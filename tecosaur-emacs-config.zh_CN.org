# SPDX-FileCopyrightText:
# SPDX-License-Identifier: MIT
# Title: Doom Emacs 配置文件
#+title: Doom Emacs Configuration
# Subtitle: 疯狂的方法、管理与动物园 --- 细致入微
#+subtitle: The Methods, Management, and Menagerie@@latex:\\@@ of Madness@@latex: --- in meticulous detail@@
#+date: @@html:<!--@@{{{git-rev}}}@@html:-->@@@@latex:\\\Large\bfseries@@ {{{modification-time(%Y-%m-%d, t)}}} @@latex:\\\normalsize\mdseries@@{{{modification-time(%H:%M, t)}}} @@latex:\acr{\lowercase{@@{{{timezone}}}@@latex:}}\iffalse@@, {{{git-rev}}}@@latex:\fi@@
#+macro: timezone (eval (substring (shell-command-to-string "date +%Z") 0 -1))
#+macro: git-rev (eval (format "@@html:<a href=\"https://github.com/tecosaur/emacs-config/commit/%1$s\" style=\"text-decoration: none\"><code style=\"padding: 0; color: var(--text-light); font-size: inherit; opacity: 0.7\">%1$s</code></a>@@@@latex:\\href{https://github.com/tecosaur/emacs-config/commit/%1$s}{\\normalsize\\texttt{%1$s}}@@" (substring (shell-command-to-string "git rev-parse --short HEAD") 0 -1)))
#+html_head: <link rel='shortcut icon' type='image/png' href='https://www.gnu.org/software/emacs/favicon.png'>
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :exports code
#+property: header-args:shell :tangle "setup.sh"
#+property: header-args :tangle no :results silent :eval no-export
#+embed: LICENCE :description MIT licence file
#+options: coverpage:yes
#+startup: fold

#+latex_class: book
#+latex_header: \usepackage[autooneside=false,automark,headsepline]{scrlayer-scrpage}
#+latex_header: \clearpairofpagestyles \renewcommand*{\chaptermarkformat}{} \renewcommand*{\sectionmarkformat}{}
#+latex_header: \ihead{\upshape\scshape\leftmark} \chead{\ifstr{\leftmark}{\rightmark}{}{\rightmark}} \ohead[\pagemark]{\pagemark}

#+begin_export html
<a href="https://github.com/tecosaur/emacs-config/"
   style="font-family: 'Open Sans'; background-image: none; color: inherit;
          text-decoration: none; position: relative; top: clamp(-26px, calc(1280px - 100vw), 0px); opacity: 0.7;">
  <img src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg"
       class="invertible" alt="GitHub Octicon"
       style="height: 1em; position: relative; top: 0.1em;">
  View on GitHub</a>&ensp;
<a href="https://www.buymeacoffee.com/tecosaur"
   style="position: relative;top: clamp(-22px, calc(1280px - 100vw), 0px);">
  <img src="https://img.shields.io/badge/Buy_me_a%C2%A0coffee-FFDD00?style=flat-square&amp;logo=buy-me-a-coffee&amp;logoColor=black"
       class="invertible" alt="Buy me a coffee"
       style="border-radius: 4px; opacity: 0.85;"></a>
#+end_export

#+begin_quote
让我们改变对程序构建的传统态度：
与其想象我们的主要任务是指导计算机做什么，
不如专注于向人们解释我们想让计算机做什么。
@@latex:\mbox{@@--- 高德纳@@latex:}@@
#+end_quote

* 引言
定制编辑器是十分值得的一件事……直到你需要离开它。多年来我一只在寻找避免这种痛苦的
方法。我发现了 [[https://github.com/cknadler/vim-anywhere][vim-anywhere]]，随后发现了 Emacs 版本的 [[https://github.com/zachcurry/emacs-anywhere][emacs-anywhere]]。对我来说这实在是太吸引人了。

另外，在线上我已经看到很多这样的段子了，我觉得这是个梗
#+begin_quote
Redditor 1: 我刚刚发现了这个东西，是不是很酷。 \\
Redditor 2: 哦，这有一个 Emacs 模式。
#+end_quote

对我来说，这足以让我安装 Emacs 了，但我很快了解了 [[https://github.com/remacs/remacs#why-emacs][更有说服力的理由]] 并开始持续使
用它。

我尝试着使用 =spacemacs= 但并不喜欢它，之后听说了 =doom emacs= 并觉得不妨一试。TLDR
它太棒了！

如今我发现了文学编程的神奇之处，Emacs 逐渐成为了我生活的一部分。这即是我的配置，
也是一个值得说道的故事。(将下面图片中的 Linux 换成 Emacs 就好)

[[xkcd:456]]

** 为什么是 Emacs?

Emacs [[https://www.eigenbahn.com/2020/01/12/emacs-is-no-editor][不是一个文本编辑器]]，这是一个常见的误会。将 Emacs 描述 *为提供以用户为中心的
通用文本操作环境的 Lisp 虚拟机* 则更为准确。真是太绕口了。
简单来说，可以将 Emacs 视为文本处理相关程序的平台。这是个模糊且通用的定义，因为
Emacs 本身就是通用的。

与文字相得益彰，那还有什么呢？当然比最初认为的要多得多：
+ [[https://orgmode.org/][任务计划]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][文件管理]]
+ [[https://github.com/akermu/emacs-libvterm][终端模拟]]
+ [[https://www.djcbsoftware.nl/code/mu/mu4e.html][邮箱客户端]]
+ [[https://www.gnu.org/software/tramp/][远程服务器工具]]
+ [[https://magit.vc/][Git 前端]]
+ Web [[https://github.com/pashky/restclient.el][客户端]] / [[https://github.com/skeeto/emacs-web-server][服务器]]
+ 还有更多……

理想情况下，可以使用 Emacs 作为处理 =输入 → 转换 → 输出= 循环的接口，即架起一座连
接人脑与信息操作的桥梁。

*** 包罗万象的编辑器
Emacs 鼓励整合其他应用的功能，让它们都能在 Emacs 里使用。为什么这样好？
+ 使用一致的、标准的一组快捷键、GUI 与编辑方式，来完成任务 --- 一次学习随处使用
+ 减少上下文切换
+ 压缩项目流程 --- 更轻松地进行集中的项目流程
+ 集成不同应用但具有相同主题的任务 --- 例如，链接到代办事项的电子邮件

Emacs 可以被认为是一个平台，你的工作流程中的各种元素都能在这里得到解决，并且具有
极高的集成潜力 --- 如果你愿意，可以打造成 *生活的* IDE。

今天，日常使用计算机的许多方面，被分割在了像一片片孤岛一样的应用中，但这往往不能
反映出我们使用计算机的 *真实* 情况。如果可以进入这奇幻般的 Emacs 世界，它能为我们
弥补这一差距。

#+name: emacs-platform
#+begin_src dot :cmd circo :file misc/emacs-platform.svg :exports none
digraph {
    graph[bgcolor="transparent"];
    node[shape="underline" penwidth="2" style="rounded,filled" fillcolor="#efefef"
          color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge[arrowhead=none color="#aaaaaa" penwidth="1.2"];
    // nodes
    "任务管理"[color="#2ec27e"]
    "电子邮箱"[color="#1c71d8"]
    "办公套件"[color="#813d9c"]
    "代码编辑"[color="#f5c211"]
    "Git前端"[color="#e66100"]
    // "新闻提要"[color="#c01c28"]
    // "个人知识库"[color="#986a44"]

    "任务管理" -> "电子邮箱"
    "任务管理" -> "办公套件"
    "任务管理" -> "代码编辑"
    "任务管理" -> "Git前端"
    // "任务管理" -> "新闻提要"
    // "任务管理" -> "个人知识库"

    "电子邮箱" -> "办公套件"
    "电子邮箱" -> "代码编辑"
    "电子邮箱" -> "Git前端"
    // "电子邮箱" -> "个人知识库"

    "办公套件" -> "代码编辑"
    "办公套件" -> "Git前端"
    // "办公套件" -> "新闻摘要"
    // "办公套件" -> "个人知识库"

    "代码编辑" -> "Git前端"

    // "新闻摘要" -> "个人知识库"
}
#+end_src

#+caption: 在 Emacs 上可以简单集成的工作流
#+attr_html: :class invertible :alt Graph of possible Emacs task integrations :style max-width:min(24em,100%)
#+attr_latex: :width 0.5linewidth
[[file:misc/emacs-platform.svg]]

*** 一些独一无二的功能

+ 递归编辑
+ 普遍的文档字符串，以及完全的内省性
+ 在可变环境中的増量修改
+ 无需特定应用启用功能
+ 允许客户端、服务器分离，启动守护进程，提供几乎无感知的启动时间

*** 问题

+ Emacs 有一些令人厌烦的奇怪操作
+ 某些方面很暴露年龄 (名称约定、API 等)
+ Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html][几乎]] 是单线程的，这意味着一些不当的操作将阻塞整个应用
+ 一些其他方面的干扰……

*** 授人以鱼不如授人以渔
#+begin_quote
Give a man a fish, and you feed him for a day. Teach a man to fish, and you feed
him for a lifetime. --- Anne Isabella\\
\\
授人以鱼，只供一餐，授人以渔，可享一生。
#+end_quote

许多主流的编辑器有着简单且美观的 [[https://code.visualstudio.com/docs/getstarted/settings][设置界面]]，其中充满了复选框、选择以及偶尔的文本。这使得
用户可以更轻松地在这些通用描述行为之间进行选择。对我来说这就像 /授人以鱼/ 。

如果你希望这些复选框只在某些特定的条件下启用怎么办？某些编辑器有工作区设置，但这可能需
要你手动设置 /每个实例/ 的值。Emmm... [[https://github.com/microsoft/vscode/issues/93153][太]][[https://github.com/microsoft/vscode/issues/93628][痛苦]][[https://github.com/microsoft/vscode/issues/8962][了]]！

如果你想将复选框的值设置为，每个文件执行表达式的结果，那需要怎么做？这就是 Emacs 等
编辑器的用武之地了。
配置 Emacs 并不是用 JSON 等文件列出设置，而是一份 *适应你的可以修改编辑器行为的可执
行程序* 。这就是 "授人以渔"。

Emacs 构建在与配置相同的编程语言之上 (Emacs [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp]], [[https://en.wikipedia.org/wiki/Emacs_Lisp][elisp]])。它有非常多的有用的文本编
辑功能，Doom 添加了一些小巧便利的功能。

如何为删除上一行添加一个快捷键？就像下面这么简单
#+name: 绑定删除上一行的快捷键
#+begin_src emacs-lisp :tangle-mode
(map! "C-d"
      (cmd! (previous-line)
            (kill-line)
            (forward-line)))
#+end_src

再举个例子，当你拆分窗口时，你希望列出当前打开的所有 /缓冲区/ (通常是文件)，就可以像这
样
#+name: 拆分时提示缓冲区
#+begin_src emacs-lisp :tangle no
(defadvice! prompt-for-buffer (&rest _)
  :after 'window-split (switch-to-buffer))
#+end_src

如果想测试它，不需要保存重启，你只需要在当前的 Emacs 缓冲区中 /执行表达式/ (
/evaluate the expression/) 就可以立即尝试它！毕竟这编辑是个 lisp 解释器。

如果想要调整行为？这是一个超紧密的迭代过程 --- 重新执行你的新版本配置。

** 编辑器比较

[[xkcd:378]]

近年我试过了 (至少花费一年时间作为我的主编辑器) 以下应用
- Python IDLE
- Komodo Edit
- Brackets
- VSCode
- 和现在使用的 Emacs

#+plot: transpose:yes type:radar min:0 max:4 ticks:4 file:"misc/editor-comparison.svg"
| Editor      | Extensibility | Ecosystem | Ease of Use | Comfort | Completion | Performance |
|-------------+---------------+-----------+-------------+---------+------------+-------------|
| IDLE        |             1 |         1 |           3 |       1 |          1 |           2 |
| VSCode      |             3 |         3 |           4 |     3.5 |          4 |           3 |
| Brackets    |           2.5 |         2 |           3 |       3 |        2.5 |           2 |
| Emacs       |             4 |         4 |           2 |       4 |        3.5 |           3 |
| Komodo Edit |             2 |         1 |           3 |       2 |          2 |           2 |

#+attr_html: :class invertible :alt Radar chart comparing my thoughts on a few editors.
#+attr_latex: :options inkscapelatex=false
[[file:misc/editor-comparison.svg]]

** 致粗心的冒险者
如果你觉得这看起来不错，这真的太棒了，我很高兴你对我所讲的感兴趣，但是：
#+begin_warning
这些配置可能有些问题，盲目的拷贝全部的代码可能会出现问题。我建议一块一块复制。
#+end_warning

如果你大胆地进行拷贝 (或有一部分在升级后不工作)，本节列出了一份依赖外部配置的列表
(此配置之外)。

+ 字典 :: 在使用 [[*Ispell][ispell]] 时，我会下载一份自定义的 SCOWL 字典。如果因为这个问题，请删除
  代码 src_elisp{(setq ispell-dictionary ...)}

我有没有提过这份配置在我对 =elisp= 没多少了解时就开始了，而这整个工作十分极客。如果你对
改进提出任何建议，无论有多少批评，我真心感谢。

[[xkcd:1513]]

*** 外部依赖

可爱的 ~doom docker~ 可以很好的诊断出缺少什么，但这些并不可以。
+ [[https://www.tug.org/texlive/][LaTeX 编译器]] 是 [[#org][org]] 与 [[*CalcTeX][CalcTeX]] 所依赖的数学公式渲染器
+ 使用无衬线字体 [[https://overpassfont.org][Overpass]]，它被用在 ~doomo-variableo-pitch-font~ 和 [[https://tecosaur.github.io/emacs-config/config.html#roam][Roam]] 生成
  的图表中。
  我选择它主要是因为其具有我希望的一些特征，即：
  - 简约、易读的风格，受 /[[https://en.wikipedia.org/wiki/Highway_Gothic][Highway Gothic]]/ 的影响，这种 Highway 风格的字体设计偏向
    于一目了然，并且在粗字重下也很好辨认。
  - 它有一点古怪，比如说字体主干上的斜切缺口。毫无疑问 [[https://en.wikipedia.org/wiki/Helvetica][Helvetica]] 是精湛的设计，但有
    时我会更喜欢时髦一点的。
+ 一些 LSP 程序。这些程序可以在 [[file:init.el][init.el]] 中查看那些有 ~+lsp~ 标记的模组。

** 当前存在的问题
*** 在守护进程中进行 push 操作
在守护进程中经常尝试 push 到远端将可能发生以下错误
#+begin_src fundamental
128 git … push -v origin refs/heads/master\:refs/heads/master
Pushing to git@github.com:tecosaur/emacs-config.git

fatal: Could not read from remote repository.

Please make sure you have the correct access rights
and the repository exists.
#+end_src

*** 未读电子邮件不适用于 Emacs 实例
我希望 Emacs 守护进程可以保持 mu4e 会话，并依然可以获取消息，如果可以那就太好了。这种
情况下我更想通过 Emacs 守护进程进行操作，这理应是可以的。

这可能涉及到 hook 进守护进程的模式行升级函数，用来写入临时文件，并在其他 Emacs 实例中
启动一个文件观察器，类似于使用 mu4e 时重建邮件索引。

* 基础配置
创建词法绑定可以 (稍微) 加速配置文件的运行。 (更多内容可以查看 [[https://nullprogram.com/blog/2016/12/22/][这篇博客]])
#+begin_src emacs-lisp :comments no
;;; config.el -*- lexical-binding: t; -*-
#+end_src

#+begin_src shell :exports none :comments no :tangle-mode (identity #o755)
#!/usr/bin/env bash
#+end_src
** 个人信息
配置有用且基础的个人信息
#+begin_src emacs-lisp
(setq user-full-name "TEC"
      user-mail-address "tec@tecosaur.com")
#+end_src
显然这可以被 GPG 或其他程序使用。

对于 ~GPG~ 我使用的是 =~/.authinfo.gpg= 来替换默认的 =~/.emacs.d= 。为什么？
因为我的 home 目录已经很乱了，这已经无所谓了，况且我曾不小心用
src_shell{rm -rf ~/.emacs.d} 删除过它。我还想尽可能地缓存这些文件，因为我家中的电脑
十分安全，而我的笔记本经常关机。
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200s (2h)
#+end_src
** 更好的默认值
*** 简单设置
浏览网页时看到了 [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]]，对比该设置与 =SPC h v= 的值，选择一些对我有
用的值，最终我选择添加这些值
#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t        ; 将文件删除到回收站
 window-combination-resize t        ; 从其他窗口获取新窗口的大小
 x-stretch-cursor t                 ; 将光标拉伸到字形宽度
 )

(setq undo-limit 104857600          ; 重置撤销限制到 100 MiB
      evil-want-fine-undo t         ; 在默认情况下插入时是一块，采用更细粒度
      auto-save-default t           ; 没有人喜欢丢失工作，我也是如此
      truncate-string-ellipsis "…"  ; Unicode 省略号相比 ascii 更好
                                    ; 同时节省 /宝贵的/ 空间
      password-cache-expiry nil     ; 我能信任我的电脑 ... 或不能?
      ;scroll-preserve-screen-position 'always
                                    ; 不要让 `点' (光标) 跳来跳去
      scroll-margin 2               ; 适当保持一点点边距
      )

(display-time-mode 1)               ; 开启时间状态栏

(unless (string-match-p "^Power N/A" (battery))  ; 笔记本电脑上
  (display-battery-mode 1)                       ; 知道还剩多少 ⚡️ 很重要
  )

(global-subword-mode 1)                          ; 识别驼峰，而不是傻瓜前进
#+end_src
*** 框大小
在 Emacs 启动时可以通过 src_shell{emacs -geometry 160x48} 这样的命令行参数来很
好的控制 Emacs 的框大小。在初始化期间调整字体大小后，大概为 ~102x31~ 。

感谢有快捷键可以让我方便的将窗口缩放到半屏、全屏，因此可以选择保守的大小启动新窗口。

在一个 Emacs 实例中创建新窗口，我们只需要将其设置为原来的 80%。

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src
*** 自动客制化
默认情况下通过自定义界面所做的修改会被添加到 =init.el= 中。我更喜欢为它们添加一个单独
的文件。只需要一点改动就可以设置并自动加载。
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file) (load custom-file))
#+end_src
*** Windows
我发现在拆分窗口后询问我想看哪个缓冲区是十分方便的，让我们实现它。

首先，我们要进入新窗口
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

之后需要弹出一个提示缓冲区
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

窗口与 /布局/ 可以通过 =SPC w r= 和 =SPC w R= 很方便的进行切换。在 Tmux 中使用快
捷键 =C-b SPC= 来切换窗口，我们也可以同样将切换窗口的快捷键放在 =SPC w SPC= 下。

用方向键来做窗口切换和交换的导航键是一个不错的选择。
#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; 方向
      "<left>"   #'evil-window-left
      "<down>"   #'evil-window-down
      "<up>"     #'evil-window-up
      "<right>"  #'evil-window-right
      ;; 交换窗口
      "C-<left>"   #'+evil/window-move-left
      "C-<down>"   #'+evil/window-move-down
      "C-<up>"     #'+evil/window-move-up
      "C-<right>"  #'+evil/window-move-right
      )
#+end_src
*** 缓冲区默认设置
我非常喜欢将新缓冲区设置为 ~org-mode~ 而非 ~fundamental-mode~
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
#+end_src

由于某些原因，添加这个 hook 会导致 hydra 出现问题，所以我现在只好采用 =SPC b o= 。

** Doom 配置
*** 模组
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
由于 Doom 的 /模块化配置/ ，我们可以在配置 Emacs 时可以做很多工作。每个模块 (开启时
) 可以提供一系列包，并进行安装 (~doom sync~) 配置应用。当然也可以增加一些标志来改变
其行为。

#+name: init.el
#+attr_html: :collapsed t
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments no
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a link to Doom's Module Index where all
;;      of our modules are listed, including what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src

**** 结构
正如你可能已经注意到的那样，这是一篇文学编程配置。Doom 对其支持良好，更多详情我们可
以通过 ~literate~ (文学) 模块了解。

在 src_elisp{:config} 中，我们使用 Doom 中非常棒的默认值，并绑定更智能的行为。(
虽然这些标记没有文档，但它们确实可用)
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src

**** 接口
可以做很多事来增强 Emacs 的功能，我猜大概需要开启 Doom 一半的模组。

#+name: doom-completion
#+begin_src emacs-lisp
(company                     ; the ultimate code completion backend
 +childframe)                ; ... when your children are better than you
;;helm                       ; the *other* search engine for love and life
;;ido                        ; the other *other* search engine...
;; (ivy                      ; a search engine for love and life
;;  +icons                   ; ... icons are nice
;;  +prescient)              ; ... I know what I want(ed)
(vertico +icons)             ; the search engine of the future
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft                       ; notational velocity for Emacs
doom                         ; what makes DOOM look the way it does
doom-dashboard               ; a nifty splash screen for Emacs
doom-quit                    ; DOOM quit-message prompts when you quit Emacs
(emoji +unicode)             ; 🙂
;;fill-column                ; a `fill-column' indicator
hl-todo                      ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
;;hydra                      ; quick documentation for related commands
;;indent-guides              ; highlighted indent columns, notoriously slow
(ligatures +extra)           ; ligatures and symbols to make your code pretty again
;;minimap                    ; show a map of the code on the side
modeline                     ; snazzy, Atom-inspired modeline, plus API
nav-flash                    ; blink the current line after jumping
;;neotree                    ; a project drawer, like NERDTree for vim
ophints                      ; highlight the region an operation acts on
(popup                       ; tame sudden yet inevitable temporary windows
 +all                        ; catch all popups that start with an asterix
 +defaults)                  ; default popup rules
;;(tabs                      ; an tab bar for Emacs
;;  +centaur-tabs)           ; ... with prettier tabs
treemacs                     ; a project drawer, like neotree but cooler
;;unicode                    ; extended unicode support for various languages
vc-gutter                    ; vcs diff in the fringe
vi-tilde-fringe              ; fringe tildes to mark beyond EOB
(window-select +numbers)     ; visually switch windows
workspaces                   ; tab emulation, persistence & separate workspaces
zen                          ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere)           ; come to the dark side, we have cookies
file-templates               ; auto-snippets for empty files
fold                         ; (nigh) universal code folding
(format)                     ; automated prettiness
;;god                        ; run Emacs commands without modifier keys
;;lispy                      ; vim for lisp, for people who don't like vim
multiple-cursors             ; editing in many places at once
;;objed                      ; text object editing for the innocent
;;parinfer                   ; turn lisp into python, sort of
rotate-text                  ; cycle region at point between text candidates
snippets                     ; my elves. They type so I don't have to
;;word-wrap                  ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)               ; making dired pretty [functional]
electric                     ; smarter, keyword-based electric-indent
(ibuffer +icons)             ; interactive buffer management
undo                         ; persistent, smarter undo for your inevitable mistakes
vc                           ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
;;eshell                     ; the elisp shell that works everywhere
;;shell                      ; simple shell REPL for Emacs
;;term                       ; basic terminal emulator for Emacs
vterm                        ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax                       ; tasing you for every semicolon you forget
(:if (executable-find "aspell") spell) ; tasing you for misspelling mispelling
grammar                      ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
ansible                      ; a crucible for infrastructure as code
;;debugger                   ; FIXME stepping through code, to help you add bugs
;;direnv                     ; be direct about your environment
docker                       ; port everything to containers
;;editorconfig               ; let someone else argue about tabs vs spaces
;;ein                        ; tame Jupyter notebooks with emacs
(eval +overlay)              ; run code, run (also, repls)
;;gist                       ; interacting with github gists
(lookup                      ; helps you navigate your code and documentation
 +dictionary                 ; dictionary/thesaurus is nice
 +docsets)                   ; ...or in Dash docsets locally
lsp                          ; Language Server Protocol
;;macos                      ; MacOS-specific commands
(magit                       ; a git porcelain for Emacs
 +forge)                     ; interface with git forges
make                         ; run make tasks from Emacs
;;pass                       ; password manager for nerds
pdf                          ; pdf enhancements
;;prodigy                    ; FIXME managing external services & code builders
rgb                          ; creating color strings
;;taskrunner                 ; taskrunner for all your projects
;;terraform                  ; infrastructure as code
;;tmux                       ; an API for interacting with tmux
upload                       ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
tty                          ; improve the terminal Emacs experience
#+end_src

**** 编程语言支持
同样使用文学编程来开启相关编程语言的包和配置，当然这些配置仅在第一次打开相关文件时启
用。

#+name: doom-lang
#+begin_src emacs-lisp
;;agda                       ; types of types of types of types...
;;beancount                  ; mind the GAAP
;;cc                         ; C/C++/Obj-C madness
;;clojure                    ; java with a lisp
;;common-lisp                ; if you've seen one lisp, you've seen them all
;;coq                        ; proofs-as-programs
;;crystal                    ; ruby at the speed of c
;;csharp                     ; unity, .NET, and mono shenanigans
data                         ; config/data formats
;;(dart +flutter)            ; paint ui and not much else
;;dhall                      ; JSON with FP sprinkles
;;elixir                     ; erlang done right
;;elm                        ; care for a cup of TEA?
emacs-lisp                   ; drown in parentheses
;;erlang                     ; an elegant language for a more civilized age
ess                          ; emacs speaks statistics
;;faust                      ; dsp, but you get to keep your soul
;;fsharp                     ; ML stands for Microsoft's Language
;;fstar                      ; (dependent) types and (monadic) effects and Z3
;;gdscript                   ; the language you waited for
;;(go +lsp)                  ; the hipster dialect
;;(haskell +lsp)             ; a language that's lazier than I am
;;hy                         ; readability of scheme w/ speed of python
;;idris                      ;
json                         ; At least it ain't XML
;;(java +meghanada)          ; the poster child for carpal tunnel syndrome
(javascript +lsp)            ; all(hope(abandon(ye(who(enter(here))))))
(julia +lsp)                 ; Python, R, and MATLAB in a blender
;;kotlin                     ; a better, slicker Java(Script)
(latex                       ; writing papers in Emacs has never been so fun
 +latexmk                    ; what else would you use?
 +cdlatex                    ; quick maths symbols
 +fold)                      ; fold the clutter away nicities
;;lean                       ; proof that mathematicians need help
;;factor                     ; for when scripts are stacked against you
;;ledger                     ; an accounting system in Emacs
lua                          ; one-based indices? one-based indices
markdown                     ; writing docs for people to ignore
;;nim                        ; python + lisp at the speed of c
;;nix                        ; I hereby declare "nix geht mehr!"
;;ocaml                      ; an objective camel
(org                         ; organize your plain life in plain text
 +pretty                     ; yessss my pretties! (nice unicode symbols)
 +dragndrop                  ; drag & drop files/images into org buffers
 ;;+hugo                     ; use Emacs for hugo blogging
 +noter                      ; enhanced PDF notetaking
 +jupyter                    ; ipython/jupyter support for babel
 +pandoc                     ; export-with-pandoc support
 +gnuplot                    ; who doesn't like pretty pictures
 ;;+pomodoro                 ; be fruitful with the tomato technique
 +present                    ; using org-mode for presentations
 +roam2)                     ; wander around notes
;;php                        ; perl's insecure younger brother
;;plantuml                   ; diagrams for confusing people more
;;purescript                 ; javascript, but functional
(python +lsp +pyright)       ; beautiful is better than ugly
;;qt                         ; the 'cutest' gui framework ever
;;racket                     ; a DSL for DSLs
;;raku                       ; the artist formerly known as perl6
;;rest                       ; Emacs as a REST client
;;rst                        ; ReST in peace
;;(ruby +rails)              ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)                  ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala                      ; java, but good
scheme                       ; a fully conniving family of lisps
sh                           ; she sells {ba,z,fi}sh shells on the C xor
;;sml                        ; no, the /other/ ML
;;solidity                   ; do you need a blockchain? No.
;;swift                      ; who asked for emoji variables?
;;terra                      ; Earth and Moon in alignment for performance.
web                          ; the tubes
yaml                         ; JSON, but readable
;;zig                        ; C, but simpler
#+end_src

**** Everything in Emacs
Everything in Emacs 实在太方便了，我无法拒绝在 Emacs 中开启 Email 和订阅模块。

#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +org +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
;;calendar                   ; A dated approach to timetabling
;;emms                       ; Multimedia in Emacs is music to my ears
everywhere                   ; *leave* Emacs!? You must be joking.
irc                          ; how neckbeards socialize
(rss +org)                   ; emacs as an RSS reader
;;twitter                    ; twitter client https://twitter.com/vnought
#+end_src

*** 视觉设置
'Fira Code' 的效果很不错，而 'Overpass' 则是其很棒的无衬线字体。我们只需调整下字号
就可以在视觉上比较舒服了。为了好玩我尝试了下 JetBrains Mono，不过目前为止我对其的感
觉很复杂，某些方面它很不错，但其他方面我更喜欢 Fira。
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "JetBrains Mono" :size 24)
      doom-big-font (font-spec :family "JetBrains Mono" :size 36)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 24)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light)
      )
#+end_src

#+attr_html: :class invertible :alt Screenshot of the fonts within Emacs.
[[https://tecosaur.com/lfs/emacs-config/screenshots/font-face.png]]

除了这些字体外，字体 [[https://github.com/SorkinType/Merriweather/][Merriweather]] 还被用于 =nov.el= 中，字体 [[https://github.com/huertatipografica/Alegreya][Alegreya]] 作为衬线比
例字体被用于 Org 文件的 =writeroom-mode= 中的 =mixed-pitch-mode= 。

比较关心外观的设置，因此我们设置一个检测函数，确保在系统中没有这些字体时可以告诉我们。

#+name: detect-missing-fonts
#+begin_src emacs-lisp
(defvar required-fonts '("JetBrainsMono.*" "Overpass" "JuliaMono"
                         "IBM Plex Mono" "Merriweather" "Alegreya"))
(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string
                    (shell-command-to-string "fc-list : family")
                    "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless
                   (delq nil (mapcar (lambda (f)
                                       (string-match-p
                                        (format "^%s$" font) f))
                                     available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                  ',missing-fonts
                                  ", "))
                       (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :no-export
<<detect-missing-fonts()>>
#+end_src

在 Doom 的 UI 初始化完成后，有字体缺失时，会爆出一个警告，并列出缺失的字体至少半秒钟。

**** 主题和模式栏

~doom-one~ 是 Doom 自带的大而全的主题，我发现其中这个 ~vibrant~ 效果更好。Doom
提供了如此丰富且不错的选择，我没有什么理由去用默认的主题。

#+begin_src emacs-lisp
(setq doom-theme 'doom-vibrant)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)
#+end_src

然而，默认情况下模式栏使用了红色字体，我可不想在编辑文件时感觉这有一些错误，因此让我
们将其改为橙色。

#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

=LF UTF-8= 是默认的文件编码方式，因此它出现在这里的意义不大。让我们继续修改模式栏，
让编码方式选择性隐藏。

#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))
(add-hook 'after-change-major-mode-hook
          #'doom-modeline-conditional-buffer-encoding)
#+end_src

**** 杂项
相对行号可以很好的知道距离目标行有多远，然后用快捷键 =C-u num <UP>= 或
=ESC num <UP>= 到达你想去的行。
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

我想设置一下更好看的默认缓冲区名称
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")
#+end_src

*** 一些辅助宏
这些是 doom 添加的一些非常有用的宏
- ~load!~ 可以相对于本文件进行外部 ~.el~ 文件的加载
- ~use-package!~ 用于配置包
- ~add-load-path!~ 将指定目录添加到 ~load-path~ 中，可以让 Emacs 在使用 ~require~ 和 ~use-package~ 时在 ~load-path~ 中进行查找
- ~map!~ 用于绑定新的快捷键

*** 允许 CLI 运行 org-babel 程序

有时我会生成一些代码包含在配置文件当中。这很好用，并且可以和 =doom sync= 一起工作。我
需要确保 Org 不会尝试确认我想运行的内容。

万幸的是 Doom 支持在 =$DOOMDIR/cli.el= 文件中写入命令，并且每次运行 CLI 命令时都会
读取该文件。因此我们可以将 ~org-confirm-babel-evaluate~ 设置为 ~nil~ 。当然还要
沉默 ~org-babel-execute-src-block~ 来避免它污染输出。

#+begin_src emacs-lisp :tangle cli.el :comments no
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)
(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))
(advice-add 'org-babel-execute-src-block :aroud #'doom-shut-up-a)
#+end_src

*** Elisp REPL

我觉得 elisp REPL (Read Eval Print Loop, 交互式解释器) 是一个不错的主意，即使它
并不是很有用 😛。我们可以在 =cli.el= 中添加一条新命令来启用 REPL。

#+begin_src emacs-lisp :tangle cli.el
(defcli! repl ((in-rlwrap-p ["--rl"] "For internal use only."))
  "Start an elisp REPL."
  (when (and (executable-find "rlwrap") (not in-rlwrap-p))
    ;; For autocomplete
    (setq autocomplete-file "/tmp/doom_elisp_repl_symbols")
    (unless (file-exists-p autocomplete-file)
      (princ "\e[0;33mInitialising autocomplete list...\e[0m\n")
      (with-temp-buffer
        (cl-do-all-symbols (s)
          (let ((sym (symbol-name s)))
            (when (string-match-p "\\`[[:ascii:]][[:ascii:]]+\\'" sym)
              (insert sym "\n"))))
        (write-region nil nil autocomplete-file)))
    (princ "\e[F")
    (throw 'exit (list "rlwrap" "-f" autocomplete-file
                       (concat doom-emacs-dir "bin/doom") "repl" "--rl")))

  (doom-initialize-packages)
  (require 'engrave-faces-ansi)
  (setq engrave-faces-ansi-color-mode '3-bit)

  ;; For some reason (require 'parent-mode) doesn't work :(
  (defun parent-mode-list (mode)
    "Return a list of MODE and all its parent modes.

The returned list starts with the parent-most mode and ends with MODE."
    (let ((result ()))
      (parent-mode--worker mode (lambda (mode)
                                  (push mode result)))
      result))
  (defun parent-mode--worker (mode func)
    "For MODE and all its parent modes, call FUNC.

FUNC is first called for MODE, then for its parent, then for the parent's
parent, and so on.

MODE shall be a symbol referring to a function.
FUNC shall be a function taking one argument."
    (funcall func mode)
    (when (not (fboundp mode))
      (signal 'void-function (list mode)))
    (let ((modefunc (symbol-function mode)))
      (if (symbolp modefunc)
          ;; Hande all the modes that use (defalias 'foo-parent-mode (stuff)) as
          ;; their parent
          (parent-mode--worker modefunc func)
        (let ((parentmode (get mode 'derived-mode-parent)))
          (when parentmode
            (parent-mode--worker parentmode func))))))
  (provide 'parent-mode)
  ;; Some extra highlighting (needs parent-mode)
  (require 'rainbow-delimiters)
  (require 'highlight-quoted)
  (require 'highlight-numbers)
  (setq emacs-lisp-mode-hook '(rainbow-delimiters-mode
                               highlight-quoted-mode
                               highlight-numbers-mode))
  ;; Pretty print
  (defun pp-sexp (sexp)
    (with-temp-buffer
      (cl-prettyprint sexp)
      (emacs-lisp-mode)
      (font-lock-ensure)
      (with-current-buffer (engrave-faces-ansi-buffer)
        (princ (string-trim (buffer-string)))
        (kill-buffer (current-buffer)))))
  ;; Now do the REPL
  (defvar accumulated-input nil)
  (while t
    (condition-case nil
        (let ((input (if accumulated-input
                         (read-string "\e[31m .\e[0m  ")
                       (read-string "\e[31mλ:\e[0m "))))
          (setq input (concat accumulated-input
                              (when accumulated-input "\n")
                              input))
          (cond
           ((string-match-p "\\`[[:space:]]*\\'" input)
            nil)
           ((string= input "exit")
            (princ "\n") (kill-emacs 0))
           (t
            (condition-case err
                (let ((input-sexp (car (read-from-string input))))
                  (setq accumulated-input nil)
                  (pp-sexp (eval input-sexp))
                  (princ "\n"))
              ;; Caused when sexp in unbalanced
              (end-of-file (setq accumulated-input input))
              (error
               (cl-destructuring-bind (backtrace &optional type data . _)
                   (cons (doom-cli--backtrace) err)
                 (princ (concat "\e[1;31mERROR:\e[0m " (get type 'error-message)))
                 (princ "\n       ")
                 (pp-sexp (cons type data))
                 (when backtrace
                   (print! (bold "Backtrace:"))
                   (print-group!
                    (dolist (frame (seq-take backtrace 10))
                      (print!
                       "%0.74s" (replace-regexp-in-string
                                 "[\n\r]" "\\\\n"
                                 (format "%S" frame))))))
                 (princ "\n")))))))
      ;; C-d causes an end-of-file error
      (end-of-file (princ "exit\n") (kill-emacs 0)))
    (unless accumulated-input (princ "\n"))))
#+end_src

*** 异步配置
Doom 为 =org-mode= 添加了 hook ~+literate-enable-recompile-h~ 。这是一个很棒
的想法，但不太符合我的口味。因为我相信我的需求相当简单，所以我把它重定义为了一个简单、
异步的函数。
#+begin_src emacs-lisp
(defvar +literate-tangle--proc nil)
(defvar +literate-tangle--proc-start-time nil)

(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (unless (getenv "__NOTANGLE")
    (let ((default-directory doom-private-dir))
      (when +literate-tangle--proc
        (message "Killing outdated tangle process...")
        (set-process-sentinel +literate-tangle--proc #'ignore)
        (kill-process +literate-tangle--proc)
        (sit-for 0.3)) ; ensure the message is seen for a bit
      (setq +literate-tangle--proc-start-time (float-time)
            +literate-tangle--proc
            (start-process "tangle-config"
                           (get-buffer-create " *tangle config*")
                           "emacs" "--batch" "--eval"
                           (format "(progn \
(require 'ox) \
(require 'ob-tangle) \
(setq org-confirm-babel-evaluate nil \
      org-inhibit-startup t \
      org-mode-hook nil \
      write-file-functions nil \
      before-save-hook nil \
      after-save-hook nil \
      vc-handled-backends nil \
      org-startup-folded nil \
      org-startup-indented nil) \
(org-babel-tangle-file \"%s\" \"%s\"))"
                                   +literate-config-file
                                   (expand-file-name (concat doom-module-config-file ".el")))))
      (set-process-sentinel +literate-tangle--proc #'+literate-tangle--sentinel)
      (run-at-time nil nil (lambda () (message "Tangling config.org"))) ; ensure shown after a save message
      "Tangling config.org...")))

(defun +literate-tangle--sentinel (process signal)
  (cond
   ((and (eq 'exit (process-status process))
         (= 0 (process-exit-status process)))
    (message "Tangled config.org sucessfully (took %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))
   ((memq (process-status process) (list 'exit 'signal))
    (pop-to-buffer (get-buffer " *tangle config*"))
    (message "Failed to tangle config.org (after %.1fs)"
             (- (float-time) +literate-tangle--proc-start-time))
    (setq +literate-tangle--proc nil))))

(defun +literate-tangle-check-finished ()
  (when (and (process-live-p +literate-tangle--proc)
             (yes-or-no-p "Config is currently retangling, would you please wait a few seconds?"))
    (switch-to-buffer " *tangle config*")
    (signal 'quit nil)))
(add-hook! 'kill-emacs-hook #'+literate-tangle-check-finished)
#+end_src

*** dashboard 快速操作

当使用 dashboard 时，我通常不会做什么操作。dashboard 有自己的行为模式，因此不必遭
受多余的按键摧残 --- 我们将一些简单、常用的命令绑定到单键上。

#+begin_src emacs-lisp
(defun +doom-dashboard-setup-modified-keymap ()
  (setq +doom-dashboard-mode-map (make-sparse-keymap))
  (map! :map +doom-dashboard-mode-map
        :desc "Find file" :ne "f" #'find-file
        :desc "Recent files" :ne "r" #'consult-recent-file
        :desc "Config dir" :ne "C" #'doom/open-private-config
        :desc "Open config.org" :ne "c" (cmd! (find-file (expand-file-name "config.org" doom-private-dir)))
        :desc "Open dotfile" :ne "." (cmd! (doom-project-find-file "~/.config/"))
        :desc "Notes (roam)" :ne "n" #'org-roam-node-find
        :desc "Switch buffer" :ne "b" #'+vertico/switch-workspace-buffer
        :desc "Switch buffers (all)" :ne "B" #'consult-buffer
        :desc "IBuffer" :ne "i" #'ibuffer
        :desc "Previous buffer" :ne "p" #'previous-buffer
        :desc "Set theme" :ne "t" #'consult-theme
        :desc "Quit" :ne "Q" #'save-buffers-kill-terminal
        :desc "Show keybindings" :ne "h" (cmd! (which-key-show-keymap '+doom-dashboard-mode-map))))

(add-transient-hook! #'+doom-dashboard-mode (+doom-dashboard-setup-modified-keymap))
(add-transient-hook! #'+doom-dashboard-mode :append (+doom-dashboard-setup-modified-keymap))
(add-hook! 'doom-init-ui-hook :append (+doom-dashboard-setup-modified-keymap))
#+end_src

不幸的是，快捷键帮助并没有按照预期工作，不过总体上还是相当不错的。

现在 dashboard 已经很方便了，那我现在需要快速调出 dashboard。
#+begin_src emacs-lisp
(map! :leader :desc "Dashboard" "d" #'+doom-dashboard/open)
#+end_src

** 其他设置
*** 编辑相互作用
**** 鼠标按钮
#+begin_src emacs-lisp
(map! :n [mouse-8] #'better-jumper-jump-backward
      :n [mouse-9] #'better-jumper-jump-forward)
#+end_src
*** 窗口标题
我更喜欢窗口展示缓冲区的名字，然后是项目文件夹 (如果可用)。
#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ? buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p) " ◉ %s" "  ●  %s")
                     project-name))))))
#+end_src

比如说我打开了一个配置文件，标题栏将显示 =config.org ● doom= ，当我修改后标题栏就
变成了 =config.org ◉ doom= 。
*** 启动画面
Emacs 可以在启动画面渲染图片，[[https://github.com/MarioRicalde][MarioRicalde]] 想出了一个 cracker (点子?)，并向我提
供了一个 Emacs 分割的图片 /E/ 。我之前使用的是黑洞的图片，我在关掉启动画面后就只用这
个 /E/ 了。

#+attr_latex: :width 0.2\linewidth
#+attr_html: :style width:20% :alt Fancy Emacs "E"
[[file:misc/splash-images/emacs-e.svg]]

现在我们调整它使其更接近主题，并随框架调整大小。

#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

现在唯一的缺陷是少了一条有趣的线，无论是一些公司的屁话、开发人员的借口，还是一个有趣 (
无用) 的事实。

以下的内容相当长，但本质上是：
+ 从 API 中获取语句
+ 将其异步插入 dashboard
+ 将 ~光标~ 移至语句
+ 在它拉取请求的几秒钟内重用最后一个语句

#+begin_src emacs-lisp
(defvar splash-phrase-source-folder
  (expand-file-name "misc/splash-phrases" doom-private-dir)
  "A folder of text files with a fun phrase on each line.")

(defvar splash-phrase-sources
  (let* ((files (directory-files splash-phrase-source-folder nil "\\.txt\\'"))
         (sets (delete-dups (mapcar
                             (lambda (file)
                               (replace-regexp-in-string "\\(?:-[0-9]+-\\w+\\)?\\.txt" "" file))
                             files))))
    (mapcar (lambda (sset)
              (cons sset
                    (delq nil (mapcar
                               (lambda (file)
                                 (when (string-match-p (regexp-quote sset) file)
                                   file))
                               files))))
            sets))
  "A list of cons giving the phrase set name, and a list of files which contain phrase components.")

(defvar splash-phrase-set
  (nth (random (length splash-phrase-sources)) (mapcar #'car splash-phrase-sources))
  "The default phrase set. See `splash-phrase-sources'.")

(defun splase-phrase-set-random-set ()
  "Set a new random splash phrase set."
  (interactive)
  (setq splash-phrase-set
        (nth (random (1- (length splash-phrase-sources)))
             (cl-set-difference (mapcar #'car splash-phrase-sources) (list splash-phrase-set))))
  (+doom-dashboard-reload t))

(defvar splase-phrase--cache nil)

(defun splash-phrase-get-from-file (file)
  "Fetch a random line from FILE."
  (let ((lines (or (cdr (assoc file splase-phrase--cache))
                   (cdar (push (cons file
                                     (with-temp-buffer
                                       (insert-file-contents (expand-file-name file splash-phrase-source-folder))
                                       (split-string (string-trim (buffer-string)) "\n")))
                               splase-phrase--cache)))))
    (nth (random (length lines)) lines)))

(defun splash-phrase (&optional set)
  "Construct a splash phrase from SET. See `splash-phrase-sources'."
  (mapconcat
   #'splash-phrase-get-from-file
   (cdr (assoc (or set splash-phrase-set) splash-phrase-sources))
   " "))

(defun doom-dashboard-phrase ()
  "Get a splash phrase, flow it over multiple lines as needed, and make fontify it."
  (mapconcat
   (lambda (line)
     (+doom-dashboard--center
      +doom-dashboard--width
      (with-temp-buffer
        (insert-text-button
         line
         'action
         (lambda (_) (+doom-dashboard-reload t))
         'face 'doom-dashboard-menu-title
         'mouse-face 'doom-dashboard-menu-title
         'help-echo "Random phrase"
         'follow-link t)
        (buffer-string))))
   (split-string
    (with-temp-buffer
      (insert (splash-phrase))
      (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
      (fill-region (point-min) (point-max))
      (buffer-string))
    "\n")
   "\n"))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

最终 doom dashboard 这些有用的命令对我不再有用。所以我关闭了这些设置，并关闭了
modeline 和 ~hl-line-mode~ ，隐藏了光标，这让 dashboard 显得格外 /清爽/ 。

#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions
             #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1)
           (hl-line-mode 1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor
            (list nil))
#+end_src

最后我们得到了一个最小化看起来非常棒的启动界面。

#+attr_html: :class invertible :alt The splash screen, just loaded.
[[https://tecosaur.com/lfs/emacs-config/screenshots/splash-screen.png]]

我当然不会忘记 ASCII 横幅！当然也是简化！
#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(",---.,-.-.,---.,---.,---."
            "|---'| | |,---||    `---."
            "`---'` ' '`---^`---'`---'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p)
  ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn  #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src

*** systemd 守护进程
我通常会使用 systemd 启动一个 Emacs 服务器
#+name: emacsclient service
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

让其开机自启动
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

出于一些原因，如果在初始化过程开始时没有开启框架，守护进程似乎并不喜欢在之后
打开框架 --- 因此 ~&& emacsclient~ 需要作为 =ExecStart= 值的一部分。

现在我们可以设置好相应桌面环境的入口，添加打开文件的默认应用。

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

不过使用守护进程启动时，我总想用其进行一些特殊的操作，所以我不在乎它会在启动时消耗一些
时间。同时用它持续运行 =mu4e= (email client)。

当然也可以作为 IRC 客户端 (=circe=) 启用，但好像在非图形会话启动时有些问题。

最后，过一会似乎新的 Emacsclient 框架开始于 =*scratch*= 缓冲区而不是
dashboard，我不太确定为什么会发生这种情况。但我更喜欢 dashboard，所以让我们确保它总
是在新框架中展现。

#+name: daemon initialisation
#+begin_src emacs-lisp
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (+mu4e-lock-add-watcher)
    (when (+mu4e-lock-available t)
      (mu4e~start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src
*** emacs 客户端别名
我经常想在终端仿真器中使用 Emacs。为了让使用更加方便，我需要声明一些别名。

然而，将简短方便的脚本放入 =~/.local/bin= 是一种有效的方法，除了允许我将别名放入别
的 shell 外，还可以做一些别的花里胡哨的操作 --- 比如：
+ 接受标准输入的数据，将其放入临时文件并立即打开它
+ 假设 ~$DISPLAY~ 没有被设置而使用 =tty= 是一个相当好的主意 (SSH 相关会话)
+ 在支持 24-bit 色彩的终端时，将 ~TERM~ 设置为 =terminfo= 来支持 24-bit 色彩
+ 将 GUI =emacsclient= 实例默认行为更改为非阻塞 (~--no-wait~)，而非使用标
  志 ~-w~

我会使用 =sh= ，但使用数组隐形参数操作实在太方便了，因此我将使用 =bash= 。相比于
=sh= 仅仅使用了数组，因此对于 =ksh= 等也应该可以工作。

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="" "${args[@]}"
fi
#+end_src

现在，可以将 =e= 与 magit 一起使用，但为了最大程度的懒惰，可以在终端中在设置一些别
名。
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src
*** 提示运行启动脚本
在配置时，内容多多少少都会存在于 =./setup.sh= 中，如果不运行终归是不好的。为了提示我
在必要时运行它，让我们为需要运行它的时候，添加一条小提示。

#+name: run-setup
#+begin_src emacs-lisp :tangle no
(if (file-exists-p "setup.sh")
    (if (string-empty-p (string-trim (with-temp-buffer (insert-file-contents "setup.sh") (buffer-string)) "#!/usr/bin/env bash"))
        (message ";; Setup script is empty")
      (message ";; Detected content in the setup script")
      (pp-to-string
       `(unless noninteractive
          (defun +config-run-setup ()
            (when (yes-or-no-p (format "%s The setup script has content. Check and run the script?"
                                       (propertize "Warning!" 'face '(bold warning))))
              (find-file (expand-file-name "setup.sh" doom-private-dir))
              (when (yes-or-no-p "Would you like to run this script?")
                (async-shell-command "./setup.sh"))))
          (add-hook! 'doom-init-ui-hook
            (run-at-time nil nil #'+config-run-setup)))))
  (message ";; setup.sh did not exist during tangle. Tangle again.")
  (pp-to-string
   `(unless noninteractive
      (add-hook! 'doom-init-ui-hook #'+literate-tangle-async-h))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<run-setup()>>
#+end_src

* 包
** 加载结构
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
这是安装包的地方，通过在 =package.el= 中使用 ~package!~ 宏来声明它们。之后在命令行中
运行 ~doom refresh~ 。
需要注意，不应该将该文件编译为字节码。
#+begin_src emacs-lisp :tangle "package.el" :comments no
;; -*- no-byte-compile: t; -*-
#+end_src

之后你需要重启 Emacs 确保改变生效！或者在最新版 doom 中运行指令 =M-x doom/reload= 。

*警告*: 不要禁用 =~/.emacs.d/core/package.el= 中列出的包。Doom 依赖这些，禁用它们
可能出现严重问题。

*** MELPA / ELPA / emacsmirror 中的包
想安装 MELPA / ELPA / emacsmirror 中的包可以采用以下语句
#+begin_src emacs-lisp
(package! some-package)
#+end_src

*** git 仓库中的包
如果你想从指定仓库中安装某个包，需要指定参数 ~:recipe~ 。你可以 [[https://github.com/raxod502/straight.el#the-recipe-format][在此]] 找到更多关于
~:recipe~ 的信息。
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

如果你安装的包中并不包含 ~PACKAGENAME.el~ 文件，或者位于 repo 的子目录中，则需要指
定 ~:recipe~ 的 ~:files~ 参数
#+begin_src emacs-lisp
(package! this-package
  :recipe (:hoet github :repo "username/repo"
           :file ("some-file.el" "src/lisp/*.el")))
#+end_src

*** 关闭内置的包
出于某些原因，你想关闭 Doom 内置的包，可以使用 ~:disable~ 属性
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src

你可以使用 ~:recipe~ 再不指定所有属性的情况下覆盖掉内建包。它将从 Doom 或 MELPA /
ELPA / Emacsmirror 寻找  ~:recipe~ 其他部分。
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

指定 ~:branch~ 可以为包指定分支或 tag。
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src

** 简便
*** Avy
#+begin_quote
来自 =:config default= 模块
#+end_quote

使用 QWERTY 布局的主行是跳到缓冲区指定位置的好方法，非常方便 …… 只不过我用的是
Colemak 布局。

#+begin_src emacs-lisp :tangle (if (= 0 (call-process "sh" nil nil nil "-c" "dmesg |grep -q 'ErgoDox'")) "yes" "no")
(after! avy
  ;; home row priorities: 8 6 4 5 - - 1 2 3 7
  (setq avy-keys '(?n ?e ?i ?s ?t ?r ?i ?a))
  )
#+end_src

*** 旋转 (窗口管理)
=rotate= 包只是增加了旋转窗口布局的能力，但这对我来说听起来不错。

#+begin_src emacs-lisp
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

*** Emacs Everywhere
这个名字就说名了一切。 它由 =:app everywhere= 加载和设置，但是当我开发时，我想将其
作为子模块的 unpin 版本使用。

#+begin_src emacs-lisp :tangle packages.el
(package! emacs-everywhere
  :recipe (:local-repo "lisp/emacs-everywhere"))
(unpin! emacs-everywhere)
#+end_src

此外，我将做出一些在 Doom 模块中没有做出的个人选择。
#+begin_src emacs-lisp
(use-package! emacs-everywhere
  :if (daemonp)
  :config
  (require 'spell-fu)
  (setq emacs-everywhere-major-mode-function #'org-mode
        emacs-everywhere-frame-name-format "Edit ∷ %s — %s")
  (defadvice! emacs-everywhere-raise-frame ()
    :after #'emacs-everywhere-set-frame-name
    (setq emacs-everywhere-frame-name (format emacs-everywhere-frame-name-format
                                (emacs-everywhere-app-class emacs-everywhere-current-app)
                                (truncate-string-to-width
                                 (emacs-everywhere-app-title emacs-everywhere-current-app)
                                 45 nil nil "…")))
    ;; need to wait till frame refresh happen before really set
    (run-with-timer 0.1 nil #'emacs-everywhere-raise-frame-1))
  (defun emacs-everywhere-raise-frame-1 ()
    (call-process "wmctrl" nil nil nil "-a" emacs-everywhere-frame-name)))
#+end_src

*** Which-key
#+begin_quote
来自 =:config default= 模块
#+end_quote

将这个弹出窗口弹出得更快些
#+begin_src emacs-lisp
(setq which-key-idle-delay 0.5) ;; I need the help, I really do
#+end_src

我认为这么多 =evil-= 出现在弹出窗口中有点过于冗长，让我们改变它，并在我们处理它的同时
做一些其他类似的调整。
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

#+attr_html: :class invertible :alt Whichkey triggered on an evil motion
[[https://tecosaur.com/lfs/emacs-config/screenshots/whichkey-evil.png]]

** 工具
*** 缩写
我以下配置需要感谢 [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][Emacs Stack Exchange 上的「在多种模式下使用统一的缩写表」]]。
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

*** 超大文件
/超大文件/ 模式允许以块 (chunk) 的形式加载大文件，优化那些大的离谱的文件的打开体验。
#+begin_src emacs-lisp :tangle packages.el
(package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
  :pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c" :disable t)
#+end_src

不要延迟加载 VLF，启动不久就直接加载它。
#+begin_src emacs-lisp
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

*** Eros
#+begin_quote
来自 =:tools eval= 模块
#+end_quote

这个包可以修改 emacs lisp 内联执行的视觉效果，让这个结果的前缀更好看一点。
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src

*** EVIL
#+begin_quote
来自 =:editor evil= 模块
#+end_quote

我想替换时，我希望这是全局的 --- 将这一行为修改为默认值。

现在 EVIL 相当关心与 VIM 默认值的行为的兼容性。不过我才不关心。有一些特殊的设定，我
更希望是别的行为，所以赶紧把它修改掉。
#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t    ; 我喜欢将 s/../.. 设置为全局默认行为
        evil-move-cursor-back nil      ; 在切换插入模式时不要将鼠标后移
        evil-kill-on-visual-paste nil  ; 不要把覆盖的文本放在剪切板中
        ))
#+end_src

我不使用 ~evil-escape-mode~ 所以我把它关闭了，而且我听说它会产生打字延迟。我不确定
这么做是否正确，但它额外带入的 ~pre-command-hook~ 对我来说没什么用，所以……
它似乎还有一个专用包，让我们阻止这个安装包，在启动时不启用它。
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

*** Consult
#+begin_quote
来自 =:completion vertico= 模块
#+end_quote

自从用了 [[Marginalia]], 不需要再用额外的标记也能很清晰的区分缓冲区与文件。

#+begin_src emacs-lisp
(after! consult
  (set-face-attribute 'consult-file nil :inherit 'consult-buffer)
  (setf (plist-get (alist-get 'perl consult-async-split-styles-alist)
                   :initial) ";"))
#+end_src

*** Magit
#+begin_quote
来自 =:tools magit= 模块
#+end_quote

[[xkcd:1597]]

Magit 超棒，感谢制作如此棒的包的 [[https://github.com/tarsius][Jonas]]!

**** 提交消息模板
为每个项目添加提交消息模板是一件简单的事。
#+begin_src emacs-lisp
(defvar +magit-project-commit-templates-alist nil
  "Alist of toplevel dirs and template strings/functions.")
(after! magit
  (defun +magit-fill-in-commit-template ()
    "Insert template from `+magit-fill-in-commit-template' if applicable."
    (when-let ((template (and (save-excursion (goto-char (point-min)) (string-match-p "\\`\\s-*$" (thing-at-point 'line)))
                              (cdr (assoc (file-name-base (directory-file-name (magit-toplevel)))
                                          +magit-project-commit-templates-alist)))))
      (goto-char (point-min))
      (insert (if (stringp template) template (funcall template)))
      (goto-char (point-min))
      (end-of-line)))
  (add-hook 'git-commit-setup-hook #'+magit-fill-in-commit-template 90))
#+end_src

在为 Org 创建提交时这特别有用，它遵循一种特定的格式，不过有时我还是会忘记 (糟糕)。
#+begin_src emacs-lisp
(after! magit
  (defun +org-commit-message-template ()
    "Create a skeleton for an Org commit message based on the staged diff."
    (let (change-data last-file file-changes temp-point)
      (with-temp-buffer
        (apply #'call-process magit-git-executable
               nil t nil
               (append
                magit-git-global-arguments
                (list "diff" "--cached")))
        (goto-char (point-min))
        (while (re-search-forward "^@@\\|^\\+\\+\\+ b/" nil t)
          (if (looking-back "^\\+\\+\\+ b/" (line-beginning-position))
              (progn
                (push (list last-file file-changes) change-data)
                (setq last-file (buffer-substring-no-properties (point) (line-end-position))
                      file-changes nil))
            (setq temp-point (line-beginning-position))
            (re-search-forward "^\\+\\|^-" nil t)
            (end-of-line)
            (cond
             ((string-match-p "\\.el$" last-file)
              (when (re-search-backward "^\\(?:[+-]? *\\|@@[ +-\\d,]+@@ \\)(\\(?:cl-\\)?\\(?:defun\\|defvar\\|defmacro\\|defcustom\\)" temp-point t)
                (re-search-forward "\\(?:cl-\\)?\\(?:defun\\|defvar\\|defmacro\\|defcustom\\) " nil t)
                (add-to-list 'file-changes (buffer-substring-no-properties (point) (forward-symbol 1)))))
             ((string-match-p "\\.org$" last-file)
              (when (re-search-backward "^[+-]\\*+ \\|^@@[ +-\\d,]+@@ \\*+ " temp-point t)
                (re-search-forward "@@ \\*+ " nil t)
                (add-to-list 'file-changes (buffer-substring-no-properties (point) (line-end-position)))))))))
      (push (list last-file file-changes) change-data)
      (setq change-data (delete '(nil nil) change-data))
      (concat
       (if (= 1 (length change-data))
           (replace-regexp-in-string "^.*/\\|.[a-z]+$" "" (caar change-data))
         "?")
       ": \n\n"
       (mapconcat
        (lambda (file-changes)
          (if (cadr file-changes)
              (format "* %s (%s): "
                      (car file-changes)
                      (mapconcat #'identity (cadr file-changes) ", "))
            (format "* %s: " (car file-changes))))
        change-data
        "\n\n"))))

  (add-to-list '+magit-project-commit-templates-alist (cons "org-mode" #'+org-commit-message-template)))
#+end_src

这依赖于 git 设置文件中的两个小项，这两项提供了在 elisp 和 Org 文件中大块的
headline 中选择的能力。
#+begin_src gitconfig
[diff "lisp"]
  xfuncname = "^(((;;;+ )|\\(|([ \t]+\\(((cl-|el-patch-)?def(un|var|macro|method|custom)|gb/))).*)$"

[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src

*** Magit delta

[[https://github.com/dandavison/delta/][Delta]] 是用 rust 实现的 git diff 语法高亮的工具。该作者还写了一个将它挂接到 magit
的 diff 视图上 (默认情况下并不会有任何语法高亮)。当然这需要 ~delta~ 二进制文件。它
被打包在某些发行版上，不过最可靠的安装方式还是通过 Rust 的包管理器 Cargo 安装。

#+begin_src shell :eval no :tangle (if (or (not (executable-find "cargo")) (executable-find "delta")) "no" "setup.sh")
cargo install git-delta
#+end_src

现在我们可以使用 delta 了
#+begin_src emacs-lisp :tangle packages.el
;; (package! magit-delta :recipe (:host github :repo "dandavison/magit-delta") :pin "56cdffd377279589aa0cb1df99455c098f1848cf")
#+end_src

顺便记得添加下 hook
#+begin_src emacs-lisp
;; (after! magit (magit-delta-mode +1))
#+end_src

有点糟糕的是现在好像不能用，我之后再好好研究研究。

*** Smerge

对于重复操作，Hydra 非常有帮助，但我更喜欢 teansient。
#+begin_src emacs-lisp
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))
(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

*** Company
#+begin_quote
来自 =:completion company= 模块
#+end_quote

我认为在大多数时候补全都很有用。不过在按键时需要等待保存。
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)
  ) ;; make aborting less annoying.
#+end_src

现在改进大多来自 ~先前选项~ 的历史记录，所以我们改进以下历史记录。
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src
**** 纯文本文件
~Ispell~ 是超级棒的检查功能，可以用在 ~text~ 、 ~markdown~ 和 ~GFM~ 中。
#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src

当然需要单独配置一下下 [[*Ispell][Ispell]]。
**** ESS
~company-dabbrev-code~ 好！快去配置！
#+begin_src emacs-lisp
(set-company-backend!
  'ess-r-mode
  '(company-R-args company-R-objects company-dabbrev-code :separate))
#+end_src

*** Projectile
#+begin_quote
来自 =:core packages= 模块
#+end_quote

通过查看文档 =SPC h f= 和 =SPC h v= 和源码可以得知，可以为 Projectile添加项目代
码目录。在我看来有些不合适。
#+begin_src emacs-lisp
(setq projectile-ignored-projects
      '("~/" "/tmp" "~/.emacs.d/.local/straight/repos/"))
(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath))
              projectile-ignored-projects)))
#+end_src

*** Ispell
**** 下载字典
让我们从 [[http://app.aspell.net/create][SCOWL Custom List / Dicionary Creator]] 获取一个好用的大词典
- size (大小) :: 80 (超大)
- spellings (拼写) :: 英语 (英国, -ise) 和 英语 (澳大利亚)
- spelling variants level (拼写变体等级) :: 0
- diacritics (变音符号) :: 保留
- extra lists (额外列表) :: hacker、罗马数字

***** Hunspell
#+begin_src shell :tangle (if (file-exists-p "/usr/share/myspell/en-custom.dic") "no" "setup.sh")
cd /tmp
curl -o "hunspell-en-custom.zip" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=hunspell'
unzip "hunspell-en-custom.zip"
sudo chown root:root en-custom.*
sudo mv en-custom.{aff,dic} /usr/share/myspell/
#+end_src
***** Aspell
#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src
**** 配置
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src

顺便一说，如果 ~company-ispell-dictionary~ 被设置为 ~nil~ ， 则会使用
~ispell-complete-word-dict~ ；而 ~ispell-alternate-dictionary~ 在此被设
置为 ~nil~ 时，则会使用之前提到的明文版本。

重点关注自己的私人字典是合理的，我们把它放在指定位置 (这意味着我更改主字典时依然可
以保留我添加的单词)。
#+begin_src emacs-lisp
(setq ispell-personal-dictionary
      (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src
*** TRAMP
关于其他很有用的功能，TRAMP 算一个，它是多协议透明远程访问 (/Transparent Remote
Access, Multiple Protocol/) 工具。简单说这是简单访问其他主机文件系统的方法。

**** 提示区域

不幸的是，TRAMP 对远程连接时 SHELL 的提示格式很挑剔，尝试使用 bash 并放宽松提示
区域的识别。

#+begin_src emacs-lisp
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern
        "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*"))  ;; default + 
#+end_src

**** 故障排除
如果远程连接的行为不符合预期，可以尝试以下方法

***** Zsh
你可能不喜欢一些转义码，让我们将其行为修改得更符合预期。
#+begin_src shell :eval no :tangle no
if [[ "$TERM" == "dumb" ]]; then
    unset zle_bracketed_paste
    unset zle
    PS1='$ '
    return
fi
#+end_src

**** Guix
[[https://guix.gnu.org/][Guix]] 将一些 TRAMP 需要的二进制文件放置在了意想不到的位置。这不是个问题，我们可以
手动帮助 TRAMP 找到它们。
#+begin_src emacs-lisp
(after! tramp
  (appendq! tramp-remote-path
            '("~/.guix-profile/bin" "~/.guix-profile/sbin"
              "/run/current-system/profile/bin"
              "/run/current-system/profile/sbin")))
#+end_src
*** 自动激活 snippets
有时按 =TAB= 实在是太蠢了。
#+begin_src emacs-lisp :tangle packages.el
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "b1a436922ba06ab9e1a5cc222f1a4f25a7697231")
#+end_src

#+begin_src emacs-lisp
(use-package! aas :commands aas-mode)
#+end_src

*** 截屏

让截屏变得轻而易举。
#+begin_src emacs-lisp :tangle packages.el
(package! screenshot :recipe (:local-repo "lisp/screenshot"))
#+end_src

#+attr_html: :class invertible :alt Example screenshot.el screenshot
[[https://tecosaur.com/lfs/emacs-config/screenshots/screenshot.png]]

只需要一点简单地配置，我们可以使用 [[https://github.com/Calinou/0x0][0x0]] 的包装文件上传脚本 (我将其重命名为
~upload~)。
#+begin_src emacs-lisp
(use-package! screenshot
  :defer t
  :config (setq screenshot-upload-fn "upload %s 2>/dev/null"))
#+end_src

*** Etrace

/Emacs Lisp Profiler/ (emacs lisp 分析器, ELP) 是记录信息的好手，但它并不善于
查看信息。 =etrace= 可以将 ELP 的结果转化为 "Chromium Catapult Trace Event
Format" (Chromium Catapult 性能视图)。这意味着 =etrace= 的输出可以加载到
[[https://www.speedscope.app/][speedscope]] 等网络应用中，方便分析视图。

#+begin_src emacs-lisp :tangle packages.el
(package! etrace :recipe (:host github :repo "aspiers/etrace"))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(use-package! etrace :after elp)
#+end_src

*** YASnippet
#+begin_quote
来自 =:editor snippets= 模块
#+end_quote

snippets 套娃谁用谁知道！
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

*** String inflection

如果你想要改变符号的匹配行为。
#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection :pin "fd7926ac17293e9124b31f706a4e8f38f6a9b855")
#+end_src

#+begin_src emacs-lisp
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase)
  :init
  (map! :leader :prefix ("c~" . "naming convention")
        :desc "cycle" "~" #'string-inflection-all-cycle
        :desc "toggle" "t" #'string-inflection-toggle
        :desc "CamelCase" "c" #'string-inflection-camelcase
        :desc "downCase" "d" #'string-inflection-lower-camelcase
        :desc "kebab-case" "k" #'string-inflection-kebab-case
        :desc "under_score" "_" #'string-inflection-underscore
        :desc "Upper_Score" "u" #'string-inflection-capital-underscore
        :desc "UP_CASE" "U" #'string-inflection-upcase)
  (after! evil
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection)))
#+end_src

*** Smart parentheses
#+begin_quote
来自 =:core packages= 模块
#+end_quote

#+begin_src emacs-lisp
(sp-local-pair '(org-mode) "<<" ">>" :actions '(insert))
#+end_src

** 视觉
*** 信息色彩
添加可变字体和着色 🙂，让 man 手册页体验更好。

#+attr_html: :class invertible :style width:80% :alt Example info-colours page.
[[https://tecosaur.com/lfs/emacs-config/screenshots/info-colours.png]]

#+begin_src emacs-lisp
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

hook 到 =Info= 启用它。
#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

#+attr_html: :class invertible :alt Example colourised info page
[[https://tecosaur.com/lfs/emacs-config/screenshots/info-coloured.png]]

*** Modus 主题
Proteolas 在 Modus 主题上做了很多很棒的工作，这也是为什么该主题在 Emacs 28 如此受
欢迎的原因。当然他的更新速度稍微有些快，我希望随时接受最新的版本。
#+begin_src emacs-lisp :tangle packages.el
(package! modus-themes :pin "59422c05e00d65582a005ccb06c3767622d14e03")
#+end_src

*** 主题魔法

有了所有的新潮朱主题，终端从此消失不见！
#+begin_src emacs-lisp :tangle packages.el
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

这个操作使用 =pywal= ，你可以通过仓库安装它，不过最简单的方式就是 =pip= 。
#+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
sudo python3 -m pip install pywal
#+end_src

Theme Magic 提供了一个数字界面，尝试从饱和度、色彩差异来有效的选取八个颜色。然而，它
可能会为 light 选择相同的颜色，并不总能够选取最佳颜色。自从使用 =doom-themes= ，
我们感到了前所未有的轻松，我们可以用 Doom themes 提供的色彩工具来轻松获取合理的配色
来生成 light 版本 --- 现在就开始！

#+begin_src emacs-lisp
(use-package! theme-magic
  :commands theme-magic-from-emacs
  :config
  (defadvice! theme-magic--auto-extract-16-doom-colors ()
    :override #'theme-magic--auto-extract-16-colors
    (list
     (face-attribute 'default :background)
     (doom-color 'error)
     (doom-color 'success)
     (doom-color 'type)
     (doom-color 'keywords)
     (doom-color 'constants)
     (doom-color 'functions)
     (face-attribute 'default :foreground)
     (face-attribute 'shadow :foreground)
     (doom-blend 'base8 'error 0.1)
     (doom-blend 'base8 'success 0.1)
     (doom-blend 'base8 'type 0.1)
     (doom-blend 'base8 'keywords 0.1)
     (doom-blend 'base8 'constants 0.1)
     (doom-blend 'base8 'functions 0.1)
     (face-attribute 'default :foreground))))
#+end_src

*** Emojify
#+begin_quote
来自 =:ui emoji= 模块.
#+end_quote

对于初学者，twitter 的 emoji 看起来比 emoji-one 好。剩下的最棒的是 OOTB 😀。

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

最烦人的一点是设置好默认字符时，使用的是 emoji 而非默认字符。这发生在我复写的 Org
符号上，比如说复选框和其他杂项。

我们可以从 emoji 散列表删除这些符号来适应我们的工作流。

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀"
    ;; I just want to see this as text
    "©" "™")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

现在最好有一个次要模式用来将输入的 ascii/gh 类型的 emoji 转化为 unicode 类型。
#+begin_src emacs-lisp
(defun emojify--replace-text-with-emoji (orig-fn emoji text buffer start end &optional target)
  "Modify `emojify--propertize-text-for-emoji' to replace ascii/github emoticons with unicode emojis, on the fly."
  (if (or (not emoticon-to-emoji) (= 1 (length text)))
      (funcall orig-fn emoji text buffer start end target)
    (delete-region start end)
    (insert (ht-get emoji "unicode"))))

(define-minor-mode emoticon-to-emoji
  "Write ascii/gh emojis, and have them converted to unicode live."
  :global nil
  :init-value nil
  (if emoticon-to-emoji
      (progn
        (setq-local emojify-emoji-styles '(ascii github unicode))
        (advice-add 'emojify--propertize-text-for-emoji :around #'emojify--replace-text-with-emoji)
        (unless emojify-mode
          (emojify-turn-on-emojify-mode)))
    (setq-local emojify-emoji-styles (default-value 'emojify-emoji-styles))
    (advice-remove 'emojify--propertize-text-for-emoji #'emojify--replace-text-with-emoji)))
#+end_src

这个新的次级模式在消息中十分好用，把它 hook 到 email 和 IRC 中。
#+begin_src emacs-lisp
(add-hook! '(mu4e-compose-mode org-msg-edit-mode circe-channel-mode) (emoticon-to-emoji 1))
#+end_src

*** Doom modeline
#+begin_quote
来自 =:ui modeline= 模块
#+end_quote

非常美观，我觉得 PDF 的 modeline 应进行一些调整。

我之前提过一个 [[https://github.com/seagle0128/doom-modeline/pull/425][issue]]，不过开发者回复的相当简单「将你的设置放在你的个人配置之中，当前
默认设置是最好的」 --- 因此我将它放在了这里。

首先我想先展示当前 buffer 的文件名与 PDF 图标。之后我将重定义两个函数来实现它。

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

*** Keycast

出于一些原因，我需要时不时地在 Emacs 进行演示操作，因此在我的屏幕上显示正在进行的操作
按键是非常有用的。虽然有 [[https://gitlab.com/screenkey/screenkey][screenkey]] 的存在，但我还是需要一些不遮挡屏幕的方法。

#+attr_html: :class invertible :alt Screenshot of Keycast-mode in action
[[https://tecosaur.com/lfs/emacs-config/screenshots/keycast.png]]

#+begin_src emacs-lisp :tangle packages.el
(package! keycast :pin "72d9add8ba16e0cae8cfcff7fc050fa75e493b4e")
#+end_src

把它设置成需要时启动吧。
#+begin_src emacs-lisp
(use-package! keycast
  :commands keycast-mode
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast--update t)
          (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast--update)
      (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
                      :height 0.9)
    '(keycast-key :inherit custom-modified
                  :height 1.1
                  :weight bold)))
#+end_src

*** screencast

与 [[Keycast]] 类似，可能也会用得上 [[https://gitlab.com/ambrevar/emacs-gif-screencast][gif-screencast]]。
#+begin_src emacs-lisp :tangle packages.el
(package! gif-screencast :pin "5517a557a17d8016c9e26b0acb74197550f829b9")
#+end_src

当然仅在使用命令加载。

我最初安装了默认捕获程序 ~scrot~ ，但我在每次启动时都会收到 ~glib error: Saving
to file file ... failed~ 。Google 并没有任何简单地修复方法，所以我改用了 [[https://github.com/naelstrof/maim][maim]]。
我们只需要将窗口 ID 传递给它，由于该值在 Emacs 实例的生命周期内不会改变，因此只需要
对单个窗口使用 ~xdotool-getactivewindow~ 就能达到非常好的效果。

似乎新颜色出现时，这往往会使 ~gifsicle~ 引入 artefacts。为了避免这种情况，我们使
用当前的 doom theme 进行预填充。

#+begin_src emacs-lisp
(use-package! gif-screencast
  :commands gif-screencast-mode
  :config
  (map! :map gif-screencast-mode-map
        :g "<f8>" #'gif-screencast-toggle-pause
        :g "<f9>" #'gif-screencast-stop)
  (setq gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))
        gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
  (defun gif-screencast-write-colormap ()
    (f-write-text
     (replace-regexp-in-string
      "\n+" "\n"
      (mapconcat (lambda (c) (if (listp (cdr c))
                                 (cadr c))) doom-themes--colors "\n"))
     'utf-8
     "/tmp/doom-color-theme" ))
  (gif-screencast-write-colormap)
  (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
#+end_src
*** Mixed pitch
#+begin_quote
来自 =:ui zen= 模块
#+end_quote

在默写模式下我还是非常想用 Mixed Pitch。如果我们只是简单增加一个 hook，在创建新的
Emacs 实例初始化 UI 之前直接使用 =mixed-pitch-mode= 打开文件时，可能发生错误。因
此创建一个 hook 在 UI 初始化之后执行
+ 条件开启 =mixed-pitch-mode=
+ 启用 mixed pitch hook

#+begin_src emacs-lisp
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

对于 mixed pitch 变量 =mixed-pitch-face= ，我们通过创建一个函数，用 serif
face 来替换默认的 mixed pitch。这是为写作室创建的。

#+begin_src emacs-lisp
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(after! mixed-pitch
  (defface variable-pitch-serif
    '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
  (setq mixed-pitch-set-height t)
  (setq variable-pitch-serif-font (font-spec :family "Alegreya" :size 27))
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src

Emacs 当前使用的是 Harfbuzz，那我们可能就会失去 Alegreya 连字特效。
#+begin_center
ff /ff/ ffi /ffi/ ffj /ffj/ ffl /ffl/
fft /fft/ fi /fi/ fj /fj/ ft /ft/
Th /Th/
#+end_center

庆幸的是将它添加到 ~composition-function-table~ 中并不麻烦。
#+begin_src emacs-lisp
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

*** Marginalia
#+begin_quote
模块 =:completion vertico= 的一部分。
#+end_quote

Marginalia 不好的一点就是文件元数据注释太简单了。特别是以下几点
+ 如果文件属性可以着色就更好了
+ 如果我拥有文件，我才不在乎文件的所属用户 / 组
+ 如果文件最近改过，这个相对时间 (比如 =2h ago=) 比日期有用
+ 指示大文件的话，体验会更好

感谢有 ~marginalia-annotator-registry~ ，我们不用再提建议了，直接自己添加一个。
#+begin_src emacs-lisp
(after! marginalia
  (setq marginalia-censor-variables nil)

  (defadvice! +marginalia--anotate-local-file-colorful (cand)
    "Just a more colourful version of `marginalia--anotate-local-file'."
    :override #'marginalia--annotate-local-file
    (when-let (attrs (file-attributes (substitute-in-file-name
                                       (marginalia--full-candidate cand))
                                      'integer))
      (marginalia--fields
       ((marginalia--file-owner attrs)
        :width 12 :face 'marginalia-file-owner)
       ((marginalia--file-modes attrs))
       ((+marginalia-file-size-colorful (file-attribute-size attrs))
        :width 7)
       ((+marginalia--time-colorful (file-attribute-modification-time attrs))
        :width 12))))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-date :foreground nil t)
                   (face-attribute 'marginalia-documentation :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color))))

  (defun +marginalia-file-size-colorful (size)
    (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
           (color (if (< size-index 10000000) ; 10m
                      (doom-blend 'orange 'green size-index)
                    (doom-blend 'red 'orange (- size-index 1)))))
      (propertize (file-size-human-readable size) 'face (list :foreground color)))))
#+end_src

*** Centaur Tabs
#+begin_quote
来自 =:ui tabs= 模块
#+end_quote

做一个美观、大小舒适 (~36~) 且带有图标的标签 (又 nice)。带有修改标记是一个好想法，
但默认的 unicode 实在是延迟太大了，所以我改为了 ~o~ ，也不会有任何问题。
对 'active-bar' 又想法？做一个！不过 ~前提~ 是打开 ~x-underline-at-decent~ 。
某种原因这似乎在 src_elisp{(after! ... )} 内不起作用 ¯\_(ツ)_/¯。默认字体不舒服
，换成无衬线字体， 'P22 Underground Book' 真是舒服多了。
#+begin_src emacs-lisp
(after! centaur-tabs
  (centaur-tabs-mode -1)
  (setq centaur-tabs-height 36
        centaur-tabs-set-icons t
        centaur-tabs-modified-marker "o"
        centaur-tabs-close-button "×"
        centaur-tabs-set-bar 'above
        centaur-tabs-gray-out-icons 'buffer)
  (centaur-tabs-change-fonts "P22 Underground Book" 160))
;; (setq x-underline-at-descent-line t)
#+end_src

*** All the icons
#+begin_quote
来自 =:core packages= 模块
#+end_quote

=all-the-icons= 是展示文件类型的通用图标，我唯一遇到的小问题是，当 /我/ 打开一个 =.m= 文件时，它更可能是 Matlab 文件，而非 Objective-C 代码。所以我要修改这个。
#+begin_src emacs-lisp
(after! all-the-icons
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))
#+end_src

*** 漂亮的分页符

一些文件采用 =^L= 作为分页符，这看起来有点丑，Steve Purcell 做了一个包，将其优化为
水平展示。
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp
(use-package! page-break-lines
  :commands page-break-lines-mode
  :init
  (autoload 'turn-on-page-break-lines-mode "page-break-lines")
  :config
  (setq page-break-lines-max-width fill-column)
  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

*** Writeroom
#+begin_quote
来自 =:ui zen= 模块
#+end_quote

对于初学者来说，Doom 十分热衷于放大
#+begin_src emacs-lisp
(setq +zen-text-scale 0.8)
#+end_src

在使用 Org 时最好进行一些美化调整，比如说：
+ 使用可变的衬线字体
+ 隐藏开头的 headline
+ 用 fleurons 作为标题符号
+ 隐藏行号
+ 移除行突出显示
+ 居中文本
+ 打开 ~org-pretty-table-mode~

#+begin_src emacs-lisp
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p nil)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (featurep 'org-superstar)
                  (setq-local org-superstar-headline-bullets-list '("🙘" "🙙" "🙚" "🙛")
                              ;; org-superstar-headline-bullets-list '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                              org-superstar-remove-leading-stars t)
                  (org-superstar-restart))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when (featurep 'org-superstar)
                  (org-superstar-restart))
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src

#+attr_html: :class invertible :alt Writeroom applied to an Org file
[[https://tecosaur.com/lfs/emacs-config/screenshots/writeroom-and-org.png]]

*** Treemacs
#+begin_quote
来自 =:ui treemacs= 模块
#+end_quote

很多时候我对多余的文件并不感兴趣，因此没有理由让它们占用显示空间，必须忽略它们的存在。
#+begin_src emacs-lisp
(after! treemacs
  (defvar treemacs-file-ignore-extensions '()
    "File extension which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-globs '()
    "Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-regexps '()
    "RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
  (defun treemacs-file-ignore-generate-regexps ()
    "Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
    (setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
  (if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
  (defun treemacs-ignore-filter (file full-path)
    "Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
    (or (member (file-name-extension file) treemacs-file-ignore-extensions)
        (let ((ignore-file nil))
          (dolist (regexp treemacs-file-ignore-regexps ignore-file)
            (setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
  (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))
#+end_src

现在识别有问题的文件。
#+begin_src emacs-lisp
(setq treemacs-file-ignore-extensions
      '(;; LaTeX
        "aux"
        "ptc"
        "fdb_latexmk"
        "fls"
        "synctex.gz"
        "toc"
        ;; LaTeX - glossary
        "glg"
        "glo"
        "gls"
        "glsdefs"
        "ist"
        "acn"
        "acr"
        "alg"
        ;; LaTeX - pgfplots
        "mw"
        ;; LaTeX - pdfx
        "pdfa.xmpi"
        ))
(setq treemacs-file-ignore-globs
      '(;; LaTeX
        "*/_minted-*"
        ;; AucTeX
        "*/.auctex-auto"
        "*/_region_.log"
        "*/_region_.tex"))
#+end_src
** Frivolities (轻浮)
*** xkcd
XKCD 漫画很有趣。
#+begin_src emacs-lisp :tangle packages.el
(package! xkcd :pin "688d0b4ea234adda0c05784e6bb22ab9d71f0884")
#+end_src

在 [[*Extra links][Extra links]] 设置更好的加载它。
#+begin_src emacs-lisp
(use-package! xkcd
  :commands (xkcd-get-json
             xkcd-download xkcd-get
             ;; now for funcs from my extension of this pkg
             +xkcd-find-and-copy +xkcd-find-and-view
             +xkcd-fetch-info +xkcd-select)
  :config
  (setq xkcd-cache-dir (expand-file-name "xkcd/" doom-cache-dir)
        xkcd-cache-latest (concat xkcd-cache-dir "latest"))
  (unless (file-exists-p xkcd-cache-dir)
    (make-directory xkcd-cache-dir))
  (after! evil-snipe
    (add-to-list 'evil-snipe-disabled-modes 'xkcd-mode))
  :general (:states 'normal
            :keymaps 'xkcd-mode-map
            "<right>" #'xkcd-next
            "n"       #'xkcd-next ; evil-ish
            "<left>"  #'xkcd-prev
            "N"       #'xkcd-prev ; evil-ish
            "r"       #'xkcd-rand
            "a"       #'xkcd-rand ; because image-rotate can interfere
            "t"       #'xkcd-alt-text
            "q"       #'xkcd-kill-buffer
            "o"       #'xkcd-open-browser
            "e"       #'xkcd-open-explanation-browser
            ;; extras
            "s"       #'+xkcd-find-and-view
            "/"       #'+xkcd-find-and-view
            "y"       #'+xkcd-copy))
#+end_src

在扩展一大堆功能。
#+begin_src emacs-lisp
(after! xkcd
  (require 'emacsql-sqlite)

  (defun +xkcd-select ()
    "Prompt the user for an xkcd using `completing-read' and `+xkcd-select-format'. Return the xkcd number or nil"
    (let* (prompt-lines
           (-dummy (maphash (lambda (key xkcd-info)
                              (push (+xkcd-select-format xkcd-info) prompt-lines))
                            +xkcd-stored-info))
           (num (completing-read (format "xkcd (%s): " xkcd-latest) prompt-lines)))
      (if (equal "" num) xkcd-latest
        (string-to-number (replace-regexp-in-string "\\([0-9]+\\).*" "\\1" num)))))

  (defun +xkcd-select-format (xkcd-info)
    "Creates each completing-read line from an xkcd info plist. Must start with the xkcd number"
    (format "%-4s  %-30s %s"
            (propertize (number-to-string (plist-get xkcd-info :num))
                        'face 'counsel-key-binding)
            (plist-get xkcd-info :title)
            (propertize (plist-get xkcd-info :alt)
                        'face '(variable-pitch font-lock-comment-face))))

  (defun +xkcd-fetch-info (&optional num)
    "Fetch the parsed json info for comic NUM. Fetches latest when omitted or 0"
    (require 'xkcd)
    (when (or (not num) (= num 0))
      (+xkcd-check-latest)
      (setq num xkcd-latest))
    (let ((res (or (gethash num +xkcd-stored-info)
                   (puthash num (+xkcd-db-read num) +xkcd-stored-info))))
      (unless res
        (+xkcd-db-write
         (let* ((url (format "https://xkcd.com/%d/info.0.json" num))
                (json-assoc
                 (if (gethash num +xkcd-stored-info)
                     (gethash num +xkcd-stored-info)
                   (json-read-from-string (xkcd-get-json url num)))))
           json-assoc))
        (setq res (+xkcd-db-read num)))
      res))

  ;; since we've done this, we may as well go one little step further
  (defun +xkcd-find-and-copy ()
    "Prompt for an xkcd using `+xkcd-select' and copy url to clipboard"
    (interactive)
    (+xkcd-copy (+xkcd-select)))

  (defun +xkcd-copy (&optional num)
    "Copy a url to xkcd NUM to the clipboard"
    (interactive "i")
    (let ((num (or num xkcd-cur)))
      (gui-select-text (format "https://xkcd.com/%d" num))
      (message "xkcd.com/%d copied to clipboard" num)))

  (defun +xkcd-find-and-view ()
    "Prompt for an xkcd using `+xkcd-select' and view it"
    (interactive)
    (xkcd-get (+xkcd-select))
    (switch-to-buffer "*xkcd*"))

  (defvar +xkcd-latest-max-age (* 60 60) ; 1 hour
    "Time after which xkcd-latest should be refreshed, in seconds")

  ;; initialise `xkcd-latest' and `+xkcd-stored-info' with latest xkcd
  (add-transient-hook! '+xkcd-select
    (require 'xkcd)
    (+xkcd-fetch-info xkcd-latest)
    (setq +xkcd-stored-info (+xkcd-db-read-all)))

  (add-transient-hook! '+xkcd-fetch-info
    (xkcd-update-latest))

  (defun +xkcd-check-latest ()
    "Use value in `xkcd-cache-latest' as long as it isn't older thabn `+xkcd-latest-max-age'"
    (unless (and (file-exists-p xkcd-cache-latest)
                 (< (- (time-to-seconds (current-time))
                       (time-to-seconds (file-attribute-modification-time (file-attributes xkcd-cache-latest))))
                    +xkcd-latest-max-age))
      (let* ((out (xkcd-get-json "http://xkcd.com/info.0.json" 0))
             (json-assoc (json-read-from-string out))
             (latest (cdr (assoc 'num json-assoc))))
        (when (/= xkcd-latest latest)
          (+xkcd-db-write json-assoc)
          (with-current-buffer (find-file xkcd-cache-latest)
            (setq xkcd-latest latest)
            (erase-buffer)
            (insert (number-to-string latest))
            (save-buffer)
            (kill-buffer (current-buffer)))))
      (shell-command (format "touch %s" xkcd-cache-latest))))

  (defvar +xkcd-stored-info (make-hash-table :test 'eql)
    "Basic info on downloaded xkcds, in the form of a hashtable")

  (defadvice! xkcd-get-json--and-cache (url &optional num)
    "Fetch the Json coming from URL.
If the file NUM.json exists, use it instead.
If NUM is 0, always download from URL.
The return value is a string."
    :override #'xkcd-get-json
    (let* ((file (format "%s%d.json" xkcd-cache-dir num))
           (cached (and (file-exists-p file) (not (eq num 0))))
           (out (with-current-buffer (if cached
                                         (find-file file)
                                       (url-retrieve-synchronously url))
                  (goto-char (point-min))
                  (unless cached (re-search-forward "^$"))
                  (prog1
                      (buffer-substring-no-properties (point) (point-max))
                    (kill-buffer (current-buffer))))))
      (unless (or cached (eq num 0))
        (xkcd-cache-json num out))
      out))

  (defadvice! +xkcd-get (num)
    "Get the xkcd number NUM."
    :override 'xkcd-get
    (interactive "nEnter comic number: ")
    (xkcd-update-latest)
    (get-buffer-create "*xkcd*")
    (switch-to-buffer "*xkcd*")
    (xkcd-mode)
    (let (buffer-read-only)
      (erase-buffer)
      (setq xkcd-cur num)
      (let* ((xkcd-data (+xkcd-fetch-info num))
             (num (plist-get xkcd-data :num))
             (img (plist-get xkcd-data :img))
             (safe-title (plist-get xkcd-data :safe-title))
             (alt (plist-get xkcd-data :alt))
             title file)
        (message "Getting comic...")
        (setq file (xkcd-download img num))
        (setq title (format "%d: %s" num safe-title))
        (insert (propertize title
                            'face 'outline-1))
        (center-line)
        (insert "\n")
        (xkcd-insert-image file num)
        (if (eq xkcd-cur 0)
            (setq xkcd-cur num))
        (setq xkcd-alt alt)
        (message "%s" title))))

  (defconst +xkcd-db--sqlite-available-p
    (with-demoted-errors "+org-xkcd initialization: %S"
      (emacsql-sqlite-ensure-binary)
      t))

  (defvar +xkcd-db--connection (make-hash-table :test #'equal)
    "Database connection to +org-xkcd database.")

  (defun +xkcd-db--get ()
    "Return the sqlite db file."
    (expand-file-name "xkcd.db" xkcd-cache-dir))

  (defun +xkcd-db--get-connection ()
    "Return the database connection, if any."
    (gethash (file-truename xkcd-cache-dir)
             +xkcd-db--connection))

  (defconst +xkcd-db--table-schema
    '((xkcds
       [(num integer :unique :primary-key)
        (year        :not-null)
        (month       :not-null)
        (link        :not-null)
        (news        :not-null)
        (safe_title  :not-null)
        (title       :not-null)
        (transcript  :not-null)
        (alt         :not-null)
        (img         :not-null)])))

  (defun +xkcd-db--init (db)
    "Initialize database DB with the correct schema and user version."
    (emacsql-with-transaction db
      (pcase-dolist (`(,table . ,schema) +xkcd-db--table-schema)
        (emacsql db [:create-table $i1 $S2] table schema))))

  (defun +xkcd-db ()
    "Entrypoint to the +org-xkcd sqlite database.
Initializes and stores the database, and the database connection.
Performs a database upgrade when required."
    (unless (and (+xkcd-db--get-connection)
                 (emacsql-live-p (+xkcd-db--get-connection)))
      (let* ((db-file (+xkcd-db--get))
             (init-db (not (file-exists-p db-file))))
        (make-directory (file-name-directory db-file) t)
        (let ((conn (emacsql-sqlite db-file)))
          (set-process-query-on-exit-flag (emacsql-process conn) nil)
          (puthash (file-truename xkcd-cache-dir)
                   conn
                   +xkcd-db--connection)
          (when init-db
            (+xkcd-db--init conn)))))
    (+xkcd-db--get-connection))

  (defun +xkcd-db-query (sql &rest args)
    "Run SQL query on +org-xkcd database with ARGS.
SQL can be either the emacsql vector representation, or a string."
    (if  (stringp sql)
        (emacsql (+xkcd-db) (apply #'format sql args))
      (apply #'emacsql (+xkcd-db) sql args)))

  (defun +xkcd-db-read (num)
    (when-let ((res
                (car (+xkcd-db-query [:select * :from xkcds
                                      :where (= num $s1)]
                                     num
                                     :limit 1))))
      (+xkcd-db-list-to-plist res)))

  (defun +xkcd-db-read-all ()
    (let ((xkcd-table (make-hash-table :test 'eql :size 4000)))
      (mapcar (lambda (xkcd-info-list)
                (puthash (car xkcd-info-list) (+xkcd-db-list-to-plist xkcd-info-list) xkcd-table))
              (+xkcd-db-query [:select * :from xkcds]))
      xkcd-table))

  (defun +xkcd-db-list-to-plist (xkcd-datalist)
    `(:num ,(nth 0 xkcd-datalist)
      :year ,(nth 1 xkcd-datalist)
      :month ,(nth 2 xkcd-datalist)
      :link ,(nth 3 xkcd-datalist)
      :news ,(nth 4 xkcd-datalist)
      :safe-title ,(nth 5 xkcd-datalist)
      :title ,(nth 6 xkcd-datalist)
      :transcript ,(nth 7 xkcd-datalist)
      :alt ,(nth 8 xkcd-datalist)
      :img ,(nth 9 xkcd-datalist)))

  (defun +xkcd-db-write (data)
    (+xkcd-db-query [:insert-into xkcds
                     :values $v1]
                    (list (vector
                           (cdr (assoc 'num        data))
                           (cdr (assoc 'year       data))
                           (cdr (assoc 'month      data))
                           (cdr (assoc 'link       data))
                           (cdr (assoc 'news       data))
                           (cdr (assoc 'safe_title data))
                           (cdr (assoc 'title      data))
                           (cdr (assoc 'transcript data))
                           (cdr (assoc 'alt        data))
                           (cdr (assoc 'img        data))
                           )))))
#+end_src

*** Selectric

每隔一段时间，你想让别人 /知道/ 你正在打字，或自娱自乐，隆重介绍：打字机的声音！
#+begin_src emacs-lisp :tangle packages.el
(package! selectric-mode :pin "1840de71f7414b7cd6ce425747c8e26a413233aa")
#+end_src

#+begin_src emacs-lisp
(use-package! selectic-mode
  :commands selectic-mode)
#+end_src

*** Wttrin

让我们快设置一下天气。草 (一种植物)，似乎 slightly 并没有有效维护
([[https://github.com/bcbcarl/emacs-wttrin/pulls][few open bugfix PRs]]) 这个包，用我们 [[https://tecosaur.github.io/emacs-config/lisp/wttrin/wttrin.el][自己的版本]] 吧。
#+begin_src emacs-lisp :tangle packages.el
(package! wttrin :recipe (:local-repo "lisp/wttrin"))
#+end_src

#+begin_src emacs-lisp
(use-package! wttrin
  :commands wttrin)
#+end_src

*** Spray

为什么不让屏幕上飞出一些单词呢？为什么！ --- 快点让它飞出来。
#+begin_src emacs-lisp
(use-package! spray
  :commands spray-mode
  :config
  (setq spray-wpm 600
        spray-height 800)
  (defun spray-mode-hide-cursor ()
    "Hide or unhide the cursor as is appropriate."
    (if spray-mode
        (setq-local spray--last-evil-cursor-state evil-normal-state-cursor
                    evil-normal-state-cursor '(nil))
      (setq-local evil-normal-state-cursor spray--last-evil-cursor-state)))
  (add-hook 'spray-mode-hook #'spray-mode-hide-cursor)
  (map! :map spray-mode-map
        "<return>" #'spray-start/stop
        "f" #'spray-faster
        "s" #'spray-slower
        "t" #'spray-time
        "<right>" #'spray-forward-word
        "h" #'spray-forward-word
        "<left>" #'spray-backward-word
        "l" #'spray-backward-word
        "q" #'spray-quit))
#+end_src

*** Elcord

除非你不断告诉身边的每个人，不然你使用 Emacs 的意义是什么？
#+begin_src emacs-lisp :tangle packages.el
(package! elcord :pin "eb4ae2e7e03a5fc26b054ba2fa9a1d308e239c76")
#+end_src

#+begin_src emacs-lisp
(use-package! elcord
  :commands elcord-mode
  :config
  (setq elcord-use-major-mode-as-main-icon t))
#+end_src

** 文件类型
*** 授权信息

我提供了一个 =authinfo-mode= 的语法高亮，不过需要 Emacs 28+ 才能用。对于旧版本，
还是用包来解决吧。

#+begin_src emacs-lisp :tangle (if (< emacs-major-version 28) "packages.el" "no")
(package! authinfo-color-mode
  :recipe (:local-repo "lisp/authinfo-color-mode"))
#+end_src

现在只需要在合适的时候加载它。
#+begin_src emacs-lisp :tangle (if (< emacs-major-version 28) "yes" "no")
(use-package! authinfo-color-mode
  :mode ("authinfo.gpg\\'" . authinfo-color-mode)
  :init (advice-add 'authinfo-mode :override #'authinfo-color-mode))
#+end_src

*** Systemd
为了编辑 Systemd 单元文件。
#+begin_src emacs-lisp :tangle packages.el
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

#+begin_src emacs-lisp
(use-package! systemd :defer t)
#+end_src

* 应用
** Ebooks
[[xkcd:548]]

为管理我的 ebook，我 hook 了已经建好的 ebook 图书管理器 [[https://calibre-ebook.com/][calibre]]。有许多这类型的
Emacs 客户端，这个是我觉得挺好的一个。
#+begin_src emacs-lisp :tangle packages.el
(package! calibredb :pin "cb93563d0ec9e0c653210bc574f9546d1e7db437")
#+end_src

为了阅读，目前唯一可用的做法似乎是 [[https://depp.brause.cc/nov.el/][nov.el]]。
#+begin_src emacs-lisp :tangle packages.el
(package! nov :pin "2b4a7231aff6211a5a2f28719d830887aec6cc57")
#+end_src

这些包一起给了我相当不错的体验。

=calibredb= 可以让我们通过 Emacs 使用 calibredb，谁不想在 Emacs 里做任何事！？

#+begin_src emacs-lisp
(use-package! calibredb
  :commands calibredb
  :config
  (setq calibredb-root-dir "~/Desktop/TEC/Other/Ebooks"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
  (map! :map calibredb-show-mode-map
        :ne "?" #'calibredb-entry-dispatch
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "q" #'calibredb-entry-quit
        :ne "." #'calibredb-open-dired
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments)
  (map! :map calibredb-search-mode-map
        :ne [mouse-3] #'calibredb-search-mouse
        :ne "RET" #'calibredb-find-file
        :ne "?" #'calibredb-dispatch
        :ne "a" #'calibredb-add
        :ne "A" #'calibredb-add-dir
        :ne "c" #'calibredb-clone
        :ne "d" #'calibredb-remove
        :ne "D" #'calibredb-remove-marked-items
        :ne "j" #'calibredb-next-entry
        :ne "k" #'calibredb-previous-entry
        :ne "l" #'calibredb-virtual-library-list
        :ne "L" #'calibredb-library-list
        :ne "n" #'calibredb-virtual-library-next
        :ne "N" #'calibredb-library-next
        :ne "p" #'calibredb-virtual-library-previous
        :ne "P" #'calibredb-library-previous
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "S" #'calibredb-switch-library
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "v" #'calibredb-view
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "." #'calibredb-open-dired
        :ne "b" #'calibredb-catalog-bib-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "r" #'calibredb-search-refresh-and-clear-filter
        :ne "R" #'calibredb-search-clear-filter
        :ne "q" #'calibredb-search-quit
        :ne "m" #'calibredb-mark-and-forward
        :ne "f" #'calibredb-toggle-favorite-at-point
        :ne "x" #'calibredb-toggle-archive-at-point
        :ne "h" #'calibredb-toggle-highlight-at-point
        :ne "u" #'calibredb-unmark-and-forward
        :ne "i" #'calibredb-edit-annotation
        :ne "DEL" #'calibredb-unmark-and-backward
        :ne [backtab] #'calibredb-toggle-view
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-n" #'calibredb-show-next-entry
        :ne "M-p" #'calibredb-show-previous-entry
        :ne "/" #'calibredb-search-live-filter
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments))
#+end_src

=nov= 让我们真真切切的阅读到了 ebook。

#+attr_html: :class invertible :alt Excerpt of the GNU Emacs manual viewed through nov.el
[[https://tecosaur.com/lfs/emacs-config/screenshots/nov.png]]

#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 81
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)

    (setq-local mode-line-format
                `((:eval
                   (doom-modeline-segment--workspace-name))
                  (:eval
                   (doom-modeline-segment--window-number))
                  (:eval
                   (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ,(* (let ((width (doom-modeline--font-width)))
                                         (or (and (= width 1) 1)
                                             (/ width (frame-char-width) 1.0)))
                                       (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                  (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

** 计算器
Emacs 包含了一个过时的计算器 =calc= ，这是一个令人印 (ji) 象 (qi) 深 (tong)
刻 (ku) 的 RPN (Reverse Polish Notation, 逆波兰表示法) 计算器。我们还是可以提高体
验的。

*** 缺省值

理智的人都喜欢弧度和精确的值。
#+begin_src emacs-lisp
(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
#+end_src

*** CalcTeX

所有人都知道 LaTeX 写的数学表达式很好看， =calc= 可以为表达式提供 LaTeX 表示，这可
以让 CalcTeX 尽情的使用。

#+begin_src emacs-lisp :tangle packages.el
(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el" "vendor"))
  :pin "67a2e76847a9ea9eff1f8e4eb37607f84b380ebb")
#+end_src

#+attr_html: :class invertible :alt Demonstration of calc, prettified by calctex.
[[https://tecosaur.com/lfs/emacs-config/screenshots/calc-with-calctex.png]]

我们喜欢使用 CalcTeX，启用它，并修复一些巨大的痛点 --- 生活在地球上，你却 /只能在
你的本地机器上/ 运算，要让这个包服务于所有人！

#+begin_src emacs-lisp
(use-package! calctex
  :commands calctex-mode
  :init
  (add-hook 'calc-mode-hook #'calctex-mode)
  :config
  (setq calctex-additional-latex-packages "
\\usepackage[usenames]{xcolor}
\\usepackage{soul}
\\usepackage{adjustbox}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{siunitx}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage{mathalpha}
\\usepackage{xparse}
\\usepackage{arevmath}"
        calctex-additional-latex-macros
        (concat calctex-additional-latex-macros
                "\n\\let\\evalto\\Rightarrow"))
  (defadvice! no-messaging-a (orig-fn &rest args)
    :around #'calctex-default-dispatching-render-process
    (let ((inhibit-message t) message-log-max)
      (apply orig-fn args)))
  ;; Fix hardcoded dvichop path (whyyyyyyy)
  (let ((vendor-folder (concat (file-truename doom-local-dir)
                               "straight/"
                               (format "build-%s" emacs-version)
                               "/calctex/vendor/")))
    (setq calctex-dvichop-sty (concat vendor-folder "texd/dvichop")
          calctex-dvichop-bin (concat vendor-folder "texd/dvichop")))
  (unless (file-exists-p calctex-dvichop-bin)
    (message "CalcTeX: Building dvichop binary")
    (let ((default-directory (file-name-directory calctex-dvichop-bin)))
      (call-process "make" nil nil nil))))
#+end_src

*** Embedded calc

在 LaTeX 数学表达式中使用嵌入式的计算器！默认的快捷键只能用操蛋来形容 (=C-x * e=)
，更改为采取基于 localleader 的方案。

#+begin_src emacs-lisp
(map! :map calc-mode-map
      :after calc
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Embedded calc (toggle)" "E" #'calc-embedded)
(map! :map latex-mode-map
      :after latex
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
#+end_src

不幸的是，计算将在没有 (内容更丰富的) 计算器和跟踪缓冲区的情况下运行，或许可以尝试放
在测面板。
#+begin_src emacs-lisp
(defvar calc-embedded-trail-window nil)
(defvar calc-embedded-calculator-window nil)

(defadvice! calc-embedded-with-side-pannel (&rest _)
  :after #'calc-do-embedded
  (when calc-embedded-trail-window
    (ignore-errors
      (delete-window calc-embedded-trail-window))
    (setq calc-embedded-trail-window nil))
  (when calc-embedded-calculator-window
    (ignore-errors
      (delete-window calc-embedded-calculator-window))
    (setq calc-embedded-calculator-window nil))
  (when (and calc-embedded-info
             (> (* (window-width) (window-height)) 1200))
    (let ((main-window (selected-window))
          (vertical-p (> (window-width) 80)))
      (select-window
       (setq calc-embedded-trail-window
             (if vertical-p
                 (split-window-horizontally (- (max 30 (/ (window-width) 3))))
               (split-window-vertically (- (max 8 (/ (window-height) 4)))))))
      (switch-to-buffer "*Calc Trail*")
      (select-window
       (setq calc-embedded-calculator-window
             (if vertical-p
                 (split-window-vertically -6)
               (split-window-horizontally (- (/ (window-width) 2))))))
      (switch-to-buffer "*Calculator*")
      (select-window main-window))))
#+end_src

** IRC
=circe= 是 Emacs 的 IRC 客户端 (这个名字+缩写简直太棒了)，还是将人变为怪物的希腊女巫
--- 喀耳刻。

还是用前面说的意思吧，用它与那些在线 +隐身+ 的人聊天！

[[xkcd:1782]]

在我们开始发消息前，我们需要从 IRC 客户端获取权限。circe 手册在 =.authinfo.gpg= 中
为我们提供了一些验证模板 --- 不过我觉得我们应该更进一步：还要整个服务器信息。

首先让我们来康康需要哪些合理的字段：
+ 服务器
+ 端口
+ SASL username
+ SASL password
+ 加入的频道

我们这样存储它们
#+begin_src authinfo
machine chat.freenode.net login USERNAME password PASSWORD port PORT for irc channels emacs,org-mode
#+end_src

~for irc~ 可以让我们为所有 IRC 验证信息设置独立的信息。忽略频道名字中的 =#= ，通过私
有 API 我们可以得到一串逗号分割的 (没有空格！) 频道名字符串。

#+name: irc-authinfo-reader
#+begin_src emacs-lisp :tangle no
(defun auth-server-pass (server)
  (if-let ((secret (plist-get (car (auth-source-search :host server)) :secret)))
      (if (functionp secret)
          (funcall secret) secret)
    (error "Could not fetch password for host %s" server)))

(defun register-irc-auths ()
  (require 'circe)
  (require 'dash)
  (let ((accounts (-filter (lambda (a) (string= "irc" (plist-get a :for)))
                           (auth-source-search :require '(:for) :max 10))))
    (appendq! circe-network-options
              (mapcar (lambda (entry)
                        (let* ((host (plist-get entry :host))
                               (label (or (plist-get entry :label) host))
                               (_ports (mapcar #'string-to-number
                                               (s-split "," (plist-get entry :port))))
                               (port (if (= 1 (length _ports)) (car _ports) _ports))
                               (user (plist-get entry :user))
                               (nick (or (plist-get entry :nick) user))
                               (channels (mapcar (lambda (c) (concat "#" c))
                                                 (s-split "," (plist-get entry :channels)))))
                          `(,label
                            :host ,host :port ,port :nick ,nick
                            :sasl-username ,user :sasl-password auth-server-pass
                            :channels ,channels)))
                      accounts))))
#+end_src

启动 Circe 时为调用 src_elisp{(register-irc-auths)} 为其添加 hook。

一切准备就绪，开始调整一两个配置文件来连接 Circe。
#+begin_src emacs-lisp
(after! circe
  (setq-default circe-use-tls t)
  (setq circe-notifications-alert-icon "/usr/share/icons/breeze/actions/24/network-connect.svg"
        lui-logging-directory "~/.emacs.d/.local/etc/irc"
        lui-logging-file-format "{buffer}/%Y/%m-%d.txt"
        circe-format-self-say "{nick:+13s} ┃ {body}")

  (custom-set-faces!
    '(circe-my-message-face :weight unspecified))

  (enable-lui-logging-globally)
  (enable-circe-display-images)

  <<org-emph-to-irc>>

  <<circe-emojis>>
  <<circe-emoji-alists>>

  (defun named-circe-prompt ()
    (lui-set-prompt
     (concat (propertize (format "%13s > " (circe-nick))
                         'face 'circe-prompt-face)
             "")))
  (add-hook 'circe-chat-mode-hook #'named-circe-prompt)

  (appendq! all-the-icons-mode-icon-alist
            '((circe-channel-mode all-the-icons-material "message" :face all-the-icons-lblue)
              (circe-server-mode all-the-icons-material "chat_bubble_outline" :face all-the-icons-purple))))

<<irc-authinfo-reader>>

(add-transient-hook! #'=irc (register-irc-auths))
#+end_src

*** Org 风格着重
在 Org 语法中，我们可以使用 *黑体* 、 /斜体/ 和 _下划线_ ，在 IRC 也这样显示。
#+name: org-emph-to-irc
#+begin_src emacs-lisp
(defun lui-org-to-irc ()
  "Examine a buffer with simple org-mode formatting, and converts the empasis:
,*bold*, /italic/, and _underline_ to IRC semi-standard escape codes.
=code= is converted to inverse (highlighted) text."
  (goto-char (point-min))
  (while (re-search-forward "\\_<\\(?1:[*/_=]\\)\\(?2:[^[:space:]]\\(?:.*?[^[:space:]]\\)?\\)\\1\\_>" nil t)
    (replace-match
     (concat (pcase (match-string 1)
               ("*" "")
               ("/" "")
               ("_" "")
               ("=" ""))
             (match-string 2)
             "") nil nil)))

(add-hook 'lui-pre-input-hook #'lui-org-to-irc)
#+end_src
*** Emojis
人人都喜欢 emojis
#+begin_src emacs-lisp
(defun lui-ascii-to-emoji ()
  (goto-char (point-min))
  (while (re-search-forward "\\( \\)?::?\\([^[:space:]:]+\\):\\( \\)?" nil t)
    (replace-match
     (concat
      (match-string 1)
      (or (cdr (assoc (match-string 2) lui-emojis-alist))
          (concat ":" (match-string 2) ":"))
      (match-string 3))
     nil nil)))

(defun lui-emoticon-to-emoji ()
  (dolist (emoticon lui-emoticons-alist)
    (goto-char (point-min))
    (while (re-search-forward (concat " " (car emoticon) "\\( \\)?") nil t)
      (replace-match (concat " "
                             (cdr (assoc (cdr emoticon) lui-emojis-alist))
                             (match-string 1))))))

(define-minor-mode lui-emojify
  "Replace :emojis: and ;) emoticons with unicode emoji chars."
  :global t
  :init-value t
  (if lui-emojify
      (add-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)
    (remove-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)))
#+end_src

看看怎么用吧
#+begin_src emacs-lisp :tangle no
(defvar lui-emojis-alist
  '(("grinning"                      . "😀")
    ("smiley"                        . "😃")
    ("smile"                         . "😄")
    ("grin"                          . "😁")
    ("laughing"                      . "😆")
    ("sweat_smile"                   . "😅")
    ("joy"                           . "😂")
    ("rofl"                          . "🤣")
    ("relaxed"                       . "☺️")
    ("blush"                         . "😊")
    ("innocent"                      . "😇")
    ("slight_smile"                  . "🙂")
    ("upside_down"                   . "🙃")
    ("wink"                          . "😉")
    ("relieved"                      . "😌")
    ("heart_eyes"                    . "😍")
    ("yum"                           . "😋")
    ("stuck_out_tongue"              . "😛")
    ("stuck_out_tongue_closed_eyes"  . "😝")
    ("stuck_out_tongue_wink"         . "😜")
    ("zanzy"                         . "🤪")
    ("raised_eyebrow"                . "🤨")
    ("monocle"                       . "🧐")
    ("nerd"                          . "🤓")
    ("cool"                          . "😎")
    ("star_struck"                   . "🤩")
    ("party"                         . "🥳")
    ("smirk"                         . "😏")
    ("unamused"                      . "😒")
    ("disapointed"                   . "😞")
    ("pensive"                       . "😔")
    ("worried"                       . "😟")
    ("confused"                      . "😕")
    ("slight_frown"                  . "🙁")
    ("frown"                         . "☹️")
    ("persevere"                     . "😣")
    ("confounded"                    . "😖")
    ("tired"                         . "😫")
    ("weary"                         . "😩")
    ("pleading"                      . "🥺")
    ("tear"                          . "😢")
    ("cry"                           . "😢")
    ("sob"                           . "😭")
    ("triumph"                       . "😤")
    ("angry"                         . "😠")
    ("rage"                          . "😡")
    ("exploding_head"                . "🤯")
    ("flushed"                       . "😳")
    ("hot"                           . "🥵")
    ("cold"                          . "🥶")
    ("scream"                        . "😱")
    ("fearful"                       . "😨")
    ("disapointed"                   . "😰")
    ("relieved"                      . "😥")
    ("sweat"                         . "😓")
    ("thinking"                      . "🤔")
    ("shush"                         . "🤫")
    ("liar"                          . "🤥")
    ("blank_face"                    . "😶")
    ("neutral"                       . "😐")
    ("expressionless"                . "😑")
    ("grimace"                       . "😬")
    ("rolling_eyes"                  . "🙄")
    ("hushed"                        . "😯")
    ("frowning"                      . "😦")
    ("anguished"                     . "😧")
    ("wow"                           . "😮")
    ("astonished"                    . "😲")
    ("sleeping"                      . "😴")
    ("drooling"                      . "🤤")
    ("sleepy"                        . "😪")
    ("dizzy"                         . "😵")
    ("zipper_mouth"                  . "🤐")
    ("woozy"                         . "🥴")
    ("sick"                          . "🤢")
    ("vomiting"                      . "🤮")
    ("sneeze"                        . "🤧")
    ("mask"                          . "😷")
    ("bandaged_head"                 . "🤕")
    ("money_face"                    . "🤑")
    ("cowboy"                        . "🤠")
    ("imp"                           . "😈")
    ("ghost"                         . "👻")
    ("alien"                         . "👽")
    ("robot"                         . "🤖")
    ("clap"                          . "👏")
    ("thumpup"                       . "👍")
    ("+1"                            . "👍")
    ("thumbdown"                     . "👎")
    ("-1"                            . "👎")
    ("ok"                            . "👌")
    ("pinch"                         . "🤏")
    ("left"                          . "👈")
    ("right"                         . "👉")
    ("down"                          . "👇")
    ("wave"                          . "👋")
    ("pray"                          . "🙏")
    ("eyes"                          . "👀")
    ("brain"                         . "🧠")
    ("facepalm"                      . "🤦")
    ("tada"                          . "🎉")
    ("fire"                          . "🔥")
    ("flying_money"                  . "💸")
    ("lighbulb"                      . "💡")
    ("heart"                         . "❤️")
    ("sparkling_heart"               . "💖")
    ("heartbreak"                    . "💔")
    ("100"                           . "💯")))

(defvar lui-emoticons-alist
  '((":)"   . "slight_smile")
    (";)"   . "wink")
    (":D"   . "smile")
    ("=D"   . "grin")
    ("xD"   . "laughing")
    (";("   . "joy")
    (":P"   . "stuck_out_tongue")
    (";D"   . "stuck_out_tongue_wink")
    ("xP"   . "stuck_out_tongue_closed_eyes")
    (":("   . "slight_frown")
    (";("   . "cry")
    (";'("  . "sob")
    (">:("  . "angry")
    (">>:(" . "rage")
    (":o"   . "wow")
    (":O"   . "astonished")
    (":/"   . "confused")
    (":-/"  . "thinking")
    (":|"   . "neutral")
    (":-|"  . "expressionless")))
#+end_src

** 新闻提要
RSS 提要是个大事 (虽然可能很多人没听过)，有什么理由不用 =elfeed= 。我真的非常喜欢
[[https://github.com/fuxialexander/doom-emacs-private-xfu/tree/master/modules/app/rss][fuxialexander]] 的配置，不过我觉得我不需要自定义模块。尝试修改一下让我们用得更舒服。

#+attr_html: :class invertible :alt Example elfeed entry
[[https://tecosaur.com/lfs/emacs-config/screenshots/elfeed.png]]

*** 快捷键
#+begin_src emacs-lisp
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :n "q" #'+rss/quit
      :n "e" #'elfeed-update
      :n "r" #'elfeed-search-untag-all-unread
      :n "u" #'elfeed-search-tag-all-unread
      :n "s" #'elfeed-search-live-filter
      :n "RET" #'elfeed-search-show-entry
      :n "p" #'elfeed-show-pdf
      :n "+" #'elfeed-search-tag-all
      :n "-" #'elfeed-search-untag-all
      :n "S" #'elfeed-search-set-filter
      :n "b" #'elfeed-search-browse-url
      :n "y" #'elfeed-search-yank)
(map! :map elfeed-show-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :nm "q" #'+rss/delete-pane
      :nm "o" #'ace-link-elfeed
      :nm "RET" #'org-ref-elfeed-add
      :nm "n" #'elfeed-show-next
      :nm "N" #'elfeed-show-prev
      :nm "p" #'elfeed-show-pdf
      :nm "+" #'elfeed-show-tag
      :nm "-" #'elfeed-show-untag
      :nm "s" #'elfeed-show-new-live-search
      :nm "y" #'elfeed-show-yank)
#+end_src
*** 可用性增强
#+begin_src emacs-lisp
(after! elfeed-search
  (set-evil-initial-state! 'elfeed-search-mode 'normal))
(after! elfeed-show-mode
  (set-evil-initial-state! 'elfeed-show-mode   'normal))

(after! evil-snipe
  (push 'elfeed-show-mode   evil-snipe-disabled-modes)
  (push 'elfeed-search-mode evil-snipe-disabled-modes))
#+end_src
*** 外观增强
#+begin_src emacs-lisp
(after! elfeed

  (elfeed-org)
  (use-package! elfeed-link)

  (setq elfeed-search-filter "@1-week-ago +unread"
        elfeed-search-print-entry-function '+rss/elfeed-search-print-entry
        elfeed-search-title-min-width 80
        elfeed-show-entry-switch #'pop-to-buffer
        elfeed-show-entry-delete #'+rss/delete-pane
        elfeed-show-refresh-function #'+rss/elfeed-show-refresh--better-style
        shr-max-image-proportion 0.6)

  (add-hook! 'elfeed-show-mode-hook (hide-mode-line-mode 1))
  (add-hook! 'elfeed-search-update-hook #'hide-mode-line-mode)

  (defface elfeed-show-title-face '((t (:weight ultrabold :slant italic :height 1.5)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (defface elfeed-show-author-face `((t (:weight light)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (set-face-attribute 'elfeed-search-title-face nil
                      :foreground 'nil
                      :weight 'light)

  (defadvice! +rss-elfeed-wrap-h-nicer ()
    "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
    :override #'+rss-elfeed-wrap-h
    (setq-local truncate-lines nil
                shr-width 120
                visual-fill-column-center-text t
                default-text-properties '(line-height 1.1))
    (let ((inhibit-read-only t)
          (inhibit-modification-hooks t))
      (visual-fill-column-mode)
      ;; (setq-local shr-current-font '(:family "Merriweather" :height 1.2))
      (set-buffer-modified-p nil)))

  (defun +rss/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer."
    (let* ((elfeed-goodies/tag-column-width 40)
           (elfeed-goodies/feed-source-column-width 30)
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat (mapconcat 'identity tags ",")))
           (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                           elfeed-goodies/tag-column-width 4))

           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left)))

      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
      (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
      (insert (propertize title 'face title-faces 'kbd-help title))
      (setq-local line-spacing 0.2)))

  (defun +rss/elfeed-show-refresh--better-style ()
    "Update the buffer to match the selected entry, using a mail-style."
    (interactive)
    (let* ((inhibit-read-only t)
           (title (elfeed-entry-title elfeed-show-entry))
           (date (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (author (elfeed-meta elfeed-show-entry :author))
           (link (elfeed-entry-link elfeed-show-entry))
           (tags (elfeed-entry-tags elfeed-show-entry))
           (tagsstr (mapconcat #'symbol-name tags ", "))
           (nicedate (format-time-string "%a, %e %b %Y %T %Z" date))
           (content (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (type (elfeed-entry-content-type elfeed-show-entry))
           (feed (elfeed-entry-feed elfeed-show-entry))
           (feed-title (elfeed-feed-title feed))
           (base (and feed (elfeed-compute-base (elfeed-feed-url feed)))))
      (erase-buffer)
      (insert "\n")
      (insert (format "%s\n\n" (propertize title 'face 'elfeed-show-title-face)))
      (insert (format "%s\t" (propertize feed-title 'face 'elfeed-search-feed-face)))
      (when (and author elfeed-show-entry-author)
        (insert (format "%s\n" (propertize author 'face 'elfeed-show-author-face))))
      (insert (format "%s\n\n" (propertize nicedate 'face 'elfeed-log-date-face)))
      (when tags
        (insert (format "%s\n"
                        (propertize tagsstr 'face 'elfeed-search-tag-face))))
      ;; (insert (propertize "Link: " 'face 'message-header-name))
      ;; (elfeed-insert-link link link)
      ;; (insert "\n")
      (cl-loop for enclosure in (elfeed-entry-enclosures elfeed-show-entry)
               do (insert (propertize "Enclosure: " 'face 'message-header-name))
               do (elfeed-insert-link (car enclosure))
               do (insert "\n"))
      (insert "\n")
      (if content
          (if (eq type 'html)
              (elfeed-insert-html content base)
            (insert content))
        (insert (propertize "(empty)\n" 'face 'italic)))
      (goto-char (point-min))))

  )
#+end_src
*** 功能性增强
#+begin_src emacs-lisp
(after! elfeed-show
  (require 'url)

  (defvar elfeed-pdf-dir
    (expand-file-name "pdfs/"
                      (file-name-directory (directory-file-name elfeed-enclosure-default-dir))))

  (defvar elfeed-link-pdfs
    '(("https://www.jstatsoft.org/index.php/jss/article/view/v0\\([^/]+\\)" . "https://www.jstatsoft.org/index.php/jss/article/view/v0\\1/v\\1.pdf")
      ("http://arxiv.org/abs/\\([^/]+\\)" . "https://arxiv.org/pdf/\\1.pdf"))
    "List of alists of the form (REGEX-FOR-LINK . FORM-FOR-PDF)")

  (defun elfeed-show-pdf (entry)
    (interactive
     (list (or elfeed-show-entry (elfeed-search-selected :ignore-region))))
    (let ((link (elfeed-entry-link entry))
          (feed-name (plist-get (elfeed-feed-meta (elfeed-entry-feed entry)) :title))
          (title (elfeed-entry-title entry))
          (file-view-function
           (lambda (f)
             (when elfeed-show-entry
               (elfeed-kill-buffer))
             (pop-to-buffer (find-file-noselect f))))
          pdf)

      (let ((file (expand-file-name
                   (concat (subst-char-in-string ?/ ?, title) ".pdf")
                   (expand-file-name (subst-char-in-string ?/ ?, feed-name)
                                     elfeed-pdf-dir))))
        (if (file-exists-p file)
            (funcall file-view-function file)
          (dolist (link-pdf elfeed-link-pdfs)
            (when (and (string-match-p (car link-pdf) link)
                       (not pdf))
              (setq pdf (replace-regexp-in-string (car link-pdf) (cdr link-pdf) link))))
          (if (not pdf)
              (message "No associated PDF for entry")
            (message "Fetching %s" pdf)
            (unless (file-exists-p (file-name-directory file))
              (make-directory (file-name-directory file) t))
            (url-copy-file pdf file)
            (funcall file-view-function file))))))

  )
#+end_src

** 字典
Doom 已经在采用 =define-word= 并用 [[https://github.com/gromnitsky/wordnut][wordnut]] 提供了私有服务。但是使用离线字典有一些巨
大的优势，比如：
+ 速度
+ 集成多个字典

[[http://goldendict.org/][GoldenDict]] 似乎是当前可用的最好的选择，不过缺少 CLI。因此，退回使用 [[https://dushistov.github.io/sdcv/][sdcv]] (StarDict
的 CLI 版本) 吧。使用接口，用我的 =lexic= 包吧。

#+attr_html: :class invertible :alt Screenshot of the lexic-mode view of "literate"
[[https://tecosaur.com/lfs/emacs-config/screenshots/lexic.png]]

#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "packages.el" "no")
(package! lexic :recipe (:local-repo "lisp/lexic"))
#+end_src

GoldenDict CLI 在 GitHub 上是 [[https://github.com/goldendict/goldendict/issues/37][最受好评的问题]]，应该很快就能从 ~sdcv~ 切换过来了。

自从 GoldenDict 支持 StarDict 文件，切换的痛点应该会少很多。

我们首先加载 =词典= ，然后集成到预先定义的函数 (比如
~+lookup/dictionary-definition~)。
#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "yes" "no")
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

现在替换 wordnet。
#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "yes" "no")
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override #'+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
#+end_src

最后一步，我想确定我有一些词典。我在网上放了词典的压缩包，如果系统中没有就可以直接下载。
#+begin_src shell :tangle (if (and (executable-find "sdsv") (not (file-exists-p (concat (or (getenv "STARDICT_DATA_DIR") (concat (or "~/.local/share" (getenv "XDG_DATA_HOME")) "/stardict")) "/dic")))) "setup.sh" "no")
DIC_FOLDER=${STARDICT_DATA_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/stardict}/dic
if [ ! -d "$DIC_FOLDER" ]; then
    TMP="$(mktemp -d /tmp/dict-XXX)"
    cd "$TMP"
    curl -A "Mozilla/4.0" -o "stardict.tar.gz" "https://tecosaur.com/resources/config/stardict.tar.gz"
    tar -xf "stardict.tar.gz"
    rm "stardict.tar.gz"
    mkdir -p "$DIC_FOLDER"
    mv * "$DIC_FOLDER"
fi
#+end_src

** Mail
[[xkcd:1467]]

*** 拉取
这有一些相似的竞争关系的应用：
+ [[https://www.offlineimap.org/][OfflineIMAP]] ([[https://wiki.archlinux.org/index.php/OfflineIMAP][ArchWiki page]])
+ [[http://isync.sourceforge.net/mbsync.html][isync/mbsync]] ([[https://wiki.archlinux.org/index.php/isync][ArchWiki page]])


仔细翻阅 r/emacs，一会发现主流观点似乎是
+ isync 超快
+ isync 超可靠
还不快用！

这个配置很简单，直接放在 [[file:~/.mbsyncrc][~/.mbsyncrc]] 里就行。我目前为止成功连接到了 Gmail、
office365mail 和 dovecot。我也是将密码保存在 [[file:authinfo.gpg][authinfo.gpg]] 中，用 ~PassCmd~ 拉
取使用它们：
#+begin_src shell :tangle no :eval no
gpg2 -q --for-your-eyes-only --no-tty -d ~/.authinfo.gpg | awk '/machine IMAP_SERCER login EMAIL_ADDR/ {print $NF}'
#+end_src

我们可以在 systemd service 文件中或其他什么中运行 ~mbsync -a~ ，但我们要做的更好
。[[https://github.com/vsemyonoff/easymail#usage][vsemyonoff/easymail]] 似乎是我们想要的类型，但不幸的是它写的 =很少= (??? but is
written for =notmuch= unfortunately)。我们应该使用 [[https://gitlab.com/shackra/goimapnotify][goimapnotify]] 同步新邮件。
这意味着需要另一个配置文件 :(

安装！
#+begin_src shell :eval no :tangle (if (and (executable-find "mu") (not (executable-find "goimapnotify"))) "setup.sh" "no")
go get -u gitlab.com/shackra/goimapnotify
ln -s ~/.local/share/go/bin/goimapnotify ~/.local/bin/
#+end_src

这是总体计划：
1. 使用 ~goimapnotify~ 监视邮箱。
   这需要我们自己设置配置文件和 =systemd= service，真 tmd 痛苦。写一个 python
   脚本终结这痛苦吧，顺便让他自己通过解析 [[file:~/.mbsyncrc][~/.mbsyncrc]] 做配置文件和 systemd。
2. 对新邮件，使用 ~mbsync --pull --new ACCOUNT:BOX~ 。
   对于尝试尽可能具体，所以 ~mbsync~ 尽可能快地返回，我们 /尽快接收 email/ 。
3. 尝试运行 ~mu index --lazy-fetch~ 。
   如果 mu4e 已经打开而失败 (由于数据库上锁)，这种情况下我们创建一个临时文件
   (=/tmp/mu_reindex_now=)。
4. 另外，我们在运行 mu4e 时，让 Emacs 每秒检查一次文件 =/tmp/mu_reindex_now=
   是否存在，存在就使用 ~mu4e-update-index~ (删除文件后)。

开始着手处理 elisp 方面的事吧。

**** 使用 mu4e 重建邮件索引
#+begin_src emacs-lisp
(after! mu4e
  (defvar mu4e-reindex-request-file "/tmp/mu_reindex_now"
    "Location of the reindex request, signaled by existance")
  (defvar mu4e-reindex-request-min-seperation 5.0
    "Don't refresh again until this many second have elapsed.
Prevents a series of redisplays from being called (when set to an appropriate value)")

  (defvar mu4e-reindex-request--file-watcher nil)
  (defvar mu4e-reindex-request--file-just-deleted nil)
  (defvar mu4e-reindex-request--last-time 0)

  (defun mu4e-reindex-request--add-watcher ()
    (setq mu4e-reindex-request--file-just-deleted nil)
    (setq mu4e-reindex-request--file-watcher
          (file-notify-add-watch mu4e-reindex-request-file
                                 '(change)
                                 #'mu4e-file-reindex-request)))

  (defadvice! mu4e-stop-watching-for-reindex-request ()
    :after #'mu4e~proc-kill
    (if mu4e-reindex-request--file-watcher
        (file-notify-rm-watch mu4e-reindex-request--file-watcher)))

  (defadvice! mu4e-watch-for-reindex-request ()
    :after #'mu4e~proc-start
    (mu4e-stop-watching-for-reindex-request)
    (when (file-exists-p mu4e-reindex-request-file)
      (delete-file mu4e-reindex-request-file))
    (mu4e-reindex-request--add-watcher))

  (defun mu4e-file-reindex-request (event)
    "Act based on the existance of `mu4e-reindex-request-file'"
    (if mu4e-reindex-request--file-just-deleted
        (mu4e-reindex-request--add-watcher)
      (when (equal (nth 1 event) 'created)
        (delete-file mu4e-reindex-request-file)
        (setq mu4e-reindex-request--file-just-deleted t)
        (mu4e-reindex-maybe t))))

  (defun mu4e-reindex-maybe (&optional new-request)
    "Run `mu4e~proc-index' if it's been more than
`mu4e-reindex-request-min-seperation'seconds since the last request,"
    (let ((time-since-last-request (- (float-time)
                                      mu4e-reindex-request--last-time)))
      (when new-request
        (setq mu4e-reindex-request--last-time (float-time)))
      (if (> time-since-last-request mu4e-reindex-request-min-seperation)
          (mu4e~proc-index nil t)
        (when new-request
          (run-at-time (* 1.1 mu4e-reindex-request-min-seperation) nil
                       #'mu4e-reindex-maybe))))))
#+end_src

**** 配置转码和服务管理
只要 =mbsyncrc= 文件存在，就像运行一样简单
#+begin_src shell :tangle (if (and (executable-find "mu") (not (file-exists-p "~/.config/imapnotify"))) "setup.sh" "no")
~/.config/doom/misc/mbsync-imapnotify.py
#+end_src

没有添加标记运行时，将执行以下操作
+ 读取并解析 [[file:~/.mbsyncrc][~/.mbsyncrc]]，指定识别以下属性
  - ~IMAPAccount~
  - ~Host~
  - ~Port~
  - ~User~
  - ~Password~
  - ~PassCmd~
  - ~Patterns~
+ 运行 ~mbsync --list ACCOUNT~ ，并采用 ~模式~ 过滤结果
+ 为每个帐号构建 imapnotify 配置，并添加以下 hook
  - onNewMail :: src_shell{mbsync --pull ACCOUNT:MAILBOX}
  - onNewMailPost :: src_shell{if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi}
+ 比较帐号表中的帐号与之前的帐号，启用/禁用相关的 systemd 服务，并用 ~--now~ 标
  记启动 (启用或停止服务)

这个脚本还支持以下参数
+ ~--status~ 获取相关 systemd 服务的信息，包括 =active= 、 =failing= 和
  =disabled=
+ ~--enable~ 可以开启相关所有的 systemd 服务
+ ~--disable~ 可以关闭相关所有的 systemd 服务
#+begin_src python :tangle misc/mbsync-imapnotify.py :shebang "#!/usr/bin/env python3"
from pathlib import Path
import json
import re
import shutil
import subprocess
import sys
import fnmatch

mbsyncFile = Path("~/.mbsyncrc").expanduser()

imapnotifyConfigFolder = Path("~/.config/imapnotify/").expanduser()
imapnotifyConfigFolder.mkdir(exist_ok=True)
imapnotifyConfigFilename = "notify.conf"

imapnotifyDefault = {
    "host": "",
    "port": 993,
    "tls": True,
    "tlsOptions": {"rejectUnauthorized": True},
    "onNewMail": "",
    "onNewMailPost": "if mu index --lazy-check; then test -f /tmp/mu_reindex_now && rm /tmp/mu_reindex_now; else touch /tmp/mu_reindex_now; fi",
}


def stripQuotes(string):
    if string[0] == '"' and string[-1] == '"':
        return string[1:-1].replace('\\"', '"')


mbsyncInotifyMapping = {
    "Host": (str, "host"),
    "Port": (int, "port"),
    "User": (str, "username"),
    "Password": (str, "password"),
    "PassCmd": (stripQuotes, "passwordCmd"),
    "Patterns": (str, "_patterns"),
}

oldAccounts = [d.name for d in imapnotifyConfigFolder.iterdir() if d.is_dir()]

currentAccount = ""
currentAccountData = {}

successfulAdditions = []


def processLine(line):
    newAcc = re.match(r"^IMAPAccount ([^#]+)", line)

    linecontent = re.sub(r"(^|[^\\])#.*", "", line).split(" ", 1)
    if len(linecontent) != 2:
        return

    parameter, value = linecontent

    if parameter == "IMAPAccount":
        if currentAccountNumber > 0:
            finaliseAccount()
        newAccount(value)
    elif parameter in mbsyncInotifyMapping.keys():
        parser, key = mbsyncInotifyMapping[parameter]
        currentAccountData[key] = parser(value)
    elif parameter == "Channel":
        currentAccountData["onNewMail"] = f"mbsync --pull --new {value}:'%s'"


def newAccount(name):
    global currentAccountNumber
    global currentAccount
    global currentAccountData
    currentAccountNumber += 1
    currentAccount = name
    currentAccountData = {}
    print(f"\n\033[1;32m{currentAccountNumber}\033[0;32m - {name}\033[0;37m")


def accountToFoldername(name):
    return re.sub(r"[^A-Za-z0-9]", "", name)


def finaliseAccount():
    if currentAccountNumber == 0:
        return

    global currentAccountData
    try:
        currentAccountData["boxes"] = getMailBoxes(currentAccount)
    except subprocess.CalledProcessError as e:
        print(
            f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
            + f"`{' '.join(e.cmd)}' returned code {e.returncode}\033[0;37m"
        )
        return
    except subprocess.TimeoutExpired as e:
        print(
            f"\033[1;31mError:\033[0;31m failed to fetch mailboxes (skipping): "
            + f"`{' '.join(e.cmd)}' timed out after {e.timeout:.2f} seconds\033[0;37m"
        )
        return

    if "_patterns" in currentAccountData:
        currentAccountData["boxes"] = applyPatternFilter(
            currentAccountData["_patterns"], currentAccountData["boxes"]
        )

    # strip not-to-be-exported data
    currentAccountData = {
        k: currentAccountData[k] for k in currentAccountData if k[0] != "_"
    }

    parametersSet = currentAccountData.keys()
    currentAccountData = {**imapnotifyDefault, **currentAccountData}
    for key, val in currentAccountData.items():
        valColor = "\033[0;33m" if key in parametersSet else "\033[0;37m"
        print(f"  \033[1;37m{key:<13} {valColor}{val}\033[0;37m")

    if (
            len(currentAccountData["boxes"]) > 15
            and "@gmail.com" in currentAccountData["username"]
    ):
        print(
            "  \033[1;31mWarning:\033[0;31m Gmail raises an error when more than"
            + "\033[1;31m15\033[0;31m simultanious connections are attempted."
            + "\n           You are attempting to monitor "
            + f"\033[1;31m{len(currentAccountData['boxes'])}\033[0;31m mailboxes.\033[0;37m"
        )

    configFile = (
        imapnotifyConfigFolder
        / accountToFoldername(currentAccount)
        / imapnotifyConfigFilename
    )
    configFile.parent.mkdir(exist_ok=True)

    json.dump(currentAccountData, open(configFile, "w"), indent=2)
    print(f" \033[0;35mConfig generated and saved to {configFile}\033[0;37m")

    global successfulAdditions
    successfulAdditions.append(accountToFoldername(currentAccount))


def getMailBoxes(account):
    boxes = subprocess.run(
        ["mbsync", "--list", account], check=True, stdout=subprocess.PIPE, timeout=10.0
    )
    return boxes.stdout.decode("utf-8").strip().split("\n")


def applyPatternFilter(pattern, mailboxes):
    patternRegexs = getPatternRegexes(pattern)
    return [m for m in mailboxes if testPatternRegexs(patternRegexs, m)]


def getPatternRegexes(pattern):
    def addGlob(b):
        blobs.append(b.replace('\\"', '"'))
        return ""

    blobs = []
    pattern = re.sub(r' ?"([^"]+)"', lambda m: addGlob(m.groups()[0]), pattern)
    blobs.extend(pattern.split(" "))
    blobs = [
        (-1, fnmatch.translate(b[1::])) if b[0] == "!" else (1, fnmatch.translate(b))
        for b in blobs
    ]
    return blobs


def testPatternRegexs(regexCond, case):
    for factor, regex in regexCond:
        if factor * bool(re.match(regex, case)) < 0:
            return False
    return True


def processSystemdServices():
    keptAccounts = [acc for acc in successfulAdditions if acc in oldAccounts]
    freshAccounts = [acc for acc in successfulAdditions if acc not in oldAccounts]
    staleAccounts = [acc for acc in oldAccounts if acc not in successfulAdditions]

    if keptAccounts:
        print(f"\033[1;34m{len(keptAccounts)}\033[0;34m kept accounts:\033[0;37m")
        restartAccountSystemdServices(keptAccounts)

    if freshAccounts:
        print(f"\033[1;32m{len(freshAccounts)}\033[0;32m new accounts:\033[0;37m")
        enableAccountSystemdServices(freshAccounts)
    else:
        print(f"\033[0;32mNo new accounts.\033[0;37m")

    notActuallyEnabledAccounts = [
        acc for acc in successfulAdditions if not getAccountServiceState(acc)["enabled"]
    ]
    if notActuallyEnabledAccounts:
        print(
            f"\033[1;32m{len(notActuallyEnabledAccounts)}\033[0;32m accounts need re-enabling:\033[0;37m"
        )
        enableAccountSystemdServices(notActuallyEnabledAccounts)

    if staleAccounts:
        print(f"\033[1;33m{len(staleAccounts)}\033[0;33m removed accounts:\033[0;37m")
        disableAccountSystemdServices(staleAccounts)
    else:
        print(f"\033[0;33mNo removed accounts.\033[0;37m")


def enableAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;32m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "enable", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;32m enabled")


def disableAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;33m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "disable", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;33m disabled")


def restartAccountSystemdServices(accounts):
    for account in accounts:
        print(f" \033[0;34m - \033[1;37m{account:<18}", end="\033[0;37m", flush=True)
        if setSystemdServiceState(
                "restart", f"goimapnotify@{accountToFoldername(account)}.service"
        ):
            print("\033[1;34m restarted")


def setSystemdServiceState(state, service):
    try:
        enabler = subprocess.run(
            ["systemctl", "--user", state, service, "--now"],
            check=True,
            stderr=subprocess.DEVNULL,
            timeout=5.0,
        )
        return True
    except subprocess.CalledProcessError as e:
        print(
            f" \033[1;31mfailed\033[0;31m to {state}, `{' '.join(e.cmd)}'"
            + f"returned code {e.returncode}\033[0;37m"
        )
    except subprocess.TimeoutExpired as e:
        print(f" \033[1;31mtimed out after {e.timeout:.2f} seconds\033[0;37m")
        return False


def getAccountServiceState(account):
    return {
        state: bool(
            1
            - subprocess.run(
                [
                    "systemctl",
                    "--user",
                    f"is-{state}",
                    "--quiet",
                    f"goimapnotify@{accountToFoldername(account)}.service",
                ],
                stderr=subprocess.DEVNULL,
            ).returncode
        )
        for state in ("enabled", "active", "failing")
    }


def getAccountServiceStates(accounts):
    for account in accounts:
        enabled, active, failing = getAccountServiceState(account).values()
        print(f"  - \033[1;37m{account:<18}\033[0;37m ", end="", flush=True)
        if not enabled:
            print("\033[1;33mdisabled\033[0;37m")
        elif active:
            print("\033[1;32mactive\033[0;37m")
        elif failing:
            print("\033[1;31mfailing\033[0;37m")
        else:
            print("\033[1;35min an unrecognised state\033[0;37m")


if len(sys.argv) > 1:
    if sys.argv[1]   in ["-e", "--enable"]:
        enableAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-d", "--disable"]:
        disableAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-r", "--restart"]:
        restartAccountSystemdServices(oldAccounts)
        exit()
    elif sys.argv[1] in ["-s", "--status"]:
        getAccountServiceStates(oldAccounts)
        exit()
    elif sys.argv[1] in ["-h", "--help"]:
        print("""\033[1;37mMbsync to IMAP Notify config generator.\033[0;37m

Usage: mbsync-imapnotify [options]

Options:
    -e, --enable       enable all services
    -d, --disable      disable all services
    -r, --restart      restart all services
    -s, --status       fetch the status for all services
    -h, --help         show this help
""", end='')
        exit()
    else:
        print(f"\033[0;31mFlag {sys.argv[1]} not recognised, try --help\033[0;37m")
        exit()


mbsyncData = open(mbsyncFile, "r").read()

currentAccountNumber = 0

totalAccounts = len(re.findall(r"^IMAPAccount", mbsyncData, re.M))


def main():
    print("\033[1;34m:: MbSync to Go IMAP notify config file creator ::\033[0;37m")

    shutil.rmtree(imapnotifyConfigFolder)
    imapnotifyConfigFolder.mkdir(exist_ok=False)
    print("\033[1;30mImap Notify config dir purged\033[0;37m")

    print(f"Identified \033[1;32m{totalAccounts}\033[0;32m accounts.\033[0;37m")

    for line in mbsyncData.split("\n"):
        processLine(line)

    finaliseAccount()

    print(
        f"\nConfig files generated for \033[1;36m{len(successfulAdditions)}\033[0;36m"
        + f" out of \033[1;36m{totalAccounts}\033[0;37m accounts.\n"
    )

    processSystemdServices()


if __name__ == "__main__":
    main()
#+end_src

*** 索引 / 搜索
这由 [[https://www.djcbsoftware.nl/code/mu/][Mu]] 来解决。这是一个查找以 [[http://en.wikipedia.org/wiki/Maildir][Maildir]] 格式存储的 emai 的工具。根据其主页介绍，它
的主要功能如下：
+ 快速索引
+ 良好的搜索
+ 支持加密和签名消息
+ 丰富的 CLI 工具
+ 规范化重音与大小写
+ 强大的集成 email 客户端

不过很遗憾，我没有打包 ~mu~ ，我只是想从源码构建它，需要这些依赖
+ =gmime-devel=
+ =xapian-core-devel=

#+name: Install mu from source
#+begin_src shell :eval no :tangle (if (and (file-directory-p "~/.mail") (not (executable-find "mu"))) "setup.sh" "no")
cd ~/.local/lib/
git clone https://github.com/djcb/mu.git
cd ./mu
./autogen.sh
make
sudo make install
#+end_src

检查我的版本是不是最新发布的：

#+begin_src shell :tangle no
curl --silent "https://api.github.com/repos/djcb/mu/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/'
mu --version | head -n 1 | sed 's/.* version //'
#+end_src

#+results:
| 1.4.6 |
| 1.4.6 |
*** 发送
[[https://www.nongnu.org/smtpmail/][SmtpMail]] 似乎是 '默认的' 出发点，但不是我的，但 [[https://marlam.de/msmtp/][msmtp]] 是。所以我会试一试。仔细阅读
(比如 google "msmtp vs sendmail")，会发现几乎所有的比较都表明 msmtp 是更好的选
择。我看到了这些观点
+ ~sendmail~ 有严重漏洞
+ ~sendmail~ 有繁琐的配置
+ ~ssmtp~ 很久没维护了
+ ~msmtp~ 是 ~ssmtp~ 的维护替代品
+ ~msmtp~ 的配置很简单

配置文件是 [[file:~/.config/msmtp/config][~/.config/msmtp/config]]。

**** 系统黑客
不幸的是在我的打包版本中似乎有一个 [[https://bugs.archlinux.org/task/44994][bug]]，因此采用最新版源码的方式安装。

对于用户 ~auth~ 操作，我需要 =GNU SASL= ，我并没有打包它。我不觉得我想用它，但我
确实需要。
#+name: 从源码安装 gsasl
#+begin_src shell :eval no :tangle (if (and (executable-find "mu") (not (executable-find "msmtp"))) "setup.sh" "no")
export GSASL_VERSION=1.8.1
cd ~/.local/lib/
curl "ftp://ftp.gnu.org/gnu/gsasl/libgsasl-$GSASL_VERSION.tar.gz" | tar xz
curl "ftp://ftp.gnu.org/gnu/gsasl/gsasl-$GSASL_VERSION.tar.gz" | tar xz
cd "./libgsasl-$GSASL_VERSION"
./configure
make
sudo make install
cd ..
cd "./gsasl-$VERSION"
./configure
make
sudo make install
cd ..
#+end_src

编译 ~msmtp~
#+name: 从源码安装 msmtp
#+begin_src shell :eval no :tangle (if (and (executable-find "mu") (not (executable-find "msmtp"))) "setup.sh" "no")
cd ~/.local/lib/
git clone https://github.com/marlam/msmtp-mirror.git ./msmtp
cd ./msmtp
libtoolize --force
aclocal
autoheader
automake --force-missing --add-missing
autoconf
# if using GSASL
# PKG_CONFIG_PATH=/usr/local/lib/pkgconfig ./configure --with-libgsasl
./configure
make
sudo make install
#+end_src

如果很早就开始使用 =GSASL= ，我们需要确定动态链接库是否在库目录中。我们可以将一个
与更早安装的同名的可执行文件添加到 ~$PATH~ 中。
#+begin_src sh :tangle no :shebang "#!/bin/sh"
LD_LIBRARY_PATH=/usr/local/lib exec /usr/local/bin/msmtp "$@"
#+end_src

*** Mu4e
:PROPERTIES:
:header-args:emacs-lisp: :tangle no :noweb-ref mu4e-conf
:END:

Webmail 客户端非常的全且棒，但我依然不相信浏览器中的 SPAs 可以替换桌面的应用……对不
起了 Gmail。我也越来越不喜欢 Google 了。

Mailspring 是近十年的桌面客户端，轻量的 electron (大概是因为后端是 =C= ，应该很有
帮助)，但是我怀念 Emacs。

=Notmuch= 看起来挺不错，我听说过关于它的一些正面评价，不过它似乎没有对邮件本身有任何
修改。所有数据都存储在 Notmuch 的数据库中。这是一个很有意思的模型，偶尔我需要将邮件
拉取到我的手机上，因此我不希望将标签或文件夹应用在邮件上 --- 不存储在数据库中。

另一方面，Mu4e 也有很多积极的讨论，并且似乎有一个强大的功能 --- 修改邮件本身 (无需访
问数据库)。 =Mu4e= 同样也拥有大量的用户群体，往往与更好的支持与关注有关。

当采用源码安装 mu4e 时，我需要将 =/usr/local/= 加入加载目录以便让 mu4e 可以加载。

#+begin_src emacs-lisp :tangle (if (file-directory-p "/usr/local/share/emacs/site-lisp/mu4e") "yes" "no")
(add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")
#+end_src

也有可能需要 =/usr/share/= 目录。
#+begin_src emacs-lisp :tangle (if (file-directory-p "/usr/share/emacs/site-lisp/mu4e") "yes" "no")
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
#+end_src

把所有 emacs 代码都放在 src_elisp{(after! ...)} 块中。
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! mu4e
  <<mu4e-conf>>
)
#+end_src

**** 浏览邮件
使用 Gnus 的文章视图 (例如内联图像) 似乎有一些优势，从 [[https://github.com/djcb/mu/pull/1442#issuecomment-591695814][djcb/mu!1442 (评论)]] 来
看，这似乎是 mu4e 的 「未来之路」。

有一些 all-the-icons 字体相关的问题，所以我们需要重新定义花哨的字符，并确保它们是
正确的宽度。

由于每个标志字符的宽度增加，并进行更多的视觉调整，我们将对标题进行一些调整。

#+begin_src emacs-lisp
(setq mu4e-headers-fields
      '((:flags . 6)
        (:account-stripe . 2)
        (:from-or-to . 25)
        (:folder . 10)
        (:recipnum . 2)
        (:subject . 80)
        (:human-date . 8))
      +mu4e-min-header-frame-width 142
      mu4e-headers-date-format "%d/%m/%y"
      mu4e-headers-time-format "⧖ %H:%M"
      mu4e-headers-results-limit 1000
      mu4e-index-cleanup t)

(add-to-list 'mu4e-bookmarks
             '(:name "Yesterday's messages" :query "date:2d..1d" :key ?y) t)

(defvar +mu4e-header--folder-colors nil)
(appendq! mu4e-header-info-custom
          '((:folder .
             (:name "Folder" :shortname "Folder" :help "Lowest level folder" :function
              (lambda (msg)
                (+mu4e-colorize-str
                 (replace-regexp-in-string "\\`.*/" "" (mu4e-message-field msg :maildir))
                 '+mu4e-header--folder-colors))))))
#+end_src

我们还将使用更好的警报图标
#+begin_src emacs-lisp
(setq mu4e-alert-icon "/usr/share/icons/Papirus/64x64/apps/evolution.svg")
#+end_src
**** 发送邮件
开始发送邮件！
#+begin_src emacs-lisp
(setq sendmail-program "/usr/bin/msmtp"
      send-mail-function #'smtpmail-send-it
      message-sendmail-f-is-evil t
      message-sendmail-extra-arguments '("--read-envelope-from"); , "--read-recipients")
      message-send-mail-function #'message-send-mail-with-sendmail)
#+end_src

避免意外使用错误的帐户发送电子邮件。如果我们可以从 "收件人" 字段中的地址发送，让我
们这样做，否则明智的做法是打开提示。

我们可以使用 desktop 文件将 Emacs 注册为潜在的电子邮件客户端。我们可以在 =Exec=
字段中放置一个 =emacsclient ...= 条目，但我发现这有点不靠谱。相反，让我们将
=emacslient= 行为打包到一个小的可执行文件 =~/.local/bin/emacsmail= 中。

#+begin_src shell :tangle ~/.local/bin/emacsmail :shebang "#!/usr/bin/env sh" :mkdirp yes :tangle-mode (identity #o755) :comments no
emacsclient -create-frame --alternate-editor='' --no-wait --eval \
"(progn (x-focus-frame nil) (mu4e-compose-from-mailto \"$1\" t))"
#+end_src

现在我们可以在 desktop 文件中使用它。

#+begin_src conf :tangle ~/.local/share/applications/emacsmail.desktop :mkdirp yes
[Desktop Entry]
Name=Mu4e
GenericName=Compose a new message with Mu4e in Emacs
Comment=Open mu4e compose window
MimeType=x-scheme-handler/mailto;
Exec=emacsmail %u
Icon=emacs
Type=Application
Terminal=false
Categories=Network;Email;
StartupWMClass=Emacs
#+end_src

注册！
#+begin_src shell :tangle (if (or (not (executable-find "mu")) (string= (shell-command-to-string "xdg-mime query default x-scheme-handler/mailto") "emacsmail.desktop\n")) "no" "setup.sh")
update-desktop-database ~/.local/share/applications
#+end_src

再定义一个 ~mu4e-compose-from-mailto~ 吧。
#+begin_src emacs-lisp
(defun mu4e-compose-from-mailto (mailto-string &optional quit-frame-after)
  (require 'mu4e)
  (unless mu4e~server-props (mu4e t) (sleep-for 0.1))
  (let* ((mailto (message-parse-mailto-url mailto-string))
         (to (cdr (assoc "To" mailto)))
         (subject (or (cdr (assoc "Subject" mailto)) ""))
         (body (cdr (assoc "Body" mailto)))
         (headers (-filter (lambda (spec) (not (-contains-p '("To" "Subject" "Body") (car spec)))) mailto)))
    (when-let ((mu4e-main (get-buffer mu4e-main-buffer-name)))
      (switch-to-buffer mu4e-main))
    (mu4e~compose-mail to subject headers)
    (when body
      (goto-char (point-min))
      (if (eq major-mode 'org-msg-edit-mode)
          (org-msg-goto-body)
        (mu4e-compose-goto-bottom))
      (insert body))
    (goto-char (point-min))
    (cond ((null to) (search-forward "To: "))
          ((string= "" subject) (search-forward "Subject: "))
          (t (if (eq major-mode 'org-msg-edit-mode)
                 (org-msg-goto-body)
               (mu4e-compose-goto-bottom))))
    (font-lock-ensure)
    (when evil-normal-state-minor-mode
      (evil-append 1))
    (when quit-frame-after
      (add-hook 'kill-buffer-hook
                `(lambda ()
                   (when (eq (selected-frame) ,(selected-frame))
                     (delete-frame)))))))
#+end_src

在起草时更改预填 =From:= 的名称也很好。
#+begin_src emacs-lisp
(defvar mu4e-from-name "Timothy"
  "Name used in \"From:\" template.")
(defadvice! mu4e~draft-from-construct-renamed (orig-fn)
  "Wrap `mu4e~draft-from-construct-renamed' to change the name."
  :around #'mu4e~draft-from-construct
  (let ((user-full-name mu4e-from-name))
    (funcall orig-fn)))
#+end_src

使用签名也不错，
#+begin_src emacs-lisp
(setq message-signature mu4e-from-name)
#+end_src
**** 在 Org mailing 列表下工作
***** 添加 =X-Woof= 头
我在 Org 邮件列表 (ML) 上相当活跃。 Org ML 有一个链接的错误/补丁跟踪器，
https://updates.orgmode.org/ 由 Woof 管理。但是，我觉得我花了太多时间来查
找合适的标头以更新错误和补丁的状态。我需要的是某种方便的工具。让我们写一个。

首先，一个函数询问我想要做什么并返回适当的 X-Woof 标头。
#+begin_src emacs-lisp
(defun +mu4e-get-woof-header ()
  (pcase (read-char
          (format "\
%s
  %s Declare %s Applied %s Aborted
%s
  %s Confirm %s Fixed
%s
  %s Request %s Resolved

%s remove X-Woof header"
                  (propertize "Patch" 'face 'outline-3)
                  (propertize "p" 'face '(bold consult-key))
                  (propertize "a" 'face '(bold consult-key))
                  (propertize "c" 'face '(bold consult-key))
                  (propertize "Bug" 'face 'outline-3)
                  (propertize "b" 'face '(bold consult-key))
                  (propertize "f" 'face '(bold consult-key))
                  (propertize "Help" 'face 'outline-3)
                  (propertize "h" 'face '(bold consult-key))
                  (propertize "r" 'face '(bold consult-key))
                  (propertize "x" 'face '(bold error))))
    (?p "X-Woof-Patch: confirmed")
    (?a "X-Woof-Patch: applied")
    (?c "X-Woof-Patch: cancelled")
    (?b "X-Woof-Bug: confirmed")
    (?f "X-Woof-Bug: fixed")
    (?h "X-Woof-Help: confirmed")
    (?r "X-Woof-Help: cancelled")
    (?x 'delete)))
#+end_src

现在我们只需要一个将这样的头添加到缓冲区的函数中
#+begin_src emacs-lisp
(defun +mu4e-insert-woof-header ()
  "Insert an X-Woof header into the current message."
  (interactive)
  (when-let ((header (+mu4e-get-woof-header)))
    (save-excursion
      (goto-char (point-min))
      (search-forward "--text follows this line--")
      (unless (eq header 'delete)
        (beginning-of-line)
        (insert header "\n")
        (forward-line -1))
      (when (re-search-backward "^X-Woof-" nil t)
        (kill-whole-line)))))

(map! :map mu4e-compose-mode-map
      :localleader
      :desc "Insert X-Woof Header" "w" #'+mu4e-insert-woof-header)

(map! :map org-msg-edit-mode-map
      :after org-msg
      :localleader
      :desc "Insert X-Woof Header" "w" #'+mu4e-insert-woof-header)
#+end_src

太棒了！这应该使添加这些头变得轻而易举。

***** 修正工作流

从 ML 测试补丁目前比它需要的更麻烦。让我们改变它。
#+begin_src emacs-lisp
(after! mu4e
  (defvar +org-ml-target-dir "~/.emacs.d/.local/straight/repos/org-mode/")
  (defvar +org-ml-max-age 600
    "Maximum permissible age in seconds.")
  (defvar +org-ml--cache-timestamp 0)
  (defvar +org-ml--cache nil)

  (define-minor-mode +org-ml-patchy-mood-mode
    "Apply patches to Org in bulk."
    :global t
    (let ((action (cons "apply patch to org" #'+org-ml-apply-patch)))
      (if +org-ml-patchy-mood-mode
          (add-to-list 'mu4e-view-actions action)
        (setq mu4e-view-actions (delete action mu4e-view-actions)))))

  (defun +org-ml-apply-patch (msg)
    "Apply the patch in the current message to Org."
    (interactive)
    (unless msg (setq msg (mu4e-message-at-point)))
    (with-current-buffer (get-buffer-create "*Shell: Org apply patches*")
      (erase-buffer)
      (let* ((default-directory +org-ml-target-dir)
             (exit-code (call-process "git" nil t nil "am" (mu4e-message-field msg :path))))
        (magit-refresh)
        (when (not (= 0 exit-code))
          (+popup/buffer)))))

  (defun +org-ml-current-patches ()
    "Get the currently open patches, as a list of alists.
Entries of the form (subject . id)."
    (delq nil
          (mapcar
           (lambda (entry)
             (unless (plist-get entry :fixed)
               (cons
                (format "%-8s  %s"
                        (propertize
                         (replace-regexp-in-string "T.*" ""
                                                   (plist-get entry :date))
                         'face 'font-lock-doc-face)
                        (propertize
                         (replace-regexp-in-string "\\[PATCH\\] ?" ""
                                                   (plist-get entry :summary))
                         'face 'font-lock-keyword-face))
                (plist-get entry :id))))
           (with-current-buffer (url-retrieve-synchronously "https://updates.orgmode.org/data/patches")
             (goto-char url-http-end-of-headers)
             (json-parse-buffer :object-type 'plist)))))

  (defun +org-ml-select-patch-thread ()
    "Find and apply a proposed Org patch."
    (interactive)
    (let* ((current-workspace (+workspace-current))
           (patches (progn
                      (when (or (not +org-ml--cache)
                                (> (- (float-time) +org-ml--cache-timestamp)
                                   +org-ml-max-age))
                        (setq +org-ml--cache (+org-ml-current-patches)
                              +org-ml--cache-timestamp (float-time)))
                      +org-ml--cache))
           (msg-id (cdr (assoc (completing-read
                                "Thread: " (mapcar #'car patches))
                               patches))))
      (+workspace-switch +mu4e-workspace-name)
      (mu4e-view-message-with-message-id msg-id)
      (unless +org-ml-patchy-mood-mode
        (add-to-list 'mu4e-view-actions
                     (cons "apply patch to org" #'+org-ml-transient-mu4e-action)))))

  (defun +org-ml-transient-mu4e-action (msg)
    (setq mu4e-view-actions
          (delete (cons "apply patch to org" #'+org-ml-transient-mu4e-action)
                  mu4e-view-actions))
    (+workspace/other)
    (magit-status +org-ml-target-dir)
    (+org-ml-apply-patch msg)))
#+end_src

***** 邮件列表归档链接
另一件容易做到的事情是在 https://list.orgmode.org 上获取指向当前消息的链接。

#+begin_src emacs-lisp
(after! mu4e
  (defun +mu4e-ml-message-link (msg)
    "Copy the link to MSG on the mailing list archives."
    (let* ((list-addr (or (mu4e-message-field msg :mailing-list)
                          (cdar (mu4e-message-field-raw msg :list-post))
                          (thread-last (append (mu4e-message-field msg :to)
                                               (mu4e-message-field msg :cc))
                            (mapcar #'last)
                            (mapcar #'cdr)
                            (mapcar (lambda (addr)
                                      (when (string-match-p "emacs.*@gnu\\.org$" addr)
                                        (replace-regexp-in-string "@" "." addr))))
                            (delq nil)
                            (car))))
           (msg-url
            (cond
             ((string= "emacs-orgmode.gnu.org" list-addr)
              (format "https://list.orgmode.org/%s" (mu4e-message-field msg :message-id)))
             (t (user-error "Mailing list %s not supported" list-addr)))))
      (message "Link %s copied to clipboard" (gui-select-text msg-url))
      msg-url))

  (add-to-list 'mu4e-view-actions (cons "link to message ML" #'+mu4e-ml-message-link) t))
#+end_src

以类似的方式，当单击此类链接时 (例如，当有人使用指向存档的链接来引用较早的电子邮
件时) 我更愿意在 mu4e 中查看它。

#+begin_src emacs-lisp
(defun +browse-url-orgmode-ml (url &optional _)
  "Open an orgmode list url using notmuch."
  (let ((id (and (or (string-match "^https?://orgmode\\.org/list/\\([^/]+\\)" url)
                     (string-match "^https?://list\\.orgmode\\.org/\\([^/]+\\)" url))
                 (match-string 1 url))))
    (mu4e-view-message-with-message-id id)))

(add-to-list 'browse-url-handlers (cons "^https?://orgmode\\.org/list" #'+browse-url-orgmode-ml))
(add-to-list 'browse-url-handlers (cons "^https?://list\\.orgmode\\.org/" #'+browse-url-orgmode-ml))
#+end_src

*** Org Msg
Doom 在默认情况下做了很棒的事情，所以我们只做一些小的调整。
#+begin_src emacs-lisp
(setq +org-msg-accent-color "#1a5fb4"
      org-msg-greeting-fmt "\nHi%s,\n\n"
      org-msg-signature "\n\n#+begin_signature\nAll the best,\\\\\n@@html:<b>@@Timothy@@html:</b>@@\n#+end_signature")
(map! :map org-msg-edit-mode-map
      :after org-msg
      :n "G" #'org-msg-goto-body)
#+end_src

* 编程语言配置
** 通用配置
*** 文件模板
某些文件类型，我们可以重载其 [[file:./snippets][snippets]] 目录的默认值，而其他文件类型则需要分配模板。
#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

** 纯文本
Emacs 可以显示 ANSI 颜色代码。然而，在 Emacs 28 之前，如果不修改缓冲区是不可能做到这
一点的，所以让我们以此为基础设置这个块。
#+begin_src emacs-lisp :tangle (if (>= emacs-major-version 28) "yes" "no")
(after! text-mode
  (add-hook! 'text-mode-hook
             ;; Apply ANSI color codes
             (with-silent-modifications
               (ansi-color-apply-on-region (point-min) (point-max) t))))
#+end_src

** Org
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:
:intro:
我真的非常喜欢 org mode，我考虑过为什么，下面就是我考虑的结果。

#+attr_latex: :align *{8}{p{0.105\linewidth}} :font \small
#+plot: transpose:yes type:radar min:0 max:4 file:"misc/document-format-comparison.svg"
| 格式              | 细粒度控制 | 上手易用性 | 语法简单 | 编辑器支持 | 集成度 | 易于参考 | 多功能性 |
|-------------------+------------+------------+----------+------------+--------+----------+----------|
| Word              |          2 |          4 |        4 |          2 |      3 |        2 |        2 |
| LaTeX             |          4 |          1 |        1 |          3 |      2 |        4 |        3 |
| Org Mode          |          4 |          2 |      3.5 |          1 |      4 |        4 |        4 |
| Markdown          |          1 |          3 |        3 |          4 |      3 |        3 |        1 |
| Markdown + Pandoc |        2.5 |        2.5 |      2.5 |          3 |      3 |        3 |        2 |

#+attr_html: :class invertible :alt Radar chart comparing my opinions of document formats.
#+attr_latex: :options inkscapelatex=false
[[file:misc/document-format-comparison.svg]]

除了标记语言 (Markup Language) 的优雅外，Emacs 集成了一场丰富的有趣的功能，比如说对
当前任何技术都支持的文学编程。
#+name: Literate programming workflow
#+attr_html: :style line-height:1.13;
#+begin_example
      ╭─╴Code╶─╮            ╭─╴Raw Code╶─▶ Computer
Ideas╺┥        ┝━▶ Org Mode╺┥
      ╰─╴Text╶─╯            ╰─╴Document╶─▶ People
#+end_example

在 =.org= 文件可以包含代码块 (不支持 noweb 模板)，这些代码块可以与专用源代码文件纠缠
在一起，并通过各种 (可扩展的) 方法编译成文档 (报告、文档、演示文稿等)。这些源块甚至可以
创建要包含在文档中的图像或其他内容，或者生成源代码。

#+name: Example Org Flowchart
#+attr_html: :style line-height:1.13;
#+begin_example
                   ╭───────────────────────────────────▶ .pdf ⎫
                  pdfLaTeX ▶╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╮                 ⎪
                   ╿     ╿                  ┊                 ⎪
                   │     ┊                  ┊                 ⎪
                 .tex    ┊                  ┊                 ⎪
                   ╿     ┊                  ┊                 ⎪
                ╭──┴╌╌╮  ┊                  ┊ style.scss      ⎬ Weaving
graphc.png ─╮   │  embedded TeX             ┊      ╽          ⎪ (Documents)
image.jpeg ─┤ filters   ╿                   ┊    .css         ⎪
            ╎     ╿     ┊                   ┊     ▾╎          ⎪
figure.png╶─╧─▶ PROJECT.ORG ▶───╴filters╶───╧──────╪──▶ .html ⎪
     ╿           ╿┊ ║ │ ╰╌╌╌▷╌╌ embedded html ▶╌╌╌╌╯          ⎪
     ├╌╌╌╌╌╌╌▷╌╌╌╯┊ ║ │                                       ⎪
    result╶╌╌╌╌╌╮ ┊ ║ ├──────╴filters╶────────────────▶ .txt  ⎪
     ┊▴         ┊ ┊ ║ │                                       ⎪
    execution   ┊ ┊ ║ ╰──────╴filters╶────────────────▶ .md   ⎭
     ┊▴         ┊ ┊ ║
    code blocks◀╯ ┊ ╟─────────────────────────────────▶ .c    ⎫
     ╰╌╌╌╌◁╌╌╌╌╌╌╌╯ ╟─────────────────────────────────▶ .sh   ⎬ Tangling
                    ╟─────────────────────────────────▶ .hs   ⎪ (Code)
                    ╙─────────────────────────────────▶ .el   ⎭
#+end_example
:end:

因为这部分初始化时相当费时，我们需要将其放在 src_elisp{(after! ...)} 中。
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src
*** System config
**** Mime types
默认情况下，Org 模式不会被识别为它自己的 MIME 类型，但可以使用以下文件轻松更改。 对于系统范围的更改，请尝试 ~/usr/share/mime/packages/org.xml~ 。
#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src
好在 Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][现在]] 有一个 =text/org= 的图标。 只需刷新他们的 mime 数据库。
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src
现在设置 emacs 为默认的编辑器。
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs.desktop text/org
#+end_src
**** Git diffs
Protesilaos 写了一篇 [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][非常有用的文章]]，他在其中解释了如何将 git diff 块标题更改为
比大块上方的直接行更有用的东西 --- 就像父标题一样。

这可以通过首先在 =~/.config/git/attributes= 中为 git 添加新的差异模式来实现。
#+begin_src fundamental
,*.org   diff=org
#+end_src

然后为它添加一个正则表达式到 =~/.config/git/config= 。
#+begin_src gitconfig
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src

*** 包
:PROPERTIES:
:header-args:emacs-lisp: :tangle packages.el :comments no
:END:
**** Org itself
实际上，我可能想将三种可能的包语句用于 Org。

如果我在一台可以推送修改的机器上，我希望可以在开发中用上 Emacs。我需要检查 SSH
key =~/.ssh/id_ed25519.pub= 的内容来确认。
1. 如果 key 存在且 =$straight-base-dir/straight/repos/org-mode= 没有设置
   正确的远程仓库，我们应该安装它。
2. 如果 key 存在且设置了正确的远程仓库，直接忽略它
3. 如果密钥不存在，则应该使用 Org 的 ~HEAD~ 。

为了正确解释这种情况，我们需要一个简短的脚本来确定所需的正确包语句。
#+name: org-pkg-statement
#+begin_src emacs-lisp :tangle no
(load (expand-file-name "core/core.el" user-emacs-directory) nil t) ; for `doom-local-dir'
(let ((dev-key (and (file-exists-p "~/.ssh/id_ed25519.pub")
                    (= 0 (shell-command "cat ~/.ssh/id_ed25519.pub | grep -q AAAAC3NzaC1lZDI1NTE5AAAAIOZZqcJOLdN+QFHKyW8ST2zz750+8TdvO9IT5geXpQVt"))))
      (dev-pkg (let ((default-directory (expand-file-name "straight/repos/org-mode" doom-local-dir)))
                 (and (file-exists-p default-directory)
                      (string= "tec@git.savannah.gnu.org:/srv/git/emacs/org-mode.git\n" (shell-command-to-string "git remote get-url origin")))))
      (recipe-common '(:files ("*.el" "lisp/*.el" "etc")
                       :pre-build
                       (with-temp-file (doom-path (straight--repos-dir "org-mode") "org-version.el")
                         (insert "(fset 'org-release (lambda () \"9.5\"))\n"
                                 (format "(fset 'org-git-version (lambda () \"%s\"))\n"
                                         (substring (shell-command-to-string "git rev-parse --short HEAD") 0 -1))
                                 "(provide 'org-version)\n"))
                       :includes org)))
  (prin1-to-string
   `(package! org-mode
      :recipe (,@(cond ((and dev-key dev-pkg)
                        (list :host nil :repo nil :local-repo (expand-file-name "straight/repos/org-mode" doom-local-dir)))
                       (dev-key
                        (list :host nil :repo "tec@git.savannah.gnu.org:/srv/git/emacs/org-mode.git"))
                       (t
                        (list :host 'github :repo "emacs-straight/org-mode")))
               ,@recipe-common)
      :pin nil)))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<org-pkg-statement()>>
(unpin! org-mode) ; there be bugs
(package! org-contrib
  :recipe (:host nil :repo "https://git.sr.ht/~bzg/org-contrib"
           :files ("lisp/*.el"))
  :pin "8c138dc5375dc13a0d1952e61c638ef4d57df368")
#+end_src

**** 视觉
***** 表

Org 表看起来并不是很漂亮。这个包可以支持缓冲区中用画框字符重绘它们。这听起来是一
种进步，就在 =writeroom-mode= 中启用它吧。

#+begin_src emacs-lisp
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "7bd68b420d3402826fea16ee5099d04aa9879b78")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

***** 强调标记
~org-hide-emphasis-markers~!棒！有时在边界上的编辑会导致变得麻烦。我们可以在
不牺牲视觉便利性的条件下，使用包 =org-appear= 改善这种情况。
#+begin_src emacs-lisp
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "303fcc8d5d85a4ebff2798dab50b2ccc0255ea5f")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

***** 标题结构
说起标题行，我注意到了一个非常棒的包，它可以浏览并管理标题结构。
#+begin_src emacs-lisp
(package! org-ol-tree :recipe (:host github :repo "Townk/org-ol-tree")
  :pin "207c748aa5fea8626be619e8c55bdb1c16118c25")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :commands org-ol-tree)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src

**** 额外的功能

***** Org ref
需要时不时的引用。
#+begin_src emacs-lisp :tangle no
(package! org-ref :pin "3ca9beb744621f007d932deb8a4197467012c23a")
#+end_src

***** Julia 支持
=ob-julia= 现在看来有点简陋，不过还是可以有效提供相关内容的。
#+begin_src emacs-lisp
(package! ob-julia :recipe (:local-repo "lisp/ob-julia" :files ("*.el" "julia")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! ob-julia
  :commands org-babel-execute:julia
  :config
  (setq org-babel-julia-command-arguments
        `("--sysimage"
          ,(when-let ((img "~/.local/lib/julia.so")
                      (exists? (file-exists-p img)))
             (expand-file-name img))
          "--threads"
          ,(number-to-string (- (doom-system-cpus) 2))
          "--banner=no")))
#+end_src

***** HTTP 请求
在 babel 中使用 HTTP 请求。
#+begin_src emacs-lisp
(package! ob-http :pin "b1428ea2a63bcb510e7382a1bf5fe82b19c104a7")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! ob-http
  :commands org-babel-execute:http)
#+end_src

***** 嵌入
将开发 /嵌入到/ Org 真的是帅的不行。
#+begin_src emacs-lisp
(package! org-transclusion :recipe (:host github :repo "nobiot/org-transclusion")
  :pin "ccc0aaa72732ea633bf52bcc8a0345cd3ac178fd")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-transclusion
  :commands org-transclusion-mode
  :init
  (map! :after org :map org-mode-map
        "<f12>" #'org-transclusion-mode))
#+end_src

***** 标题图
安装它，真的帅的不行
#+begin_src emacs-lisp
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "233c6708c1f37fc60604de49ca192497aef39757")
#+end_src

***** 烹饪食谱
在生活中我 *需要* 它，它会在公共网站上给你找到一个菜谱的链接，在这插入 org-ified 版
本。这不是特别棒嘛。

#+begin_src emacs-lisp
(package! org-chef :pin "87e9a6c4844ff32f47c8d1108ec0f087a3148a8e")
#+end_src

在 org 之后加载似乎有些早，无论是命令还是模板，都在用的时候在加载吧。
#+begin_src emacs-lisp :tangle yes
(use-package! org-chef
  :commands (org-chef-insert-recipe org-chef-get-recipe-from-url))
#+end_src

***** 从 pandoc 导出
有时我需要导出非 org 文件，这很难受。不过好在我们还有 pandoc 提供了这些方法，这个包可
以让事情变得很简单。
#+begin_src emacs-lisp
(package! org-pandoc-import :recipe
  (:local-repo "lisp/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src

***** 文档比较
比较 Org 文件的想法不错，其中比较内容最丰富的是 =latexdiff= 。不过涉及到了比较烦人的
步骤，所以我写了个包来精简这些步骤。

#+begin_src emacs-lisp
(package! orgdiff :recipe (:local-repo "lisp/orgdiff"))
#+end_src

现在唯一烦人的是， =latexdiff= 用 ~#FF0000~ 和 ~#0000FF~ 作为红色和蓝色，这两个改
变标记色。让我们在 =latexdiff= 的结果上进行处理，让它更舒服点。
#+begin_src emacs-lisp :tangle yes
(use-package! orgdiff
  :defer t
  :config
  (defun +orgdiff-nicer-change-colours ()
    (goto-char (point-min))
    ;; Set red/blue based on whether chameleon is being used
    (if (search-forward "%% make document follow Emacs theme" nil t)
        (setq red  (substring (doom-blend 'red 'fg 0.8) 1)
              blue (substring (doom-blend 'blue 'teal 0.6) 1))
      (setq red  "c82829"
            blue "00618a"))
    (when (and (search-forward "%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF" nil t)
               (search-forward "\\RequirePackage{color}" nil t))
      (when (re-search-forward "definecolor{red}{rgb}{1,0,0}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{red}{HTML}{%s}" red)))
      (when (re-search-forward "definecolor{blue}{rgb}{0,0,1}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{blue}{HTML}{%s}" blue)))))
  (add-to-list 'orgdiff-latexdiff-postprocess-hooks #'+orgdiff-nicer-change-colours))
#+end_src

***** Org Music
链接到音乐
#+begin_src emacs-lisp
(package! org-music :recipe (:local-repo "lisp/org-music"))
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! org-music
  :after org
  :config
  (setq org-music-mpris-player "Lollypop"
        org-music-track-search-method 'beets
        org-music-beets-db "~/Music/library.db"))
#+end_src

*** 行为
[[xkcd:1319]]
**** 修改默认值
#+begin_src emacs-lisp
(setq org-directory "~/.org"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

同时我也很喜欢将 src_elisp{:comments} 作为标头参数,所以来设置一下默认值。
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

默认情况下， ~visual-line-mode~ 是 =开启= 状态，但是 ~auto-fill-mode~ 通过
hook =关闭= 。这让 Org-mode 的表格和其他纯文本文件 (markdown, \LaTeX) 混淆，
所以要关闭它，在需要的模式手动开启它。
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

默认绑定了 vim 风格的快捷键，但并没有绑定方向键。
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src

**** 额外的功能
***** 创建 Org 缓冲区
把创建 Org 缓冲区变得更容易点吧。
#+begin_src emacs-lisp :tangle yes :noweb-ref none
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
***** 零宽度空格工具
偶尔在用 Org 是你希望将两个分开的块放在一起，这点有点烦人。比如将加​*重*​一个单词
的一部分，或者说在内联源码块之前放一些符号。有一个可以解决的方法 --- 零宽空格。
由于这是 Emacs，我们可以为 org-mode 做一个很小的改动将其添加到快捷键上 🙂。
#+begin_src emacs-lisp
(map! :map org-mode-map
      :nie "M-SPC M-SPC" (cmd! (insert "\u200B")))
#+end_src

不过在导出时，我并不想要它，加一个简单的过滤器将其过滤掉。
#+begin_src emacs-lisp
(defun +org-export-remove-zero-width-space (text _backend _info)
  "Remove zero width spaces from TEXT."
  (unless (org-export-derived-backend-p 'org)
    (replace-regexp-in-string "\u200B" "" text)))

(after! ox
  (add-to-list 'org-export-filter-final-output-functions #'+org-export-remove-zero-width-space t))
#+end_src
***** 列表符号序列
我觉得让列表符号随着深度变化很有意思。
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
***** 引用
偶尔引用某些东西，用 =org-ref= 就够了。

不幸的是，它忽略了 ~file = {...}~ 的 =.bib= 键值对，修正它！
我依 =;= 分割了文件，只是稍微用了下 Zotero/BetterBibLaTeX，但这相当不错。

#+begin_src emacs-lisp :noweb-ref none
(use-package! org-ref
  ;; :after org
  :defer t
  :config
  (defadvice! org-ref-open-bibtex-pdf-a ()
    :override #'org-ref-open-bibtex-pdf
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (or
                   (car (-filter (lambda (f) (string-match-p "\\.pdf$" f))
                                 (split-string (reftex-get-bib-field "file" entry) ";")))
                   (funcall org-ref-get-pdf-filename-function key))))
        (if (file-exists-p pdf)
            (org-open-file pdf)
          (ding)))))
  (defadvice! org-ref-open-pdf-at-point-a ()
    "Open the pdf for bibtex key under point if it exists."
    :override #'org-ref-open-pdf-at-point
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall org-ref-get-pdf-filename-function key)))
      (with-current-buffer (find-file-noselect (cdr results))
        (save-excursion
          (bibtex-search-entry (car results))
          (org-ref-open-bibtex-pdf))))))
#+end_src

=org-cite= 是一个新包，但体验相当好，改进它！

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! citar :pin "79512aefdf11071b66908320aa346255dd349234")
(package! citeproc :pin "ba49516265fa24b138346c4918d39d19b4de8a62")
(package! org-cite-csl-activate :recipe (:host github :repo "andras-simonyi/org-cite-csl-activate") :pin "a9b3f3643b587076538a767666372b31b873c294")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! citar
  :when (featurep! :completion vertico)
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  :config
  (setq citar-bibliography
        (let ((libfile-search-names '("library.json" "Library.json" "library.bib" "Library.bib"))
              (libfile-dir "~/Zotero")
              paths)
          (dolist (libfile libfile-search-names)
            (when (and (not paths)
                       (file-exists-p (expand-file-name libfile libfile-dir)))
              (setq paths (list (expand-file-name libfile libfile-dir)))))
          paths))
  (setq citar-symbols
      `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
        (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
        (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))))

(use-package! citeproc
  :defer t)

;;; Org-Cite configuration

(map! :after org
      :map org-mode-map
      :localleader
      :desc "Insert citation" "@" #'org-cite-insert)

(use-package! oc
  :after org citar
  :config
  (require 'ox)
  (setq org-cite-global-bibliography
        (let ((paths (or citar-bibliography
                         (bound-and-true-p bibtex-completion-bibliography))))
          ;; Always return bibliography paths as list for org-cite.
          (if (stringp paths) (list paths) paths)))
  ;; setup export processor; default csl/citeproc-el, with biblatex for latex
  (setq org-cite-export-processors
        '((t csl))))

  ;;; Org-cite processors
(use-package! oc-biblatex
  :after oc)

(use-package! oc-csl
  :after oc
  :config
  (setq org-cite-csl-styles-dir "~/Zotero/styles"))

(use-package! oc-natbib
  :after oc)

(use-package! oc-csl-activate
  :after oc
  :config
  (setq org-cite-csl-activate-use-document-style t)
  (defun +org-cite-csl-activate/enable ()
    (interactive)
    (setq org-cite-activate-processor 'csl-activate)
    (add-hook! 'org-mode-hook '((lambda () (cursor-sensor-mode 1)) org-cite-csl-activate-render-all))
    (defadvice! +org-cite-csl-activate-render-all-silent (orig-fn)
      :around #'org-cite-csl-activate-render-all
      (with-silent-modifications (funcall orig-fn)))
    (when (eq major-mode 'org-mode)
      (with-silent-modifications
        (save-excursion
          (goto-char (point-min))
          (org-cite-activate (point-max)))
        (org-cite-csl-activate-render-all)))
    (fmakunbound #'+org-cite-csl-activate/enable)))
#+end_src

也许可以用一个函数将 =org-ref= 引用转换为 =org-cite= 。
#+begin_src emacs-lisp
(after! oc
  (defun org-ref-to-org-cite ()
    "Attempt to convert org-ref citations to org-cite syntax."
    (interactive)
    (let* ((cite-conversions '(("cite" . "//b") ("Cite" . "//bc")
                               ("nocite" . "/n")
                               ("citep" . "") ("citep*" . "//f")
                               ("parencite" . "") ("Parencite" . "//c")
                               ("citeauthor" . "/a/f") ("citeauthor*" . "/a")
                               ("citeyear" . "/na/b")
                               ("Citep" . "//c") ("Citealp" . "//bc")
                               ("Citeauthor" . "/a/cf") ("Citeauthor*" . "/a/c")
                               ("autocite" . "") ("Autocite" . "//c")
                               ("notecite" . "/l/b") ("Notecite" . "/l/bc")
                               ("pnotecite" . "/l") ("Pnotecite" . "/l/bc")))
           (cite-regexp (rx (regexp (regexp-opt (mapcar #'car cite-conversions) t))
                            ":" (group (+ (not (any "\n 	,.)]}")))))))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward cite-regexp nil t)
          (message (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2)))
          (replace-match (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2))))))))
#+end_src
***** cdlatex
~cdlatex~ 好！
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

可以用 =C-c }= 实现快速插入环境。不过我总是想在之后编辑它们。将这变为默认行为。
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

也许在以后可以深入研究下 [[https://scripter.co/splitting-an-org-block-into-two/][拆分 Org 块]]。同样 [[https://archive.casouri.cat/note/2020/insert-math-symbol-in-emacs/][这]] 对于符号也不错。
***** 拼写检查
我的拼写很糟，还是用检查吧。
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+end_src
***** ~src~ 块的 LSP 支持
默认的，LSP 并不会在 ~src~ 中起作用。
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src
***** 查看导出文件
='localeader v= 没有预先设置的快捷键，所以我可以尝试将它与 LaTeX 的相同功能一起使用。尝试用它查看一下可能的导出文件。
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src

**** agenda 支持
agenda 挺好用的，但加强版更强。
#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! org-super-agenda :pin "fb5e2ef277bc811a3b061106c99e4c47b6b86f80")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! org-super-agenda
  :commands org-super-agenda-mode)
#+end_src

#+begin_src emacs-lisp
(after! org-agenda
  (org-super-agenda-mode))

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-compact-blocks t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :order 15)
                          (:name "To read"
                           :tag "Read"
                           :order 30)
                          (:name "Waiting"
                           :todo "WAITING"
                           :order 20)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))))
#+end_src

**** Capture
开始设置 Org-capture 模板吧，让它们看起来更容易访问。

#+attr_html: :class invertible :alt My org-capture dialouge.
[[https://tecosaur.com/lfs/emacs-config/screenshots/org-capture.png]]

~doct~ (Declarative Org Capture Templates) 似乎是挺不错的 org-capture 方
案。
#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "9ed9b8c7f7e2ea2d2fb739d65ae4626a1cf16b9f")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! doct
  :commands doct)
#+end_src

#+begin_src emacs-lisp :noweb no-export
(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defvar +org-capture-recipies  "~/Desktop/TEC/Organisation/recipies.org")

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a"))
                  ("Personal note" :keys "n"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web")
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch")
                              ("\tRecipie" :keys "r"
                               :icon ("spoon" :set "faicon" :color "dorange")
                               :file +org-capture-recipies
                               :headline "Unsorted"
                               :template "%(org-chef-get-recipe-from-url)")
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info")
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea")))
                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra "")
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t")
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t")))
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file)))
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file)))))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src
改进 capture 的对话外观，也不错。
#+name: prettify-capture
#+begin_src emacs-lisp :noweb-ref none
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "›" 'face 'font-lock-comment-face) "  " desc "…" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "─────────────────────────\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override
#+end_src
[[file:~/.emacs.d/bin/org-capture][org-capture bin]] 相当不错，但我更喜欢更小的框架，且没有 modeline。
#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

**** Roam
***** 基础设置
我现在将其设置在 =Organisation= 中，将来似乎很值得与 [[https://nextcloud.com/][Nextcloud]] 结合起来。
#+begin_src emacs-lisp :noweb-ref none :tangle yes
(setq org-roam-directory "~/Desktop/TEC/Organisation/Roam/")
#+end_src

也就是说，如果目录不存在我们并不想使用 roam。由于我们不想触发错误 (在 roam 初始
化时就会发生)，我们就直接不加载 roam。
#+begin_src emacs-lisp :noweb-ref none :tangle (if (file-exists-p "~/Desktop/TEC/Organisation/Roam/") "no" "packages.el")
(package! org-roam :disable t)
#+end_src
***** modeline 文件名
这些数字实在太！混！乱！了！让我们用与 [[*窗口标题][窗口标题]] 类似的方法调整它。
#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "🢔(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src
***** 图形预览
org-roam 它本身还是很优秀的，还可以将这些非常棒的 /额外/ 包集成进来。
#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")) :pin "309fe3c58c7081de4e2c9c64f7b40ea291926048")
(package! websocket :pin "fda4455333309545c0787a79d73c19ddbeb57980") ; dependency of `org-roam-ui'
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands org-roam-ui-open
  :hook (org-roam . org-roam-ui-mode)
  :config
  (require 'org-roam) ; in case autoloaded
  (defun org-roam-ui-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (unless org-roam-ui-mode (org-roam-ui-mode 1))
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-ui-port))))
#+end_src

**** 更棒的标题 ID 生成
非常感谢 alphapapa 的 [[https://github.com/alphapapa/unpackaged.el#export-to-html-with-useful-anchors][unpackaged.el]].

通常情况下 Org 会为标题生成类似 =#org80fc2a5= 的 ID…… 能用，就是有两问题
+ 复杂且无用的信息，没什么好方法去引用
+ 导出相同的文章，但 ID 会改变。虽然现在没什么硬编码需要一遍又一遍的修改，但是能
  不变是最好的。

这两个问题可以采用生成 =#language-configuration= 这样的 ID 来解决，就这样做。

需要注意，alphapapa 使用的 ~url-hexify-string~ 似乎给我带来了些问题。在
~a53899~ 中替换它解决了这个问题，为了更进一步，我创建了一个漂亮的短链接函数，就像
~reftex-label~ 的低阶版本。
#+begin_src emacs-lisp
resolved

(defvar org-reference-contraction-max-words 3
  "Maximum number of words in a reference reference.")
(defvar org-reference-contraction-max-length 35
  "Maximum length of resulting reference reference, including joining characters.")
(defvar org-reference-contraction-stripped-words
  '("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
  "Superfluous words to be removed from a reference.")
(defvar org-reference-contraction-joining-char "-"
  "Character used to join words in the reference reference.")

(defun org-reference-contraction-truncate-words (words)
  "Using `org-reference-contraction-max-length' as the total character 'budget' for the WORDS
and truncate individual words to conform to this budget.

To arrive at a budget that accounts for words undershooting their requisite average length,
the number of characters in the budget freed by short words is distributed among the words
exceeding the average length.  This adjusts the per-word budget to be the maximum feasable for
this particular situation, rather than the universal maximum average.

This budget-adjusted per-word maximum length is given by the mathematical expression below:

max length = \\floor{ \\frac{total length - chars for seperators - \\sum_{word \\leq average length} length(word) }{num(words) > average length} }"
  ;; trucate each word to a max word length determined by
  ;;
  (let* ((total-length-budget (- org-reference-contraction-max-length  ; how many non-separator chars we can use
                                 (1- (length words))))
         (word-length-budget (/ total-length-budget                      ; max length of each word to keep within budget
                                org-reference-contraction-max-words))
         (num-overlong (-count (lambda (word)                            ; how many words exceed that budget
                                 (> (length word) word-length-budget))
                               words))
         (total-short-length (-sum (mapcar (lambda (word)                ; total length of words under that budget
                                             (if (<= (length word) word-length-budget)
                                                 (length word) 0))
                                           words)))
         (max-length (/ (- total-length-budget total-short-length)       ; max(max-length) that we can have to fit within the budget
                        num-overlong)))
    (mapcar (lambda (word)
              (if (<= (length word) max-length)
                  word
                (substring word 0 max-length)))
            words)))

(defun org-reference-contraction (reference-string)
  "Give a contracted form of REFERENCE-STRING that is only contains alphanumeric characters.
Strips 'joining' words present in `org-reference-contraction-stripped-words',
and then limits the result to the first `org-reference-contraction-max-words' words.
If the total length is > `org-reference-contraction-max-length' then individual words are
truncated to fit within the limit using `org-reference-contraction-truncate-words'."
  (let ((reference-words
         (-filter (lambda (word)
                    (not (member word org-reference-contraction-stripped-words)))
                  (split-string
                   (->> reference-string
                        downcase
                        (replace-regexp-in-string "\\[\\[[^]]+\\]\\[\\([^]]+\\)\\]\\]" "\\1") ; get description from org-link
                        (replace-regexp-in-string "[-/ ]+" " ") ; replace seperator-type chars with space
                        puny-encode-string
                        (replace-regexp-in-string "^xn--\\(.*?\\) ?-?\\([a-z0-9]+\\)$" "\\2 \\1") ; rearrange punycode
                        (replace-regexp-in-string "[^A-Za-z0-9 ]" "") ; strip chars which need %-encoding in a uri
                        ) " +"))))
    (when (> (length reference-words)
             org-reference-contraction-max-words)
      (setq reference-words
            (cl-subseq reference-words 0 org-reference-contraction-max-words)))

    (when (> (apply #'+ (1- (length reference-words))
                    (mapcar #'length reference-words))
             org-reference-contraction-max-length)
      (setq reference-words (org-reference-contraction-truncate-words reference-words)))

    (string-join reference-words org-reference-contraction-joining-char)))
#+end_src

这是 alphapapa 的微调模式。
#+begin_src emacs-lisp
(define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
  "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
  :global t
  (if unpackaged/org-export-html-with-useful-ids-mode
      (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
    (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))
(unpackaged/org-export-html-with-useful-ids-mode 1) ; ensure enabled, and advice run

(defun unpackaged/org-export-get-reference (datum info)
  "Like `org-export-get-reference', except uses heading titles instead of random numbers."
  (let ((cache (plist-get info :internal-references)))
    (or (car (rassq datum cache))
        (let* ((crossrefs (plist-get info :crossrefs))
               (cells (org-export-search-cells datum))
               ;; Preserve any pre-existing association between
               ;; a search cell and a reference, i.e., when some
               ;; previously published document referenced a location
               ;; within current file (see
               ;; `org-publish-resolve-external-link').
               ;;
               ;; However, there is no guarantee that search cells are
               ;; unique, e.g., there might be duplicate custom ID or
               ;; two headings with the same title in the file.
               ;;
               ;; As a consequence, before re-using any reference to
               ;; an element or object, we check that it doesn't refer
               ;; to a previous element or object.
               (new (or (cl-some
                         (lambda (cell)
                           (let ((stored (cdr (assoc cell crossrefs))))
                             (when stored
                               (let ((old (org-export-format-reference stored)))
                                 (and (not (assoc old cache)) stored)))))
                         cells)
                        (when (org-element-property :raw-value datum)
                          ;; Heading with a title
                          (unpackaged/org-export-new-named-reference datum cache))
                        (when (member (car datum) '(src-block table example fixed-width property-drawer))
                          ;; Nameable elements
                          (unpackaged/org-export-new-named-reference datum cache))
                        ;; NOTE: This probably breaks some Org Export
                        ;; feature, but if it does what I need, fine.
                        (org-export-format-reference
                         (org-export-new-reference cache))))
               (reference-string new))
          ;; Cache contains both data already associated to
          ;; a reference and in-use internal references, so as to make
          ;; unique references.
          (dolist (cell cells) (push (cons cell new) cache))
          ;; Retain a direct association between reference string and
          ;; DATUM since (1) not every object or element can be given
          ;; a search cell (2) it permits quick lookup.
          (push (cons reference-string datum) cache)
          (plist-put info :internal-references cache)
          reference-string))))

(defun unpackaged/org-export-new-named-reference (datum cache)
  "Return new reference for DATUM that is unique in CACHE."
  (cl-macrolet ((inc-suffixf (place)
                             `(progn
                                (string-match (rx bos
                                                  (minimal-match (group (1+ anything)))
                                                  (optional "--" (group (1+ digit)))
                                                  eos)
                                              ,place)
                                ;; HACK: `s1' instead of a gensym.
                                (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                           (match-string 2 ,place)))
                                        (suffix (if suffix
                                                    (string-to-number suffix)
                                                  0)))
                                  (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
    (let* ((headline-p (eq (car datum) 'headline))
           (title (if headline-p
                      (org-element-property :raw-value datum)
                    (or (org-element-property :name datum)
                        (concat (org-element-property :raw-value
                                                      (org-element-property :parent
                                                                            (org-element-property :parent datum)))))))
           ;; get ascii-only form of title without needing percent-encoding
           (ref (concat (org-reference-contraction (substring-no-properties title))
                        (unless (or headline-p (org-element-property :name datum))
                          (concat ","
                                  (pcase (car datum)
                                    ('src-block "code")
                                    ('example "example")
                                    ('fixed-width "mono")
                                    ('property-drawer "properties")
                                    (_ (symbol-name (car datum))))
                                  "--1"))))
           (parent (when headline-p (org-element-property :parent datum))))
      (while (--any (equal ref (car it))
                    cache)
        ;; Title not unique: make it so.
        (if parent
            ;; Append ancestor title.
            (setf title (concat (org-element-property :raw-value parent)
                                "--" title)
                  ;; get ascii-only form of title without needing percent-encoding
                  ref (org-reference-contraction (substring-no-properties title))
                  parent (when headline-p (org-element-property :parent parent)))
          ;; No more ancestors: add and increment a number.
          (inc-suffixf ref)))
      ref)))

(add-hook 'org-load-hook #'unpackaged/org-export-html-with-useful-ids-mode)
#+end_src
对于它现在可以传递一个字符串和数字，我们重定义
src_elisp{(org-export-format-reference)}。
#+begin_src emacs-lisp
(defadvice! org-export-format-reference-a (reference)
  "Format REFERENCE into a string.

REFERENCE is a either a number or a string representing a reference,
as returned by `org-export-new-reference'."
  :override #'org-export-format-reference
  (if (stringp reference) reference (format "org%07x" reference)))
#+end_src

**** 更棒的 ~org-return~
在说一次，[[https://github.com/alphapapa/unpackaged.el#org-return-dwim][unpackaged.el]]！
#+begin_src emacs-lisp
(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return-indent'.  With prefix, call `org-return-indent'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return t)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               (while (not (looking-back "\\(?:[[:blank:]]?\n\\)\\{3\\}" nil))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return t))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return t))
            (t
             ;; Non-empty row: call `org-return-indent'.
             (org-return t))))
     (t
      ;; All other cases: call `org-return-indent'.
      (org-return t)))))

(map!
 :after evil-org
 :map evil-org-mode-map
 :i [return] #'unpackaged/org-return-dwim)
#+end_src

**** snippet 助手
我经常设置 =src块= 的头，所以有以下痛点
+ 类型
+ 记住可以接受什么值
+ 对相同编程语言需要一遍一遍指定

用三步解决这些问题
+ 一个小的片段，并将 src header 的条件放在 ~(point)~ 处
+ 创建一个提示窗口来展示接收的值与默认值
+ 为 =src块= 的语言预填充上一次该语言的值

对于这些参数，我简化为了这些键
+ =r= 对应 =:results=
+ =e= 对应 =:exports=
+ =v= 对应 =:eval=
+ =s= 对应 =:session=
+ =d= 对应 =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

现在让我们编写一个可以在 yasnippets 中引用的交互式方法，用它指定头的参数。

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read values :prompt question :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

**** 将大写转换为小写
所有人都习惯使用 ~#+CAPITAL~ 关键字，不过人们发现 ~#+lowercase~ 更容易阅读、视
觉上更好，因此现在只有手册在使用大写。
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

为了避免有时不得不更新旧文档时出现新旧风格混合的情况，我写了一个简单地转码功能。它可
能会遗漏一些边缘情况，但大多数情况下应该可以工作。

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src

**** 外链
***** xkcd
xkcd 很酷，让我们更简便、有趣的插入它们。毕竟可以节省几秒钟！ (一共也就这么多)

[[xkcd:1205]]

#+begin_src emacs-lisp
(org-link-set-parameters "xkcd"
                         :image-data-fun #'+org-xkcd-image-fn
                         :follow #'+org-xkcd-open-fn
                         :export #'+org-xkcd-export
                         :complete #'+org-xkcd-complete)

(defun +org-xkcd-open-fn (link)
  (+org-xkcd-image-fn nil link nil))

(defun +org-xkcd-image-fn (protocol link description)
  "Get image data for xkcd num LINK"
  (let* ((xkcd-info (+xkcd-fetch-info (string-to-number link)))
         (img (plist-get xkcd-info :img))
         (alt (plist-get xkcd-info :alt)))
    (message alt)
    (+org-image-file-data-fn protocol (xkcd-download img (string-to-number link)) description)))

(defun +org-xkcd-export (num desc backend _com)
  "Convert xkcd to html/LaTeX form"
  (let* ((xkcd-info (+xkcd-fetch-info (string-to-number num)))
         (img (plist-get xkcd-info :img))
         (alt (plist-get xkcd-info :alt))
         (title (plist-get xkcd-info :title))
         (file (xkcd-download img (string-to-number num))))
    (cond ((org-export-derived-backend-p backend 'html)
           (format "<img class='invertible' src='%s' title=\"%s\" alt='%s'>" img (subst-char-in-string ?\" ?“ alt) title))
          ((org-export-derived-backend-p backend 'latex)
           (format "\\begin{figure}[!htb]
  \\centering
  \\includegraphics[scale=0.4]{%s}%s
\\end{figure}" file (if (equal desc (format "xkcd:%s" num)) ""
                      (format "\n  \\caption*{\\label{xkcd:%s} %s}"
                              num
                              (or desc
                                  (format "\\textbf{%s} %s" title alt))))))
          (t (format "https://xkcd.com/%s" num)))))

(defun +org-xkcd-complete (&optional arg)
  "Complete xkcd using `+xkcd-stored-info'"
  (format "xkcd:%d" (+xkcd-select)))
#+end_src
***** Music

***** YouTube
~[[yt:...]]~ 预览不错，但导出不行，不过你可以修复它。
#+begin_src emacs-lisp
(org-link-set-parameters "yt" :export #'+org-export-yt)
(defun +org-export-yt (path desc backend _com)
  (cond ((org-export-derived-backend-p backend 'html)
         (format "<iframe width='440' \
height='335' \
src='https://www.youtube.com/embed/%s' \
frameborder='0' \
allowfullscreen>%s</iframe>" path (or "" desc)))
        ((org-export-derived-backend-p backend 'latex)
         (format "\\href{https://youtu.be/%s}{%s}" path (or desc "youtube")))
        (t (format "https://youtu.be/%s" path))))
#+end_src

**** Fix problematic hooks
当 src_elisp{org-mode-hook} 函数之一出错时，它会停止 hook 执行。这是个大问题
，特别是有两个 hook 会出问题。让我们减少出错。

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src

**** 基于 org-lint 的 Flycheck
Org 简单但不意味着不会出现格式错误。庆幸吧，org 的格式错误比压缩的 XML
(DOCX/ODT) 少得多，特别是 ~org-lint~ 这个小工具与 Org 捆绑在一起的情况下。

[[xkcd:2109]]

目前为止 Flycheck 不支持 Org，并且没有任何包做这件事 ☹。然而， ~org-lint~ 的这
个 issue 用了 [[https://github.com/flycheck/flycheck/issues/1757#issuecomment-759546940][一点代码]] 就成了这件事。这是剪切板发明的目的吗？话虽如此，选择这份代
码，双手合十，祈祷吧。

#+begin_src emacs-lisp
(defconst flycheck-org-lint-form
  (flycheck-prepare-emacs-lisp-form
    (require 'org)
    (require 'org-attach)
    (let ((source (car command-line-args-left))
          (process-default-directory default-directory))
      (with-temp-buffer
        (insert-file-contents source 'visit)
        (setq buffer-file-name source)
        (setq default-directory process-default-directory)
        (delay-mode-hooks (org-mode))
        (setq delayed-mode-hooks nil)
        (dolist (err (org-lint))
          (let ((inf (cl-second err)))
            (princ (elt inf 0))
            (princ ": ")
            (princ (elt inf 2))
            (terpri)))))))

(defconst flycheck-org-lint-variables
  '(org-directory
    org-id-locations
    org-id-locations-file
    org-attach-id-dir
    org-attach-use-inheritance
    org-attach-id-to-path-function-list
    org-link-parameters)
  "Variables inherited by the org-lint subprocess.")

(defun flycheck-org-lint-variables-form ()
  (require 'org-attach)  ; Needed to make variables available
  `(progn
     ,@(seq-map (lambda (opt) `(setq-default ,opt ',(symbol-value opt)))
                (seq-filter #'boundp flycheck-org-lint-variables))))

(flycheck-define-checker org-lint
  "Org buffer checker using `org-lint'."
  :command ("emacs" (eval flycheck-emacs-args)
            "--eval" (eval (concat "(add-to-list 'load-path \""
                                   (file-name-directory (locate-library "org"))
                                   "\")"))
            "--eval" (eval (flycheck-sexp-to-string
                            (flycheck-org-lint-variables-form)))
            "--eval" (eval (flycheck-sexp-to-string
                            (flycheck-org-lint-customisations-form)))
            "--eval" (eval flycheck-org-lint-form)
            "--" source)
  :error-patterns
  ((error line-start line ": " (message) line-end))
  :modes org-mode)
#+end_src

事实证明它几乎可以工作。运行该片段后运行 =M-x flycheck-verify-setup=
会产生以下结果：
#+begin_example
The following syntax checkers are not registered:
  - org-lint
Try adding these syntax checkers to `flycheck-checkers'.
#+end_example

这非常有用，现在就链接 🙂。
#+begin_src emacs-lisp
(add-to-list 'flycheck-checkers 'org-lint)
#+end_src

它缺少自定义链接类型，但只需将 ~org-link-parameters~ 添加到
~flycheck-org-lint-variables~ 即可轻松解决。

剩下一个小烦恼，它会将 =#+options= 作为错误报告，我们需要告诉 ~org-lint~ 不需要
加载所有的配置，虽然代码重复了不好，但至少并不多。

#+name: org-syntax-modifications
#+begin_src emacs-lisp :tangle no
(defun flycheck-org-lint-customisations-form ()
  `(progn
     (require 'ox)
     (cl-pushnew '(:latex-cover-page nil "coverpage" nil)
                 (org-export-backend-options (org-export-get-backend 'latex)))
     (cl-pushnew '(:latex-font-set nil "fontset" nil)
                 (org-export-backend-options (org-export-get-backend 'latex)))))
#+end_src

*** 视觉
在这里，我尝试做两件事：通过字体更改等改进各种文档的样式，以从当前主题获取颜色。

[[xkcd:1882]]

**** 字体展示
不多说， ~+org-pretty-mode~ 。
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

让标题更大一些
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.25)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src

文档标题也一样。
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

让错误面板有一个时间期限似乎是合理的。
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

然后，我们可以通过将引用块设置为 /斜体/ 来使它们更加突出。
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

Org 文件看起来很漂亮，尤其是一些自定义的部分。然而这是有代价的，字体锁定消耗极大。
在大文件中，感觉在糖蜜中打字并不好玩，但有一种方法可以让我在打字时推迟字体锁定，使体
验更具响应性。

#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

显然这会引起一些人的问题，但除了预期的字体化轻微延迟之外，我没有注意到任何问题，所以
在我会好好使用的。

**** 内联代码块的字体化
Org 使用 =#+begin_src= 块做了一些超棒的事情，比如在后台使用 font-lock 作为语言
的主要模式，并拉出彩色结果。相比之下，内联 =src_= 块在某种程度上被忽略了。

我不是第一个有这种感觉的人，谢天谢地，其他人已经 [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][通过 stackexchange]] 来表达他们对
内联 src 字体化的渴望。我打算偷取他们的工作，但不幸的是，他们没有给出 /真正的/ 字
体化代码，而只是将 =org-code= face 应用于内容。

我们可以做的更好！用 ~org-src-font-lock-fontify-block~ 我们可以应用合适语言支
持的语法高亮。然后，接下来用 ={{{results(...)}}}= ，它能将 =org-block= 应用到
匹配中，然后通过模仿 ~prettify-symbols-mode~ 的行为隐藏值环境结构。

#+begin_warning
这目前仅突出显示每行中的一个内联 src 块。我不知道它为什么会停止，但我宁愿它没有。如
果您知道发生了什么或如何解决此问题，请与我们联系。
#+end_warning

#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src

Doom 主题额外的字体化相比帮助则更多的是问题。
#+begin_src emacs-lisp
(setq doom-themes-org-fontify-special-tags nil)
#+end_src

**** 符号
更改用于折叠项目的字符也很好 (默认情况下 ~…~)，我认为用 ~▾~ 更适合指示 「折叠部分
」。并在默认的四个列表中添加一个额外的 ~org-bullet~ 。我还添加了一些有趣的替代品
，只是注释掉了。
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t ))

(setq org-ellipsis " ▾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

将 Unicode 字符用于复选框和其他命令也很好。
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    "⚙"
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "⁍")
#+end_src

~org-superstar-mode~ 很棒，当我们这样做的时候，我们也可以让标签更漂亮。
#+begin_src emacs-lisp :tangle packages.el
;; (package! org-pretty-tags :pin "5c7521651b35ae9a7d3add4a66ae8cc176ae1c76")
#+end_src

#+begin_src emacs-lisp
;; (use-package org-pretty-tags
;; :config
;;  (setq org-pretty-tags-surrogate-strings
;;        `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;          ("ucc"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;          ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;          ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;          ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;          ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;  (org-pretty-tags-global-mode))
#+end_src

**** LaTeX 片段
***** 更漂亮的高亮
首先让这些片段看起来很棒。
#+begin_src emacs-lisp
(setq! org-highlight-latex-and-related '(native script entities))
#+end_src

然而通过使用原生突出显示，添加了 =org-block= ，这看起来不太好 --- 尤其是在预览
片段时。

理想情况下 ~org-src-font-lock-fontify-block~ 不会添加 =org-block= ，但我
们可以通过添加带有 =:inherit default= 面来避免整个功能，这将覆盖背景颜色。

检查 ~org-do-latex-and-related~ 显示 ="latex"= 是传递的语言参数，因此我们
可以如上所述覆盖背景。
#+begin_src emacs-lisp
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src
***** 更快的渲染
比语法高亮的 LaTeX 更好的是 /呈现/ LaTeX，我们可以使用 =org-fragtog= 自动执
行此操作。

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! org-fragtog :pin "680606189d5d28039e6f9301b55ec80517a24005")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

***** 更好看的渲染
自定义 LaTeX 片段的外观很舒适，这样它们就更适合文本了 --- 比如这个
$\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}$ 。
从添加衬线字体开始。我还想使用 =bmc-maths= 的一些功能，所以我们也会加载它。

#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src

既然我们可以，不如让背景颜色匹配 =默认= ，我们让它透明。
#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src
***** 渲染速度测试
我们可以从 ~dvi~ 或 ~pdf~ 文件进行渲染，所以让我们对 ~latex~ 和 ~pdflatex~
进行基准测试。
| ~latex~ time | ~pdflatex~ time |
|--------------+-----------------|
| 135 \pm 2 ms | 215 \pm 3 ms    |

在渲染方面，有两个我感兴趣的 ~.dvi~ 到图像的转换器： ~dvipng~ 和 ~dvisvgm~ 。然后使用 ~.pdf~ 我们有 ~pdf2svg~ 。对于内联预览我们关心速度，而对于导出，我
们关心文件大小且更喜欢矢量图形。

使用上述 LaTeX 程序和基准测试结果如下：
| ~dvipng~ time | ~dvisvgm~ time | ~pdf2svg~ time |
|---------------+----------------+----------------|
| 89 \pm 2 ms   | 178 \pm 2 ms   | 12 \pm 2 ms    |

现在让我们结合起来看看什么是最好的
| Tool chain             | Total time   | Resultant file size |
|------------------------+--------------+---------------------|
| ~latex~ + ~dvipng~     | 226 \pm 2 ms | 7 KiB               |
| ~latex~ + ~dvisvgm~    | 392 \pm 4 ms | 8 KiB               |
| ~pdflatex~ + ~pdf2svg~ | 230 \pm 2 ms | 16 KiB              |

所以我们在 Emacs 中用 ~dvipng~ 来预览 LaTeX 片段吧，将 ~dvisvgm~ 拥用于
[[LaTeX Rendering]]。

#+begin_warning
不幸的是，据说 SVG 大小似乎很恼人，所以我们现在不这样做。
#+end_warning

**** 从 [[https://github.com/jkitchin/scimax][scimax]] 偷来的 (现在正在半工作)
对片段做一些调整
#+begin_src emacs-lisp
(defun scimax-org-latex-fragment-justify (justification)
  "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
  (interactive
   (list (intern-soft
          (completing-read "Justification (left): " '(left center right)
                           nil t nil nil 'left))))
  (let* ((ov (ov-at))
         (beg (ov-beg ov))
         (end (ov-end ov))
         (shift (- beg (line-beginning-position)))
         (img (overlay-get ov 'display))
         (img (and (and img (consp img) (eq (car img) 'image)
                        (image-type-available-p (plist-get (cdr img) :type)))
                   img))
         space-left offset)
    (when (and img
               ;; This means the equation is at the start of the line
               (= beg (line-beginning-position))
               (or
                (string= "" (s-trim (buffer-substring end (line-end-position))))
                (eq 'latex-environment (car (org-element-context)))))
      (setq space-left (- (window-max-chars-per-line) (car (image-size img)))
            offset (floor (cond
                           ((eq justification 'center)
                            (- (/ space-left 2) shift))
                           ((eq justification 'right)
                            (- space-left shift))
                           (t
                            0))))
      (when (>= offset 0)
        (overlay-put ov 'before-string (make-string offset ?\ ))))))

(defun scimax-org-latex-fragment-justify-advice (beg end image imagetype)
  "After advice function to justify fragments."
  (scimax-org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))


(defun scimax-toggle-latex-fragment-justification ()
  "Toggle if LaTeX fragment justification options can be used."
  (interactive)
  (if (not (get 'scimax-org-latex-fragment-justify-advice 'enabled))
      (progn
        (advice-add 'org--format-latex-make-overlay :after 'scimax-org-latex-fragment-justify-advice)
        (put 'scimax-org-latex-fragment-justify-advice 'enabled t)
        (message "Latex fragment justification enabled"))
    (advice-remove 'org--format-latex-make-overlay 'scimax-org-latex-fragment-justify-advice)
    (put 'scimax-org-latex-fragment-justify-advice 'enabled nil)
    (message "Latex fragment justification disabled")))
#+end_src

还有这些等式编号
#+begin_src emacs-lisp
;; Numbered equations all have (1) as the number for fragments with vanilla
;; org-mode. This code injects the correct numbers into the previews so they
;; look good.
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin . env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))

(advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
(put 'scimax-org-renumber-environment 'enabled t)
#+end_src
**** Org Plot
我们可以使用 =org-plot= 中的一些变量来使用当前的 doom 主题颜色。
#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# border styles
set tics out nomirror
set border 3

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src
*** 导出
**** 通用设置
默认情况下，Org 仅将前三个级别的标题导出为标题。很烦人，因为我的文档经常超过三个层
标题的深度。我关心的两种主要导出格式是 LaTeX 和 HTML。当使用 =article= 时，
LaTeX 标题从 =\section= 、 =\subsection= 、 =\subsubsection= 和
=\paragraph= 、 =\subgraph= --- /五/ 个级别。HTML5 有六级标题 (=<h1>= 到
=<h6>=)，但第一级 Org 标题被导出为 =<h2>= 元素 --- 剩下 /五/ 个可用级别。

因此，在导出时识别前五个级别的 Org 标题似乎是有意义的。
#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

我还将使用 =ox-extra= 中的一个项目，以便我可以在标题中添加 =:ignore:= 标记以保
留内容，但标题本身被忽略 (不像 =:noexport:= 忽略标题和内容)。写作结构中，当我想
使用标题来提供未出现在最终文档中的内容，这很有用。

#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

由于我 (大致) 跟踪 Org HEAD，因此在创建者字符串中包含 git 版本是有意义的。
#+begin_src emacs-lisp
(setq org-export-creator-string
      (format "Emacs %s (Org mode %s–%s)" emacs-version (org-release) (org-git-version)))
#+end_src

**** 首字母缩略词格式
我喜欢自动使用带间距的小型大写字母作为首字母缩略词。对于我希望不受影响的字符串，让我
们使用 ~;~ 作为防止转换的前缀 --- 即 ~;JFK~ (正如人们想要的两个字母的地理位置和
名称)。

这必须在每种格式的基础上实现，目前支持 HTML 和 LaTeX 导出。

#+begin_src emacs-lisp
(defun org-export-filter-text-acronym (text backend _info)
  "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
  (let ((base-backend
         (cond
          ((org-export-derived-backend-p backend 'latex) 'latex)
          ;; Markdown is derived from HTML, but we don't want to format it
          ((org-export-derived-backend-p backend 'md) nil)
          ((org-export-derived-backend-p backend 'html) 'html)))
        (case-fold-search nil))
    (when base-backend
      (replace-regexp-in-string
       "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
       (lambda (all-caps-str)
         (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
               ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
               (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                         (substring all-caps-str -1 (length all-caps-str))
                                       nil)) ; needed to re-insert the [^A-Za-z] at the end
                         (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                         (acr (if final-char
                                  (substring all-caps-str 0 (if trailing-s -2 -1))
                                (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                    (pcase base-backend
                      ('latex (concat "\\acr{" (s-downcase acr) "}" (when trailing-s "\\acrs{}") final-char))
                      ('html (concat "<span class='acr'>" acr "</span>" (when trailing-s "<small>s</small>") final-char)))))))
       text t t))))

(add-to-list 'org-export-filter-plain-text-functions
             #'org-export-filter-text-acronym)

;; We won't use `org-export-filter-headline-functions' because it
;; passes (and formats) the entire section contents. That's no good.

(defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-html-format-headline-default-function', but with acronym formatting."
  (org-html-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
(setq org-html-format-headline-function #'org-html-format-headline-acronymised)

(defun org-latex-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-latex-format-headline-default-function', but with acronym formatting."
  (org-latex-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'latex info) tags info))
(setq org-latex-format-headline-function #'org-latex-format-headline-acronymised)
#+end_src
**** 导出 Org code

在我们所有的 Org 配置中，当使用 font-lock 的方法导出 Org 代码块时，可能会产生十
分难看的结果。为了解决这个问题，可以在导出时调整 ~+org-babel-mode-alist~​。

#+begin_src emacs-lisp
(defun +org-mode--fontlock-only-mode ()
  "Just apply org-mode's font-lock once."
  (let (org-mode-hook
        org-hide-leading-stars
        org-hide-emphasis-markers)
    (org-set-font-lock-defaults)
    (font-lock-ensure))
  (setq-local major-mode #'fundamental-mode))

(defun +org-export-babel-mask-org-config (_backend)
  "Use `+org-mode--fontlock-only-mode' instead of `org-mode'."
  (setq-local org-src-lang-modes
              (append org-src-lang-modes
                      (list (cons "org" #'+org-mode--fontlock-only)))))

(add-hook 'org-export-before-processing-hook #'+org-export-babel-mask-org-config)
#+end_src
*** HTML 导出
:PROPERTIES:
:header-args:emacs-lisp: :noweb-ref ox-html-conf
:END:

我想调整一大堆东西。虽然我一直都希望进行调整，但有时我可能想使用默认的配置来测试结果如
何。考虑到这一点，全局次要模式似乎是最适合使用的架构。

#+begin_src emacs-lisp
(define-minor-mode org-fancy-html-export-mode
  "Toggle my fabulous org export tweaks. While this mode itself does a little bit,
the vast majority of the change in behaviour comes from switch statements in:
 - `org-html-template-fancier'
 - `org-html--build-meta-info-extended'
 - `org-html-src-block-collapsable'
 - `org-html-block-collapsable'
 - `org-html-table-wrapped'
 - `org-html--format-toc-headline-colapseable'
 - `org-html--toc-text-stripped-leaves'
 - `org-export-html-headline-anchor'"
  :global t
  :init-value t
  (if org-fancy-html-export-mode
      (setq org-html-style-default org-html-style-fancy
            org-html-meta-tags #'org-html-meta-tags-fancy
            org-html-checkbox-type 'html-span)
    (setq org-html-style-default org-html-style-plain
          org-html-meta-tags #'org-html-meta-tags-default
          org-html-checkbox-type 'html)))
#+end_src

在很多情况下，我想修改 =ox-html= 中定义的变量，所以我们将把本节的内容包装在
src_elisp{(after! ox-html ...)} 块中。
#+begin_src emacs-lisp :noweb no-export :noweb-ref org-conf
(after! ox-html
  <<ox-html-conf>>
)
#+end_src

**** 额外的头内容
我们想在主体的开头添加更多信息。不幸的是，似乎没有任何好的变量或 hook，所以我们重写
相关的函数。

这样做是为了让我可以在页眉中添加日期和作者，实现仅 CSS 的亮/暗主题切换，以及一些
[[https://ogp.me/][Open Graph]] 元数据。

#+begin_src emacs-lisp
(defadvice! org-html-template-fancier (orig-fn contents info)
  "Return complete document string after HTML conversion.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options. Adds a few extra things to the body
compared to the default implementation."
  :around #'org-html-template
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn contents info)
    (concat
     (when (and (not (org-html-html5-p info)) (org-html-xhtml-p info))
       (let* ((xml-declaration (plist-get info :html-xml-declaration))
              (decl (or (and (stringp xml-declaration) xml-declaration)
                        (cdr (assoc (plist-get info :html-extension)
                                    xml-declaration))
                        (cdr (assoc "html" xml-declaration))
                        "")))
         (when (not (or (not decl) (string= "" decl)))
           (format "%s\n"
                   (format decl
                           (or (and org-html-coding-system
                                    (fboundp 'coding-system-get)
                                    (coding-system-get org-html-coding-system 'mime-charset))
                               "utf-8"))))))
     (org-html-doctype info)
     "\n"
     (concat "<html"
             (cond ((org-html-xhtml-p info)
                    (format
                     " xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"%s\" xml:lang=\"%s\""
                     (plist-get info :language) (plist-get info :language)))
                   ((org-html-html5-p info)
                    (format " lang=\"%s\"" (plist-get info :language))))
             ">\n")
     "<head>\n"
     (org-html--build-meta-info info)
     (org-html--build-head info)
     (org-html--build-mathjax-config info)
     "</head>\n"
     "<body>\n<input type='checkbox' id='theme-switch'><div id='page'><label id='switch-label' for='theme-switch'></label>"
     (let ((link-up (org-trim (plist-get info :html-link-up)))
           (link-home (org-trim (plist-get info :html-link-home))))
       (unless (and (string= link-up "") (string= link-home ""))
         (format (plist-get info :html-home/up-format)
                 (or link-up link-home)
                 (or link-home link-up))))
     ;; Preamble.
     (org-html--build-pre/postamble 'preamble info)
     ;; Document contents.
     (let ((div (assq 'content (plist-get info :html-divs))))
       (format "<%s id=\"%s\">\n" (nth 1 div) (nth 2 div)))
     ;; Document title.
     (when (plist-get info :with-title)
       (let ((title (and (plist-get info :with-title)
                         (plist-get info :title)))
             (subtitle (plist-get info :subtitle))
             (html5-fancy (org-html--html5-fancy-p info)))
         (when title
           (format
            (if html5-fancy
                "<header class=\"page-header\">%s\n<h1 class=\"title\">%s</h1>\n%s</header>"
              "<h1 class=\"title\">%s%s</h1>\n")
            (if (or (plist-get info :with-date)
                    (plist-get info :with-author))
                (concat "<div class=\"page-meta\">"
                        (when (plist-get info :with-date)
                          (org-export-data (plist-get info :date) info))
                        (when (and (plist-get info :with-date) (plist-get info :with-author)) ", ")
                        (when (plist-get info :with-author)
                          (org-export-data (plist-get info :author) info))
                        "</div>\n")
              "")
            (org-export-data title info)
            (if subtitle
                (format
                 (if html5-fancy
                     "<p class=\"subtitle\" role=\"doc-subtitle\">%s</p>\n"
                   (concat "\n" (org-html-close-tag "br" nil info) "\n"
                           "<span class=\"subtitle\">%s</span>\n"))
                 (org-export-data subtitle info))
              "")))))
     contents
     (format "</%s>\n" (nth 1 (assq 'content (plist-get info :html-divs))))
     ;; Postamble.
     (org-html--build-pre/postamble 'postamble info)
     ;; Possibly use the Klipse library live code blocks.
     (when (plist-get info :html-klipsify-src)
       (concat "<script>" (plist-get info :html-klipse-selection-script)
               "</script><script src=\""
               org-html-klipse-js
               "\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\""
               org-html-klipse-css "\"/>"))
     ;; Closing document.
     "</div>\n</body>\n</html>")))
#+end_src

我认为如果 "目录" 将您带回页面顶部会很好。好吧，既然我们已经做了这么多建议...
#+begin_src emacs-lisp
(defadvice! org-html-toc-linked (depth info &optional scope)
  "Build a table of contents.

Just like `org-html-toc', except the header is a link to \"#\".

DEPTH is an integer specifying the depth of the table.  INFO is
a plist used as a communication channel.  Optional argument SCOPE
is an element defining the scope of the table.  Return the table
of contents as a string, or nil if it is empty."
  :override #'org-html-toc
  (let ((toc-entries
         (mapcar (lambda (headline)
                   (cons (org-html--format-toc-headline headline info)
                         (org-export-get-relative-level headline info)))
                 (org-export-collect-headlines info depth scope))))
    (when toc-entries
      (let ((toc (concat "<div id=\"text-table-of-contents\">"
                         (org-html--toc-text toc-entries)
                         "</div>\n")))
        (if scope toc
          (let ((outer-tag (if (org-html--html5-fancy-p info)
                               "nav"
                             "div")))
            (concat (format "<%s id=\"table-of-contents\">\n" outer-tag)
                    (let ((top-level (plist-get info :html-toplevel-hlevel)))
                      (format "<h%d><a href=\"#\" style=\"color:inherit; text-decoration: none;\">%s</a></h%d>\n"
                              top-level
                              (org-html--translate "Table of Contents" info)
                              top-level))
                    toc
                    (format "</%s>\n" outer-tag))))))))
#+end_src

最后，让我们堆积一些元数据。这些嵌入就快完成了。
#+begin_src emacs-lisp
(defvar org-html-meta-tags-opengraph-image
  '(:image "https://tecosaur.com/resources/org/nib.png"
    :type "image/png"
    :width "200"
    :height "200"
    :alt "Green fountain pen nib")
  "Plist of og:image:PROP properties and their value, for use in `org-html-meta-tags-fancy'.")

(defun org-html-meta-tags-fancy (info)
  "Use the INFO plist to construct the meta tags, as described in `org-html-meta-tags'."
  (let ((title (org-html-plain-text
                (org-element-interpret-data (plist-get info :title)) info))
        (author (and (plist-get info :with-author)
                     (let ((auth (plist-get info :author)))
                       ;; Return raw Org syntax.
                       (and auth (org-html-plain-text
                                  (org-element-interpret-data auth) info))))))
    (append
     (list
      (when (org-string-nw-p author)
        (list "name" "author" author))
      (when (org-string-nw-p (plist-get info :description))
        (list "name" "description"
              (plist-get info :description)))
      '("name" "generator" "org mode")
      '("name" "theme-color" "#77aa99")
      '("property" "og:type" "article")
      (list "property" "og:title" title)
      (let ((subtitle (org-export-data (plist-get info :subtitle) info)))
        (when (org-string-nw-p subtitle)
          (list "property" "og:description" subtitle))))
     (when org-html-meta-tags-opengraph-image
       (list (list "property" "og:image" (plist-get org-html-meta-tags-opengraph-image :image))
             (list "property" "og:image:type" (plist-get org-html-meta-tags-opengraph-image :type))
             (list "property" "og:image:width" (plist-get org-html-meta-tags-opengraph-image :width))
             (list "property" "og:image:height" (plist-get org-html-meta-tags-opengraph-image :height))
             (list "property" "og:image:alt" (plist-get org-html-meta-tags-opengraph-image :alt))))
     (list
      (when (org-string-nw-p author)
        (list "property" "og:article:author:first_name" (car (s-split-up-to " " author 2))))
      (when (and (org-string-nw-p author) (s-contains-p " " author))
        (list "property" "og:article:author:last_name" (cadr (s-split-up-to " " author 2))))
      (list "property" "og:article:published_time"
            (format-time-string
             "%FT%T%z"
             (or
              (when-let ((date-str (cadar (org-collect-keywords '("DATE")))))
                (unless (string= date-str (format-time-string "%F"))
                  (ignore-errors (encode-time (org-parse-time-string date-str)))))
              (if buffer-file-name
                  (file-attribute-modification-time (file-attributes buffer-file-name))
                (current-time)))))
      (when buffer-file-name
        (list "property" "og:article:modified_time"
              (format-time-string "%FT%T%z" (file-attribute-modification-time (file-attributes buffer-file-name)))))))))

(unless (functionp #'org-html-meta-tags-default)
  (defalias 'org-html-meta-tags-default #'ignore))
(setq org-html-meta-tags #'org-html-meta-tags-fancy)
#+end_src
**** 自定义 CSS/JS
默认的 org HTML 导出是...好吧，但我们真的可以让它变得好看起来。[[https://lepisma.xyz][lepisma.xyz]] 的风
格非常好，而且也有 from 和 org 导出！可以说我爱上了它，并做了一点我自己的调整。

#+begin_src html :tangle misc/org-export-header.html :comments no
<link rel="icon" href="https://tecosaur.com/resources/org/nib.ico" type="image/ico" />

<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-roman-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-italic-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextRegular.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextItalic.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextBold.woff2">
#+end_src

#+begin_src emacs-lisp
(setq org-html-style-plain org-html-style-default
      org-html-htmlize-output-type 'css
      org-html-doctype "html5"
      org-html-html5-fancy t)

(defun org-html-reload-fancy-style ()
  (interactive)
  (setq org-html-style-fancy
        (concat (f-read-text (expand-file-name "misc/org-export-header.html" doom-private-dir))
                "<script>\n"
                (f-read-text (expand-file-name "misc/org-css/main.js" doom-private-dir))
                "</script>\n<style>\n"
                (f-read-text (expand-file-name "misc/org-css/main.min.css" doom-private-dir))
                "</style>"))
  (when org-fancy-html-export-mode
    (setq org-html-style-default org-html-style-fancy)))
(org-html-reload-fancy-style)
#+end_src
**** 可折叠的 src 和示例块
通过将 ~<pre>~ 元素包装在 ~<details>~ 块中，我们可以得到没有 CSS 的可折叠块，
尽管我们会稍微折腾一下，让这看起来有点漂亮。

由于默认情况下对某些代码块启用可折叠性似乎很有用，因此如果您可以使用
=#+attr_html: :collapsed t= 设置它会更好。

如果有一个相应的全局/会话本地方式来设置它会很好，但我还没能让它正常工作。

#+begin_src emacs-lisp
(defvar org-html-export-collapsed nil)
(eval '(cl-pushnew '(:collapsed "COLLAPSED" "collapsed" org-html-export-collapsed t)
                   (org-export-backend-options (org-export-get-backend 'html))))
(add-to-list 'org-default-properties "EXPORT_COLLAPSED")
#+end_src

我们可以进一步修改 src 块，并在 src 块的一侧添加一个块，其中包含引用当前块的锚点和
复制块内容的按钮。

#+name: Src blocks
#+begin_src emacs-lisp
(defadvice! org-html-src-block-collapsable (orig-fn src-block contents info)
  "Wrap the usual <pre> block in a <details>"
  :around #'org-html-src-block
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn src-block contents info)
    (let* ((properties (cadr src-block))
           (lang (mode-name-to-lang-name
                  (plist-get properties :language)))
           (name (plist-get properties :name))
           (ref (org-export-get-reference src-block info))
           (collapsed-p (member (or (org-export-read-attribute :attr_html src-block :collapsed)
                                    (plist-get info :collapsed))
                                '("y" "yes" "t" t "true" "all"))))
      (format
       "<details id='%s' class='code'%s><summary%s>%s</summary>
<div class='gutter'>
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>⎘</button>\
</div>
%s
</details>"
       ref
       (if collapsed-p "" " open")
       (if name " class='named'" "")
       (concat
        (when name (concat "<span class=\"name\">" name "</span>"))
        "<span class=\"lang\">" lang "</span>")
       ref
       (if name
           (replace-regexp-in-string (format "<pre\\( class=\"[^\"]+\"\\)? id=\"%s\">" ref) "<pre\\1>"
                                     (funcall orig-fn src-block contents info))
         (funcall orig-fn src-block contents info))))))

(defun mode-name-to-lang-name (mode)
  (or (cadr (assoc mode
                   '(("asymptote" "Asymptote")
                     ("awk" "Awk")
                     ("C" "C")
                     ("clojure" "Clojure")
                     ("css" "CSS")
                     ("D" "D")
                     ("ditaa" "ditaa")
                     ("dot" "Graphviz")
                     ("calc" "Emacs Calc")
                     ("emacs-lisp" "Emacs Lisp")
                     ("fortran" "Fortran")
                     ("gnuplot" "gnuplot")
                     ("haskell" "Haskell")
                     ("hledger" "hledger")
                     ("java" "Java")
                     ("js" "Javascript")
                     ("latex" "LaTeX")
                     ("ledger" "Ledger")
                     ("lisp" "Lisp")
                     ("lilypond" "Lilypond")
                     ("lua" "Lua")
                     ("matlab" "MATLAB")
                     ("mscgen" "Mscgen")
                     ("ocaml" "Objective Caml")
                     ("octave" "Octave")
                     ("org" "Org mode")
                     ("oz" "OZ")
                     ("plantuml" "Plantuml")
                     ("processing" "Processing.js")
                     ("python" "Python")
                     ("R" "R")
                     ("ruby" "Ruby")
                     ("sass" "Sass")
                     ("scheme" "Scheme")
                     ("screen" "Gnu Screen")
                     ("sed" "Sed")
                     ("sh" "shell")
                     ("sql" "SQL")
                     ("sqlite" "SQLite")
                     ("forth" "Forth")
                     ("io" "IO")
                     ("J" "J")
                     ("makefile" "Makefile")
                     ("maxima" "Maxima")
                     ("perl" "Perl")
                     ("picolisp" "Pico Lisp")
                     ("scala" "Scala")
                     ("shell" "Shell Script")
                     ("ebnf2ps" "ebfn2ps")
                     ("cpp" "C++")
                     ("abc" "ABC")
                     ("coq" "Coq")
                     ("groovy" "Groovy")
                     ("bash" "bash")
                     ("csh" "csh")
                     ("ash" "ash")
                     ("dash" "dash")
                     ("ksh" "ksh")
                     ("mksh" "mksh")
                     ("posh" "posh")
                     ("ada" "Ada")
                     ("asm" "Assembler")
                     ("caml" "Caml")
                     ("delphi" "Delphi")
                     ("html" "HTML")
                     ("idl" "IDL")
                     ("mercury" "Mercury")
                     ("metapost" "MetaPost")
                     ("modula-2" "Modula-2")
                     ("pascal" "Pascal")
                     ("ps" "PostScript")
                     ("prolog" "Prolog")
                     ("simula" "Simula")
                     ("tcl" "tcl")
                     ("tex" "LaTeX")
                     ("plain-tex" "TeX")
                     ("verilog" "Verilog")
                     ("vhdl" "VHDL")
                     ("xml" "XML")
                     ("nxml" "XML")
                     ("conf" "Configuration File"))))
      mode))
#+end_src

#+name: Example, fixed width, and property blocks
#+begin_src emacs-lisp
(defun org-html-block-collapsable (orig-fn block contents info)
  "Wrap the usual block in a <details>"
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn block contents info)
    (let ((ref (org-export-get-reference block info))
          (type (pcase (car block)
                  ('property-drawer "Properties")))
          (collapsed-default (pcase (car block)
                               ('property-drawer t)
                               (_ nil)))
          (collapsed-value (org-export-read-attribute :attr_html block :collapsed))
          (collapsed-p (or (member (org-export-read-attribute :attr_html block :collapsed)
                                   '("y" "yes" "t" t "true"))
                           (member (plist-get info :collapsed) '("all")))))
      (format
       "<details id='%s' class='code'%s>
<summary%s>%s</summary>
<div class='gutter'>\
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>⎘</button>\
</div>
%s\n
</details>"
       ref
       (if (or collapsed-p collapsed-default) "" " open")
       (if type " class='named'" "")
       (if type (format "<span class='type'>%s</span>" type) "")
       ref
       (funcall orig-fn block contents info)))))

(advice-add 'org-html-example-block   :around #'org-html-block-collapsable)
(advice-add 'org-html-fixed-width     :around #'org-html-block-collapsable)
(advice-add 'org-html-property-drawer :around #'org-html-block-collapsable)
#+end_src

**** 包含 HTML 化的额外字体锁
Org 使用 [[https://github.com/hniksic/emacs-htmlize][htmlize.el]] 导出带有语法高亮的缓冲区。

在大多数情况下这些格式非常棒。不需要加载提供字体锁定的次要模式，因此不会影响结果。

通过在 ~htmlize-before-hook~ 中启用这些模式，我们可以纠正这种行为。
#+begin_src emacs-lisp
(autoload #'highlight-numbers--turn-on "highlight-numbers")
(add-hook 'htmlize-before-hook #'highlight-numbers--turn-on)
#+end_src

**** 处理表溢出
为了适应宽表 --- 尤其是在移动设备上 --- 我们想要设置最大宽度和滚动溢出。不幸的是，
这不能直接应用于 ~表格~ 元素，所以我们必须将它包装在一个 ~div~ 中。

当我们这样做时，我们可以像我们对 src 块所做的那样，设置一个链接块，并显示
~#+name~ (如果有的话)。
#+begin_src emacs-lisp
(defadvice! org-html-table-wrapped (orig-fn table contents info)
  "Wrap the usual <table> in a <div>"
  :around #'org-html-table
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn table contents info)
    (let* ((name (plist-get (cadr table) :name))
           (ref (org-export-get-reference table info)))
      (format "<div id='%s' class='table'>
<div class='gutter'><a href='#%s'>#</a></div>
<div class='tabular'>
%s
</div>\
</div>"
              ref ref
              (if name
                  (replace-regexp-in-string (format "<table id=\"%s\"" ref) "<table"
                                            (funcall orig-fn table contents info))
                (funcall orig-fn table contents info))))))
#+end_src

**** 可展开的目录树
TOC 作为可折叠树更易于导航。不幸的是，我们不能单独使用 CSS 来实现这一点。值得庆幸
的是，我们可以通过调整 TOC 生成代码来为每个项目使用一个 ~标签~ ，以及一个隐藏的
~复选框~ 来跟踪状态，从而避免使用 JS。

要添加它，我们需要在 [[file:~/.emacs.d/.local/straight/repos/org-mode/lisp/ox-html.el::(format "<a href=\"#%s\">%s</a>"][org-html--format-toc-headline]] 中更改一行。

因为我们实际上可以通过在函数周围添加建议来实现所需的效果，而无需覆盖它 --- 让我们这
样做来减少这个配置的错误表面。
#+begin_src emacs-lisp
(defadvice! org-html--format-toc-headline-colapseable (orig-fn headline info)
  "Add a label and checkbox to `org-html--format-toc-headline's usual output,
to allow the TOC to be a collapseable tree."
  :around #'org-html--format-toc-headline
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn headline info)
    (let ((id (or (org-element-property :CUSTOM_ID headline)
                  (org-export-get-reference headline info))))
      (format "<input type='checkbox' id='toc--%s'/><label for='toc--%s'>%s</label>"
              id id (funcall orig-fn headline info)))))
#+end_src

现在，叶子 (没有子标题的标题) 不应该有 ~标签项~ 。实现这一点的明显方法是在
~org-html--format-toc-headline-colapseable~ 中包含一些 (如果没有子项) 逻辑
。不幸的是，我的 elisp 无法从 org 提供的大量信息中提取子标题的数量。
#+begin_src emacs-lisp
(defadvice! org-html--toc-text-stripped-leaves (orig-fn toc-entries)
  "Remove label"
  :around #'org-html--toc-text
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn toc-entries)
    (replace-regexp-in-string "<input [^>]+><label [^>]+>\\(.+?\\)</label></li>" "\\1</li>"
                              (funcall orig-fn toc-entries))))
#+end_src

**** 使 verbatim 与 code 不同
让我们为 =varbatim= 和 ~code~ 添加一些差异。

我们可以将 ~code~ 专门用于代码片段和命令，例如：在 Emacs 的批处理模式中调用
src_elisp{(message "Hello")} 会像 ~echo~ 一样打印到标准输出。 可以对
=verbatim= 使用各种 '其他等宽'，例如键盘快捷键： =C-c C-c= 或 =C-g= 可能是
Emacs 中最有用的快捷键，或文件名：我将我的配置保存在 =~/.config/doom/= 中，其他
情况则使用正常样式。

然后，对这两种情况进行不同的样式设置有助于提高文档的清晰度。

#+begin_src emacs-lisp
(setq org-html-text-markup-alist
      '((bold . "<b>%s</b>")
        (code . "<code>%s</code>")
        (italic . "<i>%s</i>")
        (strike-through . "<del>%s</del>")
        (underline . "<span class=\"underline\">%s</span>")
        (verbatim . "<kbd>%s</kbd>")))
#+end_src

**** 改变复选框类型
我们也想使用 HTML 复选框，但是我们想比默认的更漂亮
#+begin_src emacs-lisp
(appendq! org-html-checkbox-types
          '((html-span
             (on . "<span class='checkbox'></span>")
             (off . "<span class='checkbox'></span>")
             (trans . "<span class='checkbox'></span>"))))
(setq org-html-checkbox-type 'html-span)
#+end_src
- [ ] I'm yet to do this
- [-] Work in progress
- [X] This is done

**** 额外的特殊字符串
~org-html-special-string-regexps~ 变量定义了以下内容的替换：
+ =\-=, shy 连字符
+ =---=, 增强的破折号
+ =--=, 破折号
+ =...=, (水平的) 省略号

但我认为如果还可以替换左/右箭头 (=->= 和 =<-=) 那就更好了。 这是一个
~defconst~ ，但正如你可以从这个配置中的大量建议中看出的那样，我并没有放弃我不 '应
该' 做的事情。

唯一的小麻烦是在这个阶段的输出处理之前 =<= 和 =>= 被转换为 =&lt;= 和 =&gt;= 。
#+begin_src emacs-lisp
(pushnew! org-html-special-string-regexps
          '("-&gt;" . "&#8594;")
          '("&lt;-" . "&#8592;"))
#+end_src

**** 标题锚点
一个 GitHub 风格的标题链接
#+begin_src emacs-lisp
(defun org-export-html-headline-anchor (text backend info)
  (when (and (org-export-derived-backend-p backend 'html)
             (not (org-export-derived-backend-p backend 're-reveal))
             org-fancy-html-export-mode)
    (unless (bound-and-true-p org-msg-export-in-progress)
      (replace-regexp-in-string
       "<h\\([0-9]\\) id=\"\\([a-z0-9-]+\\)\">\\(.*[^ ]\\)<\\/h[0-9]>" ; this is quite restrictive, but due to `org-reference-contraction' I can do this
       "<h\\1 id=\"\\2\">\\3<a aria-hidden=\"true\" href=\"#\\2\">#</a> </h\\1>"
       text))))

(add-to-list 'org-export-filter-headline-functions
             'org-export-html-headline-anchor)
#+end_src

**** 链接预览
有时让链接特别突出会很好，我认为像 Twitter 那样的嵌入 / 预览会很好。

我们可以通过添加一个与 =https= --- =Https= 略有不同的新链接类型来轻松做到这点。

#+begin_src emacs-lisp
(org-link-set-parameters "Https"
                         :follow (lambda (url arg) (browse-url (concat "https:" url) arg))
                         :export #'org-url-fancy-export)
#+end_src

然后，如果我们可以通过函数 ~org-url-unfurl-metadata~ 为此类链接获取
src_elisp{(:title "..." :description "..." :image "...")} 形式的 plist
，我们就可以进行精美的导出。

#+begin_src emacs-lisp
(defun org-url-fancy-export (url _desc backend)
  (let ((metadata (org-url-unfurl-metadata (concat "https:" url))))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (concat
       "<div class=\"link-preview\">"
       (format "<a href=\"%s\">" (concat "https:" url))
       (when (plist-get metadata :image)
         (format "<img src=\"%s\"/>" (plist-get metadata :image)))
       "<small>"
       (replace-regexp-in-string "//\\(?:www\\.\\)?\\([^/]+\\)/?.*" "\\1" url)
       "</small><p>"
       (when (plist-get metadata :title)
         (concat "<b>" (org-html-encode-plain-text (plist-get metadata :title)) "</b></br>"))
       (when (plist-get metadata :description)
         (org-html-encode-plain-text (plist-get metadata :description)))
       "</p></a></div>"))
     (t url))))
#+end_src

现在我们只需要实现元数据提取功能。
#+begin_src emacs-lisp
(setq org-url-unfurl-metadata--cache nil)
(defun org-url-unfurl-metadata (url)
  (cdr (or (assoc url org-url-unfurl-metadata--cache)
           (car (push
                 (cons
                  url
                  (let* ((head-data
                          (-filter #'listp
                                   (cdaddr
                                    (with-current-buffer (progn (message "Fetching metadata from %s" url)
                                                                (url-retrieve-synchronously url t t 5))
                                      (goto-char (point-min))
                                      (delete-region (point-min) (- (search-forward "<head") 6))
                                      (delete-region (search-forward "</head>") (point-max))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<script[^\u2800]+?</script>" nil t)
                                        (replace-match ""))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<style[^\u2800]+?</style>" nil t)
                                        (replace-match ""))
                                      (libxml-parse-html-region (point-min) (point-max))))))
                         (meta (delq nil
                                     (mapcar
                                      (lambda (tag)
                                        (when (eq 'meta (car tag))
                                          (cons (or (cdr (assoc 'name (cadr tag)))
                                                    (cdr (assoc 'property (cadr tag))))
                                                (cdr (assoc 'content (cadr tag))))))
                                      head-data))))
                    (let ((title (or (cdr (assoc "og:title" meta))
                                     (cdr (assoc "twitter:title" meta))
                                     (nth 2 (assq 'title head-data))))
                          (description (or (cdr (assoc "og:description" meta))
                                           (cdr (assoc "twitter:description" meta))
                                           (cdr (assoc "description" meta))))
                          (image (or (cdr (assoc "og:image" meta))
                                     (cdr (assoc "twitter:image" meta)))))
                      (when image
                        (setq image (replace-regexp-in-string
                                     "^/" (concat "https://" (replace-regexp-in-string "//\\([^/]+\\)/?.*" "\\1" url) "/")
                                     (replace-regexp-in-string
                                      "^//" "https://"
                                      image))))
                      (list :title title :description description :image image))))
                 org-url-unfurl-metadata--cache)))))
#+end_src

**** LaTeX Rendering
***** 预渲染
我认为 ~dvisvgm~ 是一个相当引人注目的选择。然而目前这并不是很好地扩展。
#+begin_src emacs-lisp
;; (setq-default org-html-with-latex `dvisvgm)
#+end_src
***** MathJax
如果使用 MathJax，我们希望使用版本 3 而不是默认的版本 2。通过[[https://www.intmath.com/cg5/katex-mathjax-comparison.php][对比]]我们发现它似乎
快了 5 倍，而且它使用单个文件而不是多个文件，就是有点大而已。值得庆幸的是，这可以
通过添加 ~async~ 属性来延迟加载来缓解。
#+begin_src emacs-lisp
(setq org-html-mathjax-options
      '((path "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" )
        (scale "1")
        (autonumber "ams")
        (multlinewidth "85%")
        (tagindent ".8em")
        (tagside "right")))

(setq org-html-mathjax-template
      "<script>
MathJax = {
  chtml: {
    scale: %SCALE
  },
  svg: {
    scale: %SCALE,
    fontCache: \"global\"
  },
  tex: {
    tags: \"%AUTONUMBER\",
    multlineWidth: \"%MULTLINEWIDTH\",
    tagSide: \"%TAGSIDE\",
    tagIndent: \"%TAGINDENT\"
  }
};
</script>
<script id=\"MathJax-script\" async
        src=\"%PATH\"></script>")
#+end_src

*** LaTeX 导出
**** 编译
默认情况下，Org 使用 ~pdflatex~ \times 3 + ~bibtex~ 。 这在现代世界根本行不
通。 ~latexmk~ + ~biber~ (自动与 ~latexmk~ 一起使用) 是一个简单的优越组合。

#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

虽然 ~org-latex-pdf-process~ 确实支持一个函数，我们可以使用它来代替，但这将不再
使用日志缓冲区 --- 这有点盲目，你给它一个文件名并期望它做它的事情。

~org-latex-compilers~ 的默认值以注释形式给出，以查看
~org-latex-pdf-process~ 如何与它们一起工作。

虽然上面的 ~-%latex~ 有点 hacky (~-pdflatex~ 期望被赋予一个值)，但它允许我们 保持 ~org-latex-compilers~ 不变。如果我打开一个使用 =#+LATEX_COMPILER= 的
org 文件，这很好，它应该仍然可以工作。

**** 超棒的复选框
我们可以假设在序言部分，定义了下面的各种自定义 =\checkbox...= 命令。

#+begin_src emacs-lisp
(defun +org-export-latex-fancy-item-checkboxes (text backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string
     "\\\\item\\[{$\\\\\\(\\w+\\)$}\\]"
     (lambda (fullmatch)
       (concat "\\\\item[" (pcase (substring fullmatch 9 -3) ; content of capture group
                             ("square"   "\\\\checkboxUnchecked")
                             ("boxminus" "\\\\checkboxTransitive")
                             ("boxtimes" "\\\\checkboxChecked")
                             (_ (substring fullmatch 9 -3))) "]"))
     text)))

(add-to-list 'org-export-filter-item-functions
             '+org-export-latex-fancy-item-checkboxes)
#+end_src

**** 类模板
我真的很喜欢 KOMA 捆绑包。它提供了一组机制来调整文档样式，这些机制既易于使用，又非
常全面。例如，我更喜欢页边空白处的节号，这可以用下面的 LaTeX 来完成。
#+name: latex-hanging-secnum
#+begin_src LaTeX
\\renewcommand\\sectionformat{\\llap{\\thesection\\autodot\\enskip}}
\\renewcommand\\subsectionformat{\\llap{\\thesubsection\\autodot\\enskip}}
\\renewcommand\\subsubsectionformat{\\llap{\\thesubsubsection\\autodot\\enskip}}
#+end_src

还有超大的 =\chapter= 。
#+name: latex-big-chapter
#+begin_src LaTeX
\\RedeclareSectionCommand[afterindent=false, beforeskip=0pt, afterskip=0pt, innerskip=0pt]{chapter}
\\setkomafont{chapter}{\\normalfont\\Huge}
\\renewcommand*{\\chapterheadstartvskip}{\\vspace*{0\\baselineskip}}
\\renewcommand*{\\chapterheadendvskip}{\\vspace*{0\\baselineskip}}
\\renewcommand*{\\chapterformat}{%
  \\fontsize{60}{30}\\selectfont\\rlap{\\hspace{6pt}\\thechapter}}
\\renewcommand*\\chapterlinesformat[3]{%
  \\parbox[b]{\\dimexpr\\textwidth-0.5em\\relax}{%
    \\raggedleft{{\\large\\scshape\\bfseries\\chapapp}\\vspace{-0.5ex}\\par\\Huge#3}}%
    \\hfill\\makebox[0pt][l]{#2}}
#+end_src

现在让我们在 Org LaTeX 类中添加一些 KOMA。

#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (let* ((article-sections '(("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
         (book-sections (append '(("\\chapter{%s}" . "\\chapter*{%s}"))
                                article-sections))
         (hanging-secnum-preamble "
<<latex-hanging-secnum>>
")
         (big-chap-preamble "
<<latex-big-chapter>>
"))
    (setcdr (assoc "article" org-latex-classes)
            `(,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
              ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("report" ,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("book" ,(concat "\\documentclass[twoside=false]{scrbook}"
                                   big-chap-preamble hanging-secnum-preamble)
                   ,@book-sections))
    (add-to-list 'org-latex-classes
                 `("blank" "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc-article" "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc" "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@book-sections))))

(setq org-latex-tables-booktabs t
      org-latex-hyperref-template "
<<latex-fancy-hyperref>>
"
      org-latex-reference-command "\\cref{%s}")
#+end_src

然而 =hyperref= 设置需要单独处理。
#+name: latex-fancy-hyperref
#+begin_src LaTeX
\\providecolor{url}{HTML}{0077bb}
\\providecolor{link}{HTML}{882255}
\\providecolor{cite}{HTML}{999933}
\\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  breaklinks=true,
  colorlinks=true,
  linkcolor=link,
  urlcolor=url,
  citecolor=cite\n}
\\urlstyle{same}
#+end_src

**** 更智能的序言
***** 使用示例
我们经常希望在文档序言中包含特定的 LaTeX 片段。 每次都必须码出 / 记住它们是一种
痛苦。我几乎总是想包含下面的代码片段。

#+name: org-latex-embed-files-preamble
#+begin_src LaTeX
\\usepackage[main,include]{embedall}
\\IfFileExists{./\\jobname.org}{\\embedfile[desc=The original file]{\\jobname.org}}{}
#+end_src

我们可以在每个 ~org-latex-classes~ 中包含我们可能需要的每个包，但这非常低效，
我不想考虑维护它。

相反，我们可以通过拆分我们想要的功能来提供一些细粒度，然后通过实现一个系统来自动
检测需要哪些功能并生成提供这些功能的前导码，从而将体验提升到一个全新的水平。
***** 条件内容
让我们考虑在特定情况下我们想要的内容。

Caption 可以做一些调整，比如这样
+ 您可以轻松拥有多个 Caption
+ 指向图的链接将您带到图的顶部 (而不是底部)
+ Caption 标签可以稍微强调一点
+ 只有当跨越多行时，多行 Caption 应该向右一点

#+name: org-latex-caption-preamble
#+begin_src LaTeX
\\usepackage{subcaption}
\\usepackage[hypcap=true]{caption}
\\setkomafont{caption}{\\sffamily\\small}
\\setkomafont{captionlabel}{\\upshape\\bfseries}
\\captionsetup{justification=raggedright,singlelinecheck=true}
\\usepackage{capt-of} % required by Org
#+end_src

默认的复选框太丑了，用一些好看的替代品吧。
#+name: org-latex-checkbox-preamble
#+begin_src LaTeX
\\newcommand{\\checkboxUnchecked}{$\\square$}
\\newcommand{\\checkboxTransitive}{\\rlap{\\raisebox{-0.1ex}{\\hspace{0.35ex}\\Large\\textbf -}}$\\square$}
\\newcommand{\\checkboxChecked}{\\rlap{\\raisebox{0.2ex}{\\hspace{0.35ex}\\scriptsize \\ding{52}}}$\\square$}
#+end_src

"消息块" 是一个不错的想法，就像 info/warning/error/success。LaTeX 中的宏可
以创建它们。

#+name: org-latex-box-preamble
#+begin_src LaTeX
\\ExplSyntaxOn
\\NewCoffin\\Content
\\NewCoffin\\SideRule
\\NewDocumentCommand{\\defsimplebox}{O{\\ding{117}} O{0.36em} m m m}{%
  % #1 ding, #2 ding offset, #3 name, #4 colour, #5 default label
  \\definecolor{#3}{HTML}{#4}
  \\NewDocumentEnvironment{#3}{ O{#5} }
  {
    \\vcoffin_set:Nnw \\Content { \\linewidth }
    \\noindent \\ignorespaces
    \\par\\vspace{-0.7\\baselineskip}%
    \\textcolor{#3}{#1}~\\textcolor{#3}{\\textbf{##1}}%
    \\vspace{-0.8\\baselineskip}
    \\begin{addmargin}[1em]{1em}
    }
    {
    \\end{addmargin}
    \\vspace{-0.5\\baselineskip}
    \\vcoffin_set_end:
    \\SetHorizontalCoffin\\SideRule{\\color{#3}\\rule{1pt}{\\CoffinTotalHeight\\Content}}
    \\JoinCoffins*\\Content[l,t]\\SideRule[l,t](#2,-0.7em)
    \\noindent\\TypesetCoffin\\Content
    \\vspace*{\\CoffinTotalHeight\\Content}\\bigskip
    \\vspace{-2\\baselineskip}
  }
}
\\ExplSyntaxOff
#+end_src

最后，我们会将这些内容传递到一些全局变量中，以便于访问。

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-embed-files-preamble "
<<org-latex-embed-files-preamble>>
"
  "Preamble that embeds files within the pdf.")

(defvar org-latex-caption-preamble "
<<org-latex-caption-preamble>>
"
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble "
<<org-latex-checkbox-preamble>>
"
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble "
<<org-latex-box-preamble>>
"
  "Preamble that provides a macro for custom boxes.")
#+end_src

在 "通用序言" 中，我们已经嵌入了源 .org 文件，但最好嵌入所有 tangle 文件。通过
将每个 tangle 文件映射到嵌入文件 (如果存在) 的表单，这很容易实现。考虑到我们已
经走到了这一步，为什么不添加一个专用的 =#+emded= 关键字，这样我们就可以嵌入任何
我们想要的东西。

#+begin_src emacs-lisp
(defun org-latex-embed-extra-files ()
  "Return a string that uses embedfile to embed all tangled files."
  (mapconcat
   (lambda (file-desc)
     (format "\\IfFileExists{%1$s}{\\embedfile[desc=%2$s]{%1$s}}{}"
             (thread-last (car file-desc)
               (replace-regexp-in-string "\\\\" "\\\\\\\\")
               (replace-regexp-in-string "~" "\\\\string~"))
             (cdr file-desc)))
   (append
    (mapcar (lambda (f-block)
              (let ((file-lang (cons (or (car f-block) (caddr (cadr f-block))) (caadr f-block))))
                (cons (car file-lang) (format "Tangled %s file" (cdr file-lang)))))
            (org-babel-tangle-collect-blocks)) ; all files being tangled to
    (let (extra-files)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\+embed:" nil t)
          (let* ((file-desc (split-string (org-element-property :value (org-element-at-point)) " :desc\\(?:ription\\)? ")))
            (push (cons (car file-desc) (or (cdr file-desc) "Extra file")) extra-files))))
      (nreverse extra-files)))
   "\n"))
#+end_src

现在所有 tangle 文件都将被嵌入，我们可以像这样嵌入任意文件：
#+begin_src org
,#+embed: some-file :description flavour text about the file
#+end_src

这目前不会完成或类似的事情，因为我们还没有告诉 Org 它是一个关键字。它也是 LaTeX
特有的，所以也许应该将它更改为 =#+latex_embed= 或类似的东西。
***** 内容-特征-序言关联
最初，这个想法是通过一个 alist 实现的，该 alist 将搜索当前 Org 文件以指示需要
某些功能的结构，并在提供该功能的序言中插入一个 LaTeX 片段。当检测到的特征与支持
这些特征所需的 LaTeX 代码之间存在双射时，这一切都很好，但在许多情况下，这种关系
不是单射的。

为了更好地模拟实际情况，我在这个过程中添加了一个额外的层，其中每个检测到的特征都
会给出一个所需的 「特征标志」列表。只需合并功能标志列表，我们不再需要注入性来避免
LaTeX 重复。然后额外的层在特征标志和可用于实现该特征的规范之间形成双射。

该模型还提供了许多不错的次要好处，例如功能依赖的简单实现。

#+begin_src dot :file misc/org-latex-clever-preamble.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" width="1.3" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [color="#aaaaaa" penwidth="1.2"]
    rankdir=LR

    node[group=a,color="#2ec27e"]
    "file:*.svg"
    "file:*.jpeg"
    "file:*.png"
    "#+caption"
    "xkcd:*"
    node[group=b,color="#f5c211"]
    "svg"
    "image"
    "caption"
    node[group=c,color="#813d9c"]
    "(TeX) svg"
    "(TeX) graphicx"
    "(TeX) caption"

    "file:*.svg" -> "svg" -> "(TeX) svg"
    "file:*.jpeg" -> "image" -> "(TeX) graphicx"
    "file:*.png" -> "image"
    "(TeX) svg":s -> "(TeX) graphicx":n [constraint=false]
    "#+caption" -> "caption" -> "(TeX) caption"
    "xkcd:*" -> "image"
    "xkcd:*" -> "caption"
}
#+end_src

#+caption: Org 功能、功能标志和 LaTeX 片段之间的关联
#+attr_html: :class invertible :alt DAG showing how Org features flow through to LaTeX :style max-width:min(24em,100%)
#+attr_latex: :width 0.6\linewidth
[[file:misc/org-latex-clever-preamble.svg]]

首先，我们将实现该模型的特征检测组件。我希望它能够使用尽可能多的状态信息，因此功
能测试应该非常通用。

#+begin_src emacs-lisp
(defvar org-latex-embed-files t
  "Embed the source .org, .tex, and any tangled files.")
(defvar org-latex-use-microtype t
  "Use the microtype pakage.")
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(defvar org-latex-conditional-features
  '(("\\[\\[\\(?:file\\|https?\\):\\(?:[^]]\\|\\\\\\]\\)+?\\.\\(?:eps\\|pdf\\|png\\|jpeg\\|jpg\\|jbig2\\)\\]\\]\\|\\\\includegraphics[\\[{]" . image)
    ("\\[\\[\\(?:file\\|https?\\):\\(?:[^]]+?\\|\\\\\\]\\)\\.svg\\]\\]\\|\\\\includesvg[\\[{]" . svg)
    ("\\\\(\\|\\\\\\[\\|\\\\begin{\\(?:math\\|displaymath\\|equation\\|align\\|flalign\\|multiline\\|gather\\)[a-z]*\\*?}" . maths)
    ("^[ \t]*|" . table)
    ("cref:\\|\\cref{\\|\\[\\[[^\\]+\n?[^\\]\\]\\]" . cleveref)
    ("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
    ("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
    (":float wrap" . float-wrap)
    (":float sideways" . rotate)
    ("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
    ("\\[\\[xkcd:" . (image caption))
    (org-latex-use-microtype . microtype)
    ((and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}") . italic-quotes)
    (org-latex-par-sep . par-sep)
    ((org-latex-embed-extra-files) . embed-files)
    ((and org-latex-embed-files "^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC") . embed-tangled)
    ("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
    ("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
    ("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
    ("^[ \t]*#\\+begin_notes\\|\\\\begin{notes}"     . box-notes)
    ("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
    ("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
  "Org feature tests and associated LaTeX feature flags.

Alist where the car is a test for the presense of the feature,
and the cdr is either a single feature symbol or list of feature symbols.

When a string, it is used as a regex search in the buffer.
The feature is registered as present when there is a match.

The car can also be a
- symbol, the value of which is fetched
- function, which is called with info as an argument
- list, which is `eval'uated

If the symbol, function, or list produces a string: that is used as a regex
search in the buffer. Otherwise any non-nil return value will indicate the
existance of the feature.")
#+end_src

然后我们提供一种方法来生成提供这些功能的序言。除了
~org-latex-conditional-features~ 中命名的特性之外，我们还将创建元特性，这些
特性可能是其他特性所需要的 (=:requires=)，或者默认情况下是启用的
(=:eager t=)。为了进一步控制，我只能在某些其他功能处于启用状态 (=:when=) 并被
其他功能屏蔽 (=:prevents=) 时使用某些功能。我将使用以 =.= 开头的元功能的约定
，以及以 =!= 开头的 =:eager= 功能，使它们的性质更明显。

LaTeX 中的另一个考虑因素是加载顺序，这在某些情况下很重要。除此之外，有某种合理的
排序是很好的。为此我将介绍一个 =:order= 关键字。使用它将按如下方式排列片段。

+ =-2= 嵌入文件设置
+ =-1= 额外的文件嵌入
+ =0= 排版
  - =0= 字体本身
  - =0.1= 排版调整 (=microtype=)
  - =0.2= 数学设置
  - =0.3= 数学字体
  - =0.4= 额外的文字整形 (~\acr~)
  - =0.5-0.9= 其他文本修改，尝试将较短的片段放在首位
+ =1= (/default/)
+ =2= 表和图
+ =3= 其他短内容
+ =4= 各种 boxes

#+begin_src emacs-lisp
(defvar org-latex-feature-implementations
  '((image         :snippet "\\usepackage{graphicx}" :order 2)
    (svg           :snippet "\\usepackage[inkscapelatex=false]{svg}" :order 2)
    (maths         :snippet "\\usepackage[nofont]{bmc-maths}" :order 0.2)
    (table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
    (cleveref      :snippet "\\usepackage[capitalize]{cleveref}" :order 1) ; after bmc-maths
    (underline     :snippet "\\usepackage[normalem]{ulem}" :order 0.5)
    (float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
    (rotate        :snippet "\\usepackage{rotating}" :order 2)
    (caption       :snippet org-latex-caption-preamble :order 2.1)
    (microtype     :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}\n" :order 0.1)
    (embed-files   :snippet org-latex-embed-files-preamble :order -2)
    (embed-tangled :requires embed-files :snippet (concat (org-latex-embed-extra-files) "\n") :order -1)
    (acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
    (italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
    (par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
    (.pifont       :snippet "\\usepackage{pifont}")
    (.xcoffins     :snippet "\\usepackage{xcoffins}")
    (checkbox      :requires .pifont :order 3
                   :snippet (concat (unless (memq 'maths features)
                                      "\\usepackage{amssymb} % provides \\square")
                                    org-latex-checkbox-preamble))
    (.fancy-box    :requires (.pifont .xcoffins) :snippet org-latex-box-preamble :order 3.9)
    (box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{Warning}" :order 4)
    (box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{Information}" :order 4)
    (box-notes     :requires .fancy-box :snippet "\\defsimplebox{notes}{26a269}{Notes}" :order 4)
    (box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\vspace{-\\baselineskip}}" :order 4)
    (box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{Important}" :order 4))
  "LaTeX features and details required to implement them.

List where the car is the feature symbol, and the rest forms a plist with the
following keys:
- :snippet, which may be either
  - a string which should be included in the preamble
  - a symbol, the value of which is included in the preamble
  - a function, which is evaluated with the list of feature flags as its
    single argument. The result of which is included in the preamble
  - a list, which is passed to `eval', with a list of feature flags available
    as \"features\"

- :requires, a feature or list of features that must be available
- :when, a feature or list of features that when all available should cause this
    to be automatically enabled.
- :prevents, a feature or list of features that should be masked
- :order, for when ordering is important. Lower values appear first.
    The default is 0.
- :eager, when non-nil the feature will be eagerly loaded, i.e. without being detected.")
#+end_src
***** 特征确定
现在我们已经定义了 ~org-latex-conditional-features~ ，我们需要使用它来提取
在 Org 缓冲区中找到的特征列表。

#+begin_src emacs-lisp
(defun org-latex-detect-features (&optional buffer info)
  "List features from `org-latex-conditional-features' detected in BUFFER."
  (let ((case-fold-search nil))
    (with-current-buffer (or buffer (current-buffer))
      (delete-dups
       (mapcan (lambda (construct-feature)
                 (when (let ((out (pcase (car construct-feature)
                                    ((pred stringp) (car construct-feature))
                                    ((pred functionp) (funcall (car construct-feature) info))
                                    ((pred listp) (eval (car construct-feature)))
                                    ((pred symbolp) (symbol-value (car construct-feature)))
                                    (_ (user-error "org-latex-conditional-features key %s unable to be used" (car construct-feature))))))
                         (if (stringp out)
                             (save-excursion
                               (goto-char (point-min))
                               (re-search-forward out nil t))
                           out))
                   (if (listp (cdr construct-feature)) (cdr construct-feature) (list (cdr construct-feature)))))
               org-latex-conditional-features)))))
#+end_src

***** 序言生成
一旦确定了所需功能的列表，我们希望使用 ~org-latex-feature-implementations~
来生成 LaTeX，该 LaTeX 应该插入到序言中以提供这些功能。

首先，我们要在 ~org-latex-feature-implementations~ 中处理我们的关键字，以
生成扩展的功能列表。我们将通过执行以下步骤来做到这一点。

+ 每个列出的功能的依赖项都添加到功能列表 (src_elisp{:requires}) 中。
+ 每个特性的 src_elisp{:when} 条件，以及带有 src_elisp{:eager t} 的可用特
  性，都会被评估，并相应地添加 / 删除
+ src_elisp{:prevents} 值中存在的任何特性都将被删除
+ 功能列表清除重复项
+ 特征列表按 src_elisp{:order} (升序) 排序

#+begin_src emacs-lisp
(defun org-latex-expand-features (features)
  "For each feature in FEATURES process :requires, :when, and :prevents keywords and sort according to :order."
  (dolist (feature features)
    (unless (assoc feature org-latex-feature-implementations)
      (message "Feature %s not provided in org-latex-feature-implementations, ignoring." feature)
      (setq features (remove feature features))))
  (setq current features)
  (while current
    (when-let ((requirements (plist-get (cdr (assq (car current) org-latex-feature-implementations)) :requires)))
      (setcdr current (if (listp requirements)
                          (append requirements (cdr current))
                        (cons requirements (cdr current)))))
    (setq current (cdr current)))
  (dolist (potential-feature
           (append features (delq nil (mapcar (lambda (feat)
                                                (when (plist-get (cdr feat) :eager)
                                                  (car feat)))
                                              org-latex-feature-implementations))))
    (when-let ((prerequisites (plist-get (cdr (assoc potential-feature org-latex-feature-implementations)) :when)))
      (setf features (if (if (listp prerequisites)
                             (cl-every (lambda (preq) (memq preq features)) prerequisites)
                           (memq prerequisites features))
                         (append (list potential-feature) features)
                       (delq potential-feature features)))))
  (dolist (feature features)
    (when-let ((prevents (plist-get (cdr (assoc feature org-latex-feature-implementations)) :prevents)))
      (setf features (cl-set-difference features (if (listp prevents) prevents (list prevents))))))
  (sort (delete-dups features)
        (lambda (feat1 feat2)
          (if (< (or (plist-get (cdr (assoc feat1 org-latex-feature-implementations)) :order) 1)
                 (or (plist-get (cdr (assoc feat2 org-latex-feature-implementations)) :order) 1))
              t nil))))
#+end_src

现在我们有一个很好的最终要使用的特性列表，可以提取它们的片段并将结果连接在一起。

#+begin_src emacs-lisp
(defun org-latex-generate-features-preamble (features)
  "Generate the LaTeX preamble content required to provide FEATURES.
This is done according to `org-latex-feature-implementations'"
  (let ((expanded-features (org-latex-expand-features features)))
    (concat
     (format "\n%% features: %s\n" expanded-features)
     (mapconcat (lambda (feature)
                  (when-let ((snippet (plist-get (cdr (assoc feature org-latex-feature-implementations)) :snippet)))
                    (concat
                     (pcase snippet
                       ((pred stringp) snippet)
                       ((pred functionp) (funcall snippet features))
                       ((pred listp) (eval `(let ((features ',features)) (,@snippet))))
                       ((pred symbolp) (symbol-value snippet))
                       (_ (user-error "org-latex-feature-implementations :snippet value %s unable to be used" snippet)))
                     "\n")))
                expanded-features
                "")
     "% end features\n")))
#+end_src

然后需要建议 Org 实际使用这个生成的前导内容。
#+begin_src emacs-lisp
(defvar info--tmp nil)

(defadvice! org-latex-save-info (info &optional t_ s_)
  :before #'org-latex-make-preamble
  (setq info--tmp info))

(defadvice! org-splice-latex-header-and-generated-preamble-a (orig-fn tpl def-pkg pkg snippets-p &optional extra)
  "Dynamically insert preamble content based on `org-latex-conditional-preambles'."
  :around #'org-splice-latex-header
  (let ((header (funcall orig-fn tpl def-pkg pkg snippets-p extra)))
    (if snippets-p header
      (concat header
              (org-latex-generate-features-preamble (org-latex-detect-features nil info--tmp))
              "\n"))))
#+end_src

我对 ~info--tmp~ 的使用有点老套。 当我尝试将其上游化时，这应该会变得更加清晰，
因为我可以通过直接修改 ~org-latex-make-preamble~ 来传递信息。
***** 减少默认包
由于上文添加，我们可以从 ~org-latex-default-packages-alist~ 中删除一些包。

默认值中也有一些过时的条目，具体来说
+ =grffile= 的功能内置于当前版本的 =graphicsx=
+ =textcomp= 的功能已经包含在 LaTeX 的核心中一段时间了

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "xcolor" nil) ; Generally useful
        ("" "hyperref" nil)))
#+end_src

**** 字体集合
使用好用的条件序言，我将定义一些可用于 LaTeX 导出的字体集合。谁知道呢，
也许我会在某个时候将它与其他导出格式一起使用。

首先，我将创建一个默认状态变量并将字体集注册为 =#+options= 的一部分。

#+begin_src emacs-lisp
(defvar org-latex-default-fontset 'alegreya
  "Fontset from `org-latex-fontsets' to use by default.
As cm (computer modern) is TeX's default, that causes nothing
to be added to the document.

If \"nil\" no custom fonts will ever be used.")

(eval '(cl-pushnew '(:latex-font-set nil "fontset" org-latex-default-fontset)
                   (org-export-backend-options (org-export-get-backend 'latex))))
#+end_src

然后需要一个函数来生成应用字体集的 LaTeX 片段。如果可以为单个样式完成此操作并使用
不同样式作为主要文档字体，那就太好了。如果字体集的各个字体分别定义为
src_elisp{:serif}、 src_elisp{:sans}、 src_elisp{:mono} 和
src_elisp{:maths}。 我可以使用它们为完整字体集的子集生成 LaTeX。然后，如果我不
让任何字体集名称中包含 =-= ，我可以使用 =-sans= 和 =-mono= 作为指定要使用的文档
字体的后缀。


#+begin_src emacs-lisp
(defun org-latex-fontset-entry ()
  "Get the fontset spec of the current file.
Has format \"name\" or \"name-style\" where 'name' is one of
the cars in `org-latex-fontsets'."
  (let ((fontset-spec
         (symbol-name
          (or (car (delq nil
                         (mapcar
                          (lambda (opt-line)
                            (plist-get (org-export--parse-option-keyword opt-line 'latex)
                                       :latex-font-set))
                          (cdar (org-collect-keywords '("OPTIONS"))))))
              org-latex-default-fontset))))
    (cons (intern (car (split-string fontset-spec "-")))
          (when (cadr (split-string fontset-spec "-"))
            (intern (concat ":" (cadr (split-string fontset-spec "-"))))))))

(defun org-latex-fontset (&rest desired-styles)
  "Generate a LaTeX preamble snippet which applies the current fontset for DESIRED-STYLES."
  (let* ((fontset-spec (org-latex-fontset-entry))
         (fontset (alist-get (car fontset-spec) org-latex-fontsets)))
    (if fontset
        (concat
         (mapconcat
          (lambda (style)
            (when (plist-get fontset style)
              (concat (plist-get fontset style) "\n")))
          desired-styles
          "")
         (when (memq (cdr fontset-spec) desired-styles)
           (pcase (cdr fontset-spec)
             (:serif "\\renewcommand{\\familydefault}{\\rmdefault}\n")
             (:sans "\\renewcommand{\\familydefault}{\\sfdefault}\n")
             (:mono "\\renewcommand{\\familydefault}{\\ttdefault}\n"))))
      (error "Font-set %s is not provided in org-latex-fontsets" (car fontset-spec)))))
#+end_src

现在所有的功能都已经实现了，我们应该把它挂到我们的序言生成中。

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '(org-latex-default-fontset . custom-font) t)
(add-to-list 'org-latex-feature-implementations '(custom-font :snippet (org-latex-fontset :serif :sans :mono) :order 0) t)
(add-to-list 'org-latex-feature-implementations '(.custom-maths-font :eager t :when (custom-font maths) :snippet (org-latex-fontset :maths) :order 0.3) t)
#+end_src

最后，我们只需要添加一些字体。

#+begin_src emacs-lisp
(defvar org-latex-fontsets
  '((cm nil) ; computer modern
    (## nil) ; no font set
    (alegreya
     :serif "\\usepackage[osf]{Alegreya}"
     :sans "\\usepackage{AlegreyaSans}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (biolinum
     :serif "\\usepackage[osf]{libertineRoman}"
     :sans "\\usepackage[sfdefault,osf]{biolinum}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[libertine,varvw]{newtxmath}")
    (fira
     :sans "\\usepackage[sfdefault,scale=0.85]{FiraSans}"
     :mono "\\usepackage[scale=0.80]{FiraMono}"
     :maths "\\usepackage{newtxsf} % change to firamath in future?")
    (kp
     :serif "\\usepackage{kpfonts}")
    (newpx
     :serif "\\usepackage{newpxtext}"
     :sans "\\usepackage{gillius}"
     :mono "\\usepackage[scale=0.9]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (noto
     :serif "\\usepackage[osf]{noto-serif}"
     :sans "\\usepackage[osf]{noto-sans}"
     :mono "\\usepackage[scale=0.96]{noto-mono}"
     :maths "\\usepackage{notomath}")
    (plex
     :serif "\\usepackage{plex-serif}"
     :sans "\\usepackage{plex-sans}"
     :mono "\\usepackage[scale=0.95]{plex-mono}"
     :maths "\\usepackage{newtxmath}") ; may be plex-based in future
    (source
     :serif "\\usepackage[osf,semibold]{sourceserifpro}"
     :sans "\\usepackage[osf,semibold]{sourcesanspro}"
     :mono "\\usepackage[scale=0.92]{sourcecodepro}"
     :maths "\\usepackage{newtxmath}") ; may be sourceserifpro-based in future
    (times
     :serif "\\usepackage{newtxtext}"
     :maths "\\usepackage{newtxmath}"))
  "Alist of fontset specifications.
Each car is the name of the fontset (which cannot include \"-\").

Each cdr is a plist with (optional) keys :serif, :sans, :mono, and :maths.
A key's value is a LaTeX snippet which loads such a font.")
#+end_src

当我们使用 Alegreya 时，我们可以对 =表格= 应用一个可爱的小调整，它 (本地) 改变了
用于衬里固定宽度的图表。

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '((string= (car (org-latex-fontset-entry)) "alegreya") . alegreya-typeface))
(add-to-list 'org-latex-feature-implementations '(alegreya-typeface) t)
(add-to-list 'org-latex-feature-implementations'(.alegreya-tabular-figures :eager t :when (alegreya-typeface table) :order 0.5 :snippet "
\\makeatletter
% tabular lining figures in tables
\\renewcommand{\\tabular}{\\AlegreyaTLF\\let\\@halignto\\@empty\\@tabular}
\\makeatother\n") t)
#+end_src

由于 Alegreya 的指标，\LaTeX 符号看起来不太正确。我们可以通过使用微妙的字距调整
来重新定义它来纠正这个问题。

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '("LaTeX" . latex-symbol))
(add-to-list 'org-latex-feature-implementations '(latex-symbol :when alegreya-typeface :order 0.5 :snippet "
\\makeatletter
% Kerning around the A needs adjusting
\\DeclareRobustCommand{\\LaTeX}{L\\kern-.24em%
        {\\sbox\\z@ T%
         \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts
                              \\fontsize\\sf@size\\z@
                              \\math@fontsfalse\\selectfont
                              A}%
                        \\vss}%
        }%
        \\kern-.10em%
        \\TeX}
\\makeatother\n") t)
#+end_src

**** 封面
要制作漂亮的封面，想到的一个简单方法就是重新定义 =\maketitle= 。为了精确控制定位
，我们将使用 =tikz= 包，然后添加 Tikz 库 =calc= 和 =shape.geometric= 来为背
景做一些漂亮的装饰。

我将首先为序言设置必要的补充。 这将完成以下任务：
+ 加载所需的包
+ 重新定义 =\maketitle=
+ 用 Tikz 画一个 =Org= 图标，用在封面上 (这是一个小彩蛋)
+ 通过重新定义 =\tableofcontents= 在目录之后开始一个新页面

#+name: latex-cover-page
#+begin_src LaTeX
\\usepackage{tikz}
\\usetikzlibrary{shapes.geometric}
\\usetikzlibrary{calc}

\\newsavebox\\orgicon
\\begin{lrbox}{\\orgicon}
  \\begin{tikzpicture}[y=0.80pt, x=0.80pt, inner sep=0pt, outer sep=0pt]
    \\path[fill=black!6] (16.15,24.00) .. controls (15.58,24.00) and (13.99,20.69) .. (12.77,18.06)arc(215.55:180.20:2.19) .. controls (12.33,19.91) and (11.27,19.09) .. (11.43,18.05) .. controls (11.36,18.09) and (10.17,17.83) .. (10.17,17.82) .. controls (9.94,18.75) and (9.37,19.44) .. (9.02,18.39) .. controls (8.32,16.72) and (8.14,15.40) .. (9.13,13.80) .. controls (8.22,9.74) and (2.18,7.75) .. (2.81,4.47) .. controls (2.99,4.47) and (4.45,0.99) .. (9.15,2.41) .. controls (14.71,3.99) and (17.77,0.30) .. (18.13,0.04) .. controls (18.65,-0.49) and (16.78,4.61) .. (12.83,6.90) .. controls (10.49,8.18) and (11.96,10.38) .. (12.12,11.15) .. controls (12.12,11.15) and (14.00,9.84) .. (15.36,11.85) .. controls (16.58,11.53) and (17.40,12.07) .. (18.46,11.69) .. controls (19.10,11.41) and (21.79,11.58) .. (20.79,13.08) .. controls (20.79,13.08) and (21.71,13.90) .. (21.80,13.99) .. controls (21.97,14.75) and (21.59,14.91) .. (21.47,15.12) .. controls (21.44,15.60) and (21.04,15.79) .. (20.55,15.44) .. controls (19.45,15.64) and (18.36,15.55) .. (17.83,15.59) .. controls (16.65,15.76) and (15.67,16.38) .. (15.67,16.38) .. controls (15.40,17.19) and (14.82,17.01) .. (14.09,17.32) .. controls (14.70,18.69) and (14.76,19.32) .. (15.50,21.32) .. controls (15.76,22.37) and (16.54,24.00) .. (16.15,24.00) -- cycle(7.83,16.74) .. controls (6.83,15.71) and (5.72,15.70) .. (4.05,15.42) .. controls (2.75,15.19) and (0.39,12.97) .. (0.02,10.68) .. controls (-0.02,10.07) and (-0.06,8.50) .. (0.45,7.18) .. controls (0.94,6.05) and (1.27,5.45) .. (2.29,4.85) .. controls (1.41,8.02) and (7.59,10.18) .. (8.55,13.80) -- (8.55,13.80) .. controls (7.73,15.00) and (7.80,15.64) .. (7.83,16.74) -- cycle;
  \\end{tikzpicture}
\\end{lrbox}

\\makeatletter
\\g@addto@macro\\tableofcontents{\\clearpage}
\\renewcommand\\maketitle{
  \\thispagestyle{empty}
  \\hyphenpenalty=10000 % hyphens look bad in titles
  \\renewcommand{\\baselinestretch}{1.1}
  \\let\\oldtoday\\today
  \\renewcommand{\\today}{\\LARGE\\number\\year\\\\\\large%
    \\ifcase \\month \\or Jan\\or Feb\\or Mar\\or Apr\\or May \\or Jun\\or Jul\\or Aug\\or Sep\\or Oct\\or Nov\\or Dec\\fi
    ~\\number\\day}
  \\begin{tikzpicture}[remember picture,overlay]
    %% Background Polygons %%
    \\foreach \\i in {2.5,...,22} % bottom left
    {\\node[rounded corners,black!3.5,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.west)+(2.5,-4.2)$) {} ;}
    \\foreach \\i in {0.5,...,22} % top left
    {\\node[rounded corners,black!5,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {} ;}
    \\node[rounded corners,fill=black!4,regular polygon,regular polygon sides=6, minimum size=5.5 cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {};
    \\foreach \\i in {0.5,...,24} % top right
    {\\node[rounded corners,black!2,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {} ;}
    \\node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2.5 cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {};
    \\foreach \\i in {21,...,3} % bottom right
    {\\node[black!3,rounded corners,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {} ;}
    \\node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2 cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {};
    \\node[align=center, scale=1.4] at ($(current page.south east)+(-1.5,0.75)$) {\\usebox\\orgicon};
    %% Text %%
    \\node[left, align=right, black, text width=0.8\\paperwidth, minimum height=3cm, rounded corners,font=\\Huge\\bfseries] at ($(current page.north east)+(-2,-8.5)$)
    {\\@title};
    \\node[left, align=right, black, text width=0.8\\paperwidth, minimum height=2cm, rounded corners, font=\\Large] at ($(current page.north east)+(-2,-11.8)$)
    {\\scshape \\@author};
    \\renewcommand{\\baselinestretch}{0.75}
    \\node[align=center,rounded corners,fill=black!3,text=black,regular polygon,regular polygon sides=6, minimum size=2.5 cm,inner sep=0, font=\\Large\\bfseries ] at ($(current page.west)+(2.5,-4.2)$)
    {\\@date};
  \\end{tikzpicture}
  \\let\\today\\oldtoday
  \\clearpage}
\\makeatother
#+end_src

现在我们有了一个不错的封面页，我们只需要不时使用它。将此添加到 =#+options= 感觉最
合适。让封面选项接受 auto 作为值，然后根据字数决定是否应使用封面 --- 我将把它作为
全局默认值。然后我们只想插入一个 LaTeX 片段在封面中来调整标题格式。
#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-cover-page 'auto
  "When t, use a cover page by default.
When auto, use a cover page when the document's wordcount exceeds
`org-latex-cover-page-wordcount-threshold'.

Set with #+option: coverpage:{yes,auto,no} in org buffers.")
(defvar org-latex-cover-page-wordcount-threshold 5000
  "Document word count at which a cover page will be used automatically.
This condition is applied when cover page option is set to auto.")
(defvar org-latex-subtitle-coverpage-format "\\\\\\bigskip\n\\LARGE\\mdseries\\itshape\\color{black!80} %s\\par"
  "Variant of `org-latex-subtitle-format' to use with the cover page.")
(defvar org-latex-cover-page-maketitle "
<<latex-cover-page>>
"
  "LaTeX snippet for the preamble that sets \\maketitle to produce a cover page.")

(eval '(cl-pushnew '(:latex-cover-page nil "coverpage" org-latex-cover-page)
                   (org-export-backend-options (org-export-get-backend 'latex))))

(defun org-latex-cover-page-p ()
  "Whether a cover page should be used when exporting this Org file."
  (pcase (or (car
              (delq nil
                    (mapcar
                     (lambda (opt-line)
                       (plist-get (org-export--parse-option-keyword opt-line 'latex) :latex-cover-page))
                     (cdar (org-collect-keywords '("OPTIONS"))))))
             org-latex-cover-page)
    ((or 't 'yes) t)
    ('auto (when (> (count-words (point-min) (point-max)) org-latex-cover-page-wordcount-threshold) t))
    (_ nil)))

(defadvice! org-latex-set-coverpage-subtitle-format-a (contents info)
  "Set the subtitle format when a cover page is being used."
  :before #'org-latex-template
  (when (org-latex-cover-page-p)
    (setf info (plist-put info :latex-subtitle-format org-latex-subtitle-coverpage-format))))

(add-to-list 'org-latex-feature-implementations '(cover-page :snippet org-latex-cover-page-maketitle :order 9) t)
(add-to-list 'org-latex-conditional-features '((org-latex-cover-page-p) . cover-page) t)
#+end_src
**** 精简列表
默认情况下 LaTeX 非常好，但是默认情况下它在列表项之间放置空间时真的很慷慨。我不能
接受。

值得庆幸的是，这很容易通过一个小片段来纠正：
#+name: latex-condense-lists
#+begin_src LaTeX
\\newcommand{\\setuplistspacing}{\\setlength{\\itemsep}{-0.5ex}\\setlength{\\parskip}{1.5ex}\\setlength{\\parsep}{0pt}}
\\let\\olditem\\itemize\\renewcommand{\\itemize}{\\olditem\\setuplistspacing}
\\let\\oldenum\\enumerate\\renewcommand{\\enumerate}{\\oldenum\\setuplistspacing}
\\let\\olddesc\\description\\renewcommand{\\description}{\\olddesc\\setuplistspacing}
#+end_src

然后我们可以用我们的序言把它 hook 进来。

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-condense-lists t
  "Reduce the space between list items.")
(defvar org-latex-condensed-lists "
<<latex-condense-lists>>
")

(add-to-list 'org-latex-conditional-features '((and org-latex-condense-lists "^[ \t]*[-+]\\|^[ \t]*[1Aa][.)] ") . condensed-lists) t)
(add-to-list 'org-latex-feature-implementations '(condensed-lists :snippet org-latex-condensed-lists :order 0.7) t)
#+end_src

**** 漂亮的代码块
我们可以只使用 =minted= 进行语法高亮 --- 但是，我们可以做得更好！
=engrave-faces= 包让我们可以使用 Emacs 的字体锁定来突出显示语法，并将其导出为
LaTeX 命令。

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! engrave-faces :recipe (:local-repo "lisp/engrave-faces"))
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src

我们将修改列表的生成方式，以使使用它变得如此简单：
#+begin_src emacs-lisp
(setq org-latex-listings 'engraved) ; NOTE non-standard value
#+end_src

由于 ~org-latex-conditional-features~ 和一些复制粘贴以及
~org-latex-scr-block~ 中的 =minted= 条目，我们可以轻松地将其添加为可识别的
~org-latex-listings~ 值。

#+begin_src emacs-lisp :noweb no-export
(defadvice! org-latex-src-block-engraved (orig-fn src-block contents info)
  "Like `org-latex-src-block', but supporting an engraved backend"
  :around #'org-latex-src-block
  (if (eq 'engraved (plist-get info :latex-listings))
      (org-latex-scr-block--engraved src-block contents info)
    (funcall orig-fn src-block contents info)))

(defadvice! org-latex-inline-src-block-engraved (orig-fn inline-src-block contents info)
  "Like `org-latex-inline-src-block', but supporting an engraved backend"
  :around #'org-latex-inline-src-block
  (if (eq 'engraved (plist-get info :latex-listings))
      (org-latex-inline-scr-block--engraved inline-src-block contents info)
    (funcall orig-fn src-block contents info)))

(defvar-local org-export-has-code-p nil)

(defadvice! org-export-expect-no-code (&rest _)
  :before #'org-export-as
  (setq org-export-has-code-p nil))

(defadvice! org-export-register-code (&rest _)
  :after #'org-latex-src-block-engraved
  :after #'org-latex-inline-src-block-engraved
  (setq org-export-has-code-p t))

(setq org-latex-engraved-code-preamble "
<<org-latex-engraved-code-preamble>>
")

(add-to-list 'org-latex-conditional-features '((and org-export-has-code-p "^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC\\|src_[A-Za-z]") . engraved-code) t)
(add-to-list 'org-latex-conditional-features '("^[ \t]*#\\+begin_example\\|^[ \t]*#\\+BEGIN_EXAMPLE" . engraved-code-setup) t)
(add-to-list 'org-latex-feature-implementations '(engraved-code :requires engraved-code-setup :snippet (engrave-faces-latex-gen-preamble) :order 99) t)
(add-to-list 'org-latex-feature-implementations '(engraved-code-setup :snippet org-latex-engraved-code-preamble :order 98) t)

(defun org-latex-scr-block--engraved (src-block contents info)
  (let* ((lang (org-element-property :language src-block))
         (attributes (org-export-read-attribute :attr_latex src-block))
         (float (plist-get attributes :float))
         (num-start (org-export-get-loc src-block info))
         (retain-labels (org-element-property :retain-labels src-block))
         (caption (org-element-property :caption src-block))
         (caption-above-p (org-latex--caption-above-p src-block info))
         (caption-str (org-latex--caption/label-string src-block info))
         (placement (or (org-unbracket-string "[" "]" (plist-get attributes :placement))
                        (plist-get info :latex-default-figure-position)))
         (float-env
          (cond
           ((string= "multicolumn" float)
            (format "\\begin{listing*}[%s]\n%s%%s\n%s\\end{listing*}"
                    placement
                    (if caption-above-p caption-str "")
                    (if caption-above-p "" caption-str)))
           (caption
            (format "\\begin{listing}[%s]\n%s%%s\n%s\\end{listing}"
                    placement
                    (if caption-above-p caption-str "")
                    (if caption-above-p "" caption-str)))
           ((string= "t" float)
            (concat (format "\\begin{listing}[%s]\n"
                            placement)
                    "%s\n\\end{listing}"))
           (t "%s")))
         (options (plist-get info :latex-minted-options))
         (content-buffer
          (with-temp-buffer
            (insert
             (let* ((code-info (org-export-unravel-code src-block))
                    (max-width
                     (apply 'max
                            (mapcar 'length
                                    (org-split-string (car code-info)
                                                      "\n")))))
               (org-export-format-code
                (car code-info)
                (lambda (loc _num ref)
                  (concat
                   loc
                   (when ref
                     ;; Ensure references are flushed to the right,
                     ;; separated with 6 spaces from the widest line
                     ;; of code.
                     (concat (make-string (+ (- max-width (length loc)) 6)
                                          ?\s)
                             (format "(%s)" ref)))))
                nil (and retain-labels (cdr code-info)))))
            (funcall (org-src-get-lang-mode lang))
            (engrave-faces-latex-buffer)))
         (content
          (with-current-buffer content-buffer
            (buffer-string)))
         (body
          (format
           "\\begin{Code}\n\\begin{Verbatim}[%s]\n%s\\end{Verbatim}\n\\end{Code}"
           ;; Options.
           (concat
            (org-latex--make-option-string
             (if (or (not num-start) (assoc "linenos" options))
                 options
               (append
                `(("linenos")
                  ("firstnumber" ,(number-to-string (1+ num-start))))
                options)))
            (let ((local-options (plist-get attributes :options)))
              (and local-options (concat "," local-options))))
           content)))
    (kill-buffer content-buffer)
    ;; Return value.
    (format float-env body)))

(defun org-latex-inline-scr-block--engraved (inline-src-block _contents info)
  (let ((options (org-latex--make-option-string
                  (plist-get info :latex-minted-options)))
        code-buffer code)
    (setq code-buffer
          (with-temp-buffer
            (insert (org-element-property :value inline-src-block))
            (funcall (org-src-get-lang-mode
                      (org-element-property :language inline-src-block)))
            (engrave-faces-latex-buffer)))
    (setq code (with-current-buffer code-buffer
                 (buffer-string)))
    (kill-buffer code-buffer)
    (format "\\Verb%s{%s}"
            (if (string= options "") ""
              (format "[%s]" options))
            code)))
#+end_src

每当使用它时，为了让它实际工作 (并且看起来更好一点) ，我们在序言中添加一点：

#+name: org-latex-engraved-code-preamble
#+begin_src LaTeX
\\usepackage{fvextra}
\\fvset{
  commandchars=\\\\\\{\\},
  highlightcolor=white!95!black!80!blue,
  breaklines=true,
  breaksymbol=\\color{white!60!black}\\tiny\\ensuremath{\\hookrightarrow}}
\\renewcommand\\theFancyVerbLine{\\footnotesize\\color{black!40!white}\\arabic{FancyVerbLine}}

\\definecolor{codebackground}{HTML}{f7f7f7}
\\definecolor{codeborder}{HTML}{f0f0f0}
\\providecolor{EFD}{HTML}{28292e}

% TODO have code boxes keep line vertical alignment
\\usepackage[breakable,xparse]{tcolorbox}
\\DeclareTColorBox[]{Code}{o}%
{colback=codebackground, colframe=codeborder,
  fontupper=\\footnotesize,
  colupper=EFD,
  IfNoValueTF={#1}%
  {boxsep=2pt, arc=2.5pt, outer arc=2.5pt,
    boxrule=0.5pt, left=2pt}%
  {boxsep=2.5pt, arc=0pt, outer arc=0pt,
    boxrule=0pt, leftrule=1.5pt, left=0.5pt},
  right=2pt, top=1pt, bottom=0.5pt,
  breakable}
#+end_src

对此的一个小烦恼是微型字体和 =verbatim= 环境之间的交互。突出在这里是不可取的。值
得庆幸的是，我们可以修补 =verbatim= 环境以在本地关闭突出显示。
#+begin_src emacs-lisp
(add-to-list 'org-latex-feature-implementations
             '(.no-protrusion-in-code :snippet "\\let\\oldcode\\Code\\renewcommand{\\Code}{\\microtypesetup{protrusion=false}\\oldcode}"
                                      :when (microtype engraved-code-setup)
                                      :eager t
                                      :order 98.5) t)
#+end_src

在某些时候，让盒子颜色易于定制会很好。目前，使用
src_elisp{(setq engrave-faces-preset-styles (engrave-faces-generate-preset))}
更改语法突出显示颜色相当容易，但也许需要切换，它指定是否使用默认值、当前主题、 或任
何命名的主题可能是一个好主意。还应该可以动态设置匹配的框背景。命名主题可以通过在缓存
目录中查找具有特定名称的样式定义来工作，然后切换到该主题并生成 (并保存) 样式定义
(如果它不存在)。

现在让我们为示例块设置类似的样式。
#+begin_src emacs-lisp
(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
  "Like `org-latex-example-block', but supporting an engraved backend"
  :around #'org-latex-example-block
  (let ((output-block (funcall orig-fn example-block contents info)))
    (if (eq 'engraved (plist-get info :latex-listings))
        (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
      output-block)))
#+end_src

除了非常出色的视觉输出之外，这对于代码繁重的文档 (如此配置) 的编译速度也应该更快。

用这个文档做一个小基准测试，我发现确实是这样。
| LaTeX 语法高亮后端 | 编译时间 | 超出基准时间 | 超出率 |
|--------------------+----------+--------------+--------|
| verbatim           | 12 s     | 0            |    0.0 |
| lstlistings        | 15 s     | 3 s          |    0.2 |
| Engrave            | 34 s     | 22 s         |    1.8 |
| Pygments (Minted)  | 184 s    | 172 s        |   14.3 |
#+TBLFM: $3=$2-@2$2::$4=$3 / @2$2;%.1f

=verbatim= (无语法高亮) 结果视为基线；这个初步测试表明， =engrave-faces= 比
pygments 快八倍左右，只需要 =verbatim= (无语法高亮) 的 3 倍时间。
**** Julia 代码块
Julia 代码对 unicode 有极好的支持！缺点是 =pdflatex= 与 unicode 符号一起使用
仍然很痛苦。解决方案 --- =lualatex= 。现在我们只需要让它自动化

#+begin_src emacs-lisp
(defadvice! org-latex-pick-compiler (_contents info)
  :before #'org-latex-template
  (when (and org-export-has-code-p (memq 'julia-code (org-latex-detect-features)))
    (setf info (plist-put
                (if (member #'+org-latex-replace-non-ascii-chars (plist-get info :filter-final-output))
                    (plist-put info :filter-final-output
                               (delq #'+org-latex-replace-non-ascii-chars (plist-get info :filter-final-output)))
                  info)
                :latex-compiler "lualatex"))))
#+end_src

然后必须使用支持 unicode 的字体。JuliaMono 是显而易见的选择，我们可以将它与
=fontspec= 包一起使用。将其设置为备用字体可能会很好 (如果这样做并不痛苦)。

#+name: julia-mono-fontspec
#+begin_src LaTeX
\\usepackage{fontspec}
\\newfontfamily\\JuliaMono{JuliaMono-Regular.ttf}[Path=/usr/share/fonts/truetype/, Extension=.ttf]
\\newfontface\\JuliaMonoRegular{JuliaMono-Regular}
\\setmonofont{JuliaMonoRegular}[Contextuals=Alternate, Scale=MatchLowercase]
#+end_src

现在剩下的就是将其 hook 进序言。

#+begin_src emacs-lisp :noweb no-export
(setq org-latex-julia-mono-fontspec "
<<julia-mono-fontspec>>
")

(add-to-list 'org-latex-feature-implementations '(julia-code :snippet org-latex-julia-mono-fontspec :order 0) t)
(add-to-list 'org-latex-conditional-features '((and org-export-has-code-p "^[ \t]*#\\+begin_src julia\\|^[ \t]*#\\+BEGIN_SRC julia\\|src_julia") . julia-code) t)

(add-to-list 'org-latex-feature-implementations '(.microtype-lualatex :eager t :when (microtype julia-code) :prevents microtype :order 0.1 :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,factor=2000]{microtype}\n"))
(add-to-list 'org-latex-feature-implementations '(.custom-font-no-mono :eager t :prevents custom-font :order 0 :snippet (org-latex-fontset :serif :sans)) t)
#+end_src

**** Emojis
在使用的地方实际包含表情符号会很好。多亏了 =emojify= ，我们有了一个表情符号图像文
件夹用于使用 🙂。

首先，我们想要检测表情符号何时实际存在。我们可以尝试使用 =[?-?]= 正则表达式组的集
合检查 unicode 范围，但 Emojis 实际上分布在相当多的地方，因此这不是很简单。相反
，我可以迭代彻底的非 ASCII 字符并检查是否有任何文本属性 =emojified= 。

#+begin_src emacs-lisp
(defun emojify-emoji-in-buffer-p ()
  "Determine if any emojis are present in the current buffer, using `emojify-mode'."
  (unless emojify-mode
    (emojify-mode 1)
    (emojify-display-emojis-in-region (point-min) (point-max)))
  (let (emoji-found end)
    (save-excursion
      (goto-char (point-min))
      (while (not (or emoji-found end))
        (if-let ((pos (re-search-forward "[^[:ascii:]]" nil t)))
            (when (get-text-property (1- pos) 'emojified)
              (setq emoji-found t))
          (setq end t))))
    emoji-found))
#+end_src

一旦我们知道存在表情符号，我们就可以在缓冲区中添加一些前导码以使插入更容易。

#+begin_src emacs-lisp
(defun org-latex-emoji-setup ()
  (format "\\newcommand\\emoji[1]{\\raisebox{-0.3ex}{\\includegraphics[height=1.8ex]{%s/#1}}}" (emojify-image-dir)))

(add-to-list 'org-latex-conditional-features '((emojify-emoji-in-buffer-p) . emoji) t)
(add-to-list 'org-latex-feature-implementations '(emoji :requires image :snippet (org-latex-emoji-setup) :order 3 ))
#+end_src

再次使用 =emojify= ，我们可以相当轻松地为我们的表情符号生成 LaTeX 命令。
#+begin_src emacs-lisp
(defun emojify-latexify-emoji-in-buffer ()
  (unless emojify-mode
    (emojify-mode 1)
    (emojify-display-emojis-in-region (point-min) (point-max)))
  (let (end)
    (save-excursion
      (goto-char (point-min))
      (while (not end)
        (if-let ((pos (re-search-forward "[^[:ascii:]]\\{1,2\\}" nil t)))
            (when-let ((char (get-text-property (1- pos) 'emojify-text))
                       (emoji (emojify-get-emoji char)))
              (replace-match (format "\\\\emoji{%s}" (file-name-sans-extension (ht-get emoji "image")))))
          (setq end t))))))
#+end_src

现在我们只需要将这个方便的函数 hook 到 Org 的导出中。我们不能使用标准的字符串替换
，因为我们依赖于 src_elisp{(emojify-mode)} 指定的缓冲区修改。

由于我还没有实现在 src_elisp{(org-latex-generate-features-preamble)} 之外
共享特征检测信息的好方法，我们将在尝试 LaTeXify 表情符号之前使用相同的检查，并希望
不会发生任何奇怪的事情。

#+begin_src emacs-lisp
(defun +org-latex-convert-emojis (text backend _info)
  (when (org-export-derived-backend-p backend 'latex)
    (with-temp-buffer
      (insert text)
      (when (emojify-emoji-in-buffer-p)
        (emojify-latexify-emoji-in-buffer)
        (buffer-string)))))

(add-to-list 'org-export-filter-final-output-functions #'+org-latex-convert-emojis)
#+end_src

这工作得相当好，我们可以执行一点点 QOL 升级。 =emojify= 下载 ~72x72~ 版本的
Twemoji，但也会生成 SVG 版本。我们可以使用 inkscape 将它们转换为 PDF，这可能是最适合的情况。

首先，值得检查 =.pdf= 图形文件是否会优先于 =.png= 文件。如果是这样，那将是理想的
，因为在获取和转换文件之后不需要额外的努力。

#+begin_src shell :tangle no :exports both :results output verbatim :wrap example
texdef -t pdflatex -p graphicx Gin@extensions
#+end_src

#+RESULTS:
#+begin_example
\Gin@extensions:
macro:->.pdf,.png,.jpg,.mps,.jpeg,.jbig2,.jb2,.PDF,.PNG,.JPG,.JPEG,.JBIG2,.JB2,.eps
#+end_example

极好的！我们可以看到 =.pdf= 实际上在优先级列表中排在第一位。所以现在我们只需要获取
和转换这些 SVG --- 理想情况下使用一个方便的命令来为我们做这件事。

#+begin_src emacs-lisp
(defun org-latex-emoji-install-vector-graphics ()
  "Dowload, convert, and install vector emojis for use with LaTeX."
  (interactive)
  (let ((dir (org-latex-emoji-install-vector-graphics--download)))
    (org-latex-emoji-install-vector-graphics--convert dir)
    (org-latex-emoji-install-vector-graphics--install dir))
  (message "Vector emojis installed."))

(defun org-latex-emoji-install-vector-graphics--download ()
  (message "Locating latest emojis...")
  (let* ((twemoji-url (substring (shell-command-to-string "echo \"https://github.com$(curl -sL https://github.com/twitter/twemoji/releases/latest | grep '.zip\"' | cut -d '\"' -f 2)\"") 0 -1))
         (twemoji-version (replace-regexp-in-string "^.*tags/v\\(.*\\)\\.zip" "\\1" twemoji-url))
         (twemoji-dest-folder (make-temp-file "twemoji-" t)))
    (message "Downloading Twemoji v%s" twemoji-version)
    (let ((default-directory twemoji-dest-folder))
      (call-process "curl" nil nil nil "-L" twemoji-url "--output" "twemoji.zip")
      (message "Unzipping")
      (call-process "unzip" nil nil nil "twemoji.zip")
      (concat twemoji-dest-folder "/twemoji-" twemoji-version "/assets/svg"))))

(defun org-latex-emoji-install-vector-graphics--convert (dir)
  (let ((default-directory dir))
    (if (executable-find "cairosvg") ; cairo's PDFs are ~10% smaller
        (let* ((images (directory-files dir nil ".*.svg"))
               (num-images (length images))
               (index 0)
               (max-threads (1- (string-to-number (shell-command-to-string "nproc"))))
               (threads 0))
          (while (< index num-images)
            (setf threads (1+ threads))
            (message "Converting emoji %d/%d (%s)" (1+ index) num-images (nth index images))
            (make-process :name "cairosvg"
                          :command (list "cairosvg" (nth index images) "-o" (concat (file-name-sans-extension (nth index images)) ".pdf"))
                          :sentinel (lambda (proc msg)
                                      (when (memq (process-status proc) '(exit signal))
                                        (setf threads (1- threads)))))
            (setq index (1+ index))
            (while (> threads max-threads)
              (sleep-for 0.01)))
          (while (> threads 0)
            (sleep-for 0.01))
          (message "Finished conversion!")))
    (shell-command "inkscape --batch-process --export-type='pdf' *.svg")))

(defun org-latex-emoji-install-vector-graphics--install (dir)
  (message "Installing vector emojis into emoji directory")
  (let ((images (directory-files dir t ".*.pdf"))
        (emoji-dir (concat (emojify-image-dir) "/")))
    (mapcar
     (lambda (image)
       (rename-file image emoji-dir t))
     images)))
#+end_src

**** 移除非 ascii 字符
使用 ~pdflatex~ 时，几乎非 ascii 字符一般都有问题，不会出现在 pdf 中。最好看到
有一些字符没有显示，而不是什么都没有。

我们检查每个非 ascii 字符，以确保它不是使用 =utf8= 选项加载时由 =inputenc= 包
编码的字符。最后，我们看看我们是否有自己的 LaTeX 转换可以应用，如果没有，我们用
=¿= 替换非 ascii 字符。

否以确保我们只删除无法显示的字符，我们检查
=/usr/share/texmf/tex/latex/base/utf8enc.dfu= 。

我们只需要确保将其附加到过滤器函数列表中，因为我们想让表情符号处理首先发生。

#+begin_src emacs-lisp
(defvar +org-pdflatex-inputenc-encoded-chars
  "[[:ascii:]\u00A0-\u01F0\u0218-\u021BȲȳȷˆˇ˜˘˙˛˝\u0400-\u04FFḂḃẞ\u200C\u2010-\u201E†‡•…‰‱‹›※‽⁄⁎⁒₡₤₦₩₫€₱℃№℗℞℠™Ω℧℮←↑→↓〈〉␢␣◦◯♪⟨⟩Ḡḡ\uFB00-\uFB06]")

(defun +org-latex-replace-non-ascii-chars (text backend info)
  "Replace non-ascii chars with \\char\"XYZ forms."
  (when (and (org-export-derived-backend-p backend 'latex)
             (string= (plist-get info :latex-compiler) "pdflatex"))
    (let (case-replace)
      (replace-regexp-in-string "[^[:ascii:]]"
                                (lambda (nonascii)
                                  (if (string-match-p +org-pdflatex-inputenc-encoded-chars nonascii) nonascii
                                    (or (cdr (assoc nonascii +org-latex-non-ascii-char-substitutions)) "¿")))
                                text))))

(add-to-list 'org-export-filter-final-output-functions #'+org-latex-replace-non-ascii-chars t)
#+end_src

现在，有些符号没有包含在 =inputenc= 中，但无论如何我们应该能够处理。我们为他们定
义了一张 LaTeX 翻译表。

#+name: latex-non-ascii-char-substitutions
| Character | LaTeX           |
|-----------+-----------------|
| ɑ         | \(\alpha\)      |
| β         | \(\beta\)       |
| γ         | \(\gamma\)      |
| δ         | \(\delta\)      |
| ε         | \(\epsilon\)    |
| ϵ         | \(\varepsilon\) |
| ζ         | \(\zeta\)       |
| η         | \(\eta\)        |
| θ         | \(\theta\)      |
| ϑ         | \(\vartheta\)   |
| ι         | \(\iota\)       |
| κ         | \(\kappa\)      |
| λ         | \(\lambda\)     |
| μ         | \(\mu\)         |
| ν         | \(\nu\)         |
| ξ         | \(\xi\)         |
| π         | \(\pi\)         |
| ϖ         | \(\varpi\)      |
| ρ         | \(\rho\)        |
| ϱ         | \(\varrho\)     |
| σ         | \(\sigma\)      |
| ς         | \(\varsigma\)   |
| τ         | \(\tau\)        |
| υ         | \(\upsilon\)    |
| ϕ         | \(\phi\)        |
| φ         | \(\varphi\)     |
| ψ         | \(\psi\)        |
| ω         | \(\omega\)      |
| Γ         | \(\Gamma\)      |
| Δ         | \(\Delta\)      |
| Θ         | \(\Theta\)      |
| Λ         | \(\Lambda\)     |
| Ξ         | \(\Xi\)         |
| Π         | \(\Pi\)         |
| Σ         | \(\Sigma\)      |
| Υ         | \(\Upsilon\)    |
| Φ         | \(\Phi\)        |
| Ψ         | \(\Psi\)        |
| Ω         | \(\Omega\)      |
| א         | \(\aleph\)      |
| ב         | \(\beth\)       |
| ד         | \(\daleth\)     |
| ג         | \(\gimel\)      |

#+name: gen-latex-non-ascii-char-substitutions
#+begin_src emacs-lisp :noweb-ref none :var latex-non-ascii-char-substitutions=latex-non-ascii-char-substitutions
(replace-regexp-in-string
 " '((" "\n   '(("
 (replace-regexp-in-string
  ") (" ")\n     ("
  (prin1-to-string
   `(defvar +org-latex-non-ascii-char-substitutions
      ',(mapcar
         (lambda (entry)
           (cons (car entry) (replace-regexp-in-string "\\\\" "\\\\\\\\" (cadr entry))))
         latex-non-ascii-char-substitutions)))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<gen-latex-non-ascii-char-substitutions()>>
#+end_src

**** 缩写后的普通空格
在 LaTeX 中，单词和句子空间通常具有不同的宽度。当使用缩写时，这可能是一个问题，
i.e. e.g. etc. et al.. 。这可以通过使用 src_LaTeX{\ } 强制一个正常空格来纠正
。在导出Org文档的时候，我们可以添加一个过滤器来检查常见的缩写，让空格正常。

#+begin_src emacs-lisp
(defvar +org-latex-abbreviations
  '(;; Latin
    "cf." "e.g." "etc." "et al." "i.e." "v." "vs." "viz." "n.b."
    ;; Corperate
    "inc." "govt." "ltd." "pty." "dept."
    ;; Temporal
    "est." "c."
    ;; Honorifics
    "Prof." "Dr." "Mr." "Mrs." "Ms." "Miss." "Sr." "Jr."
    ;; Components of a work
    "ed." "vol." "sec." "chap." "pt." "pp." "op." "no."
    ;; Common usage
    "approx." "misc." "min." "max.")
  "A list of abbreviations that should be spaced correctly when exporting to LaTeX.")

(defun +org-latex-correct-latin-abbreviation-spaces (text backend _info)
  "Normalise spaces after Latin abbreviations."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string (rx (group (or line-start space)
                                         (regexp (regexp-opt-group +org-latex-abbreviations)))
                                  (or line-end space))
                              "\\1\\\\ "
                              text)))

(add-to-list 'org-export-filter-paragraph-functions #'+org-latex-correct-latin-abbreviation-spaces t)
#+end_src

**** 额外的特殊字符串
LaTeX 已经将 =---= 和 =--= 识别为 em/en-dashes， =\-= 作为连字符，并且将
=...= 转换为 =\ldots{}= 被硬编码在 ~org-latex-plain-text~ 中 (不像
~org-html-plain-text~)。

我也很想重定义 =->= 和 =<-= ，所以让我们提出一些建议。

#+begin_src emacs-lisp
(defvar org-latex-extra-special-string-regexps
  '(("->" . "\\\\textrightarrow{}")
    ("<-" . "\\\\textleftarrow{}")))

(defun org-latex-convert-extra-special-strings (string)
  "Convert special characters in STRING to LaTeX."
  (dolist (a org-latex-extra-special-string-regexps string)
    (let ((re (car a))
          (rpl (cdr a)))
      (setq string (replace-regexp-in-string re rpl string t)))))

(defadvice! org-latex-plain-text-extra-special-a (orig-fn text info)
  "Make `org-latex-plain-text' handle some extra special strings."
  :around #'org-latex-plain-text
  (let ((output (funcall orig-fn text info)))
    (when (plist-get info :with-special-strings)
      (setq output (org-latex-convert-extra-special-strings output)))
    output))
#+end_src

**** 支持来自 URL 的图像
您可以轻松链接到远程图像，并且它们可以很好地与基于 HTML 的导出配合使用。但是，
LaTeX 只能包含本地文件，因此 =org-latex-link= 的当前行为只是将 URL 插入到图像
中。

通过将图像下载到可预测的位置并使用它，我们可以做得更好。通过使文件名可预测而不仅仅是
一个临时文件，这可以提供一种缓存机制。
#+begin_src emacs-lisp
(defadvice! +org-latex-link (orig-fn link desc info)
  "Acts as `org-latex-link', but supports remote images."
  :around #'org-latex-link
  (setq o-link link
        o-desc desc
        o-info info)
  (if (and (member (plist-get (cadr link) :type) '("http" "https"))
           (member (file-name-extension (plist-get (cadr link) :path))
                   '("png" "jpg" "jpeg" "pdf" "svg")))
      (org-latex-link--remote link desc info)
    (funcall orig-fn link desc info)))

(defun org-latex-link--remote (link _desc info)
  (let* ((url (plist-get (cadr link) :raw-link))
         (ext (file-name-extension url))
         (target (format "%s%s.%s"
                         (temporary-file-directory)
                         (replace-regexp-in-string "[./]" "-"
                                                   (file-name-sans-extension (substring (plist-get (cadr link) :path) 2)))
                         ext)))
    (unless (file-exists-p target)
      (url-copy-file url target))
    (setcdr link (--> (cadr link)
                   (plist-put it :type "file")
                   (plist-put it :path target)
                   (plist-put it :raw-link (concat "file:" target))
                   (list it)))
    (concat "% fetched from " url "\n"
            (org-latex--inline-image link info))))
#+end_src

**** 变色龙 --- 又名匹配主题
一旦我有了让生成的 LaTeX 文档的外观与当前的 Emacs 主题相匹配的想法，我就欣喜若狂
。结果是类 ~变色龙~ ，我在包 =ox-chameleon= 中实现了它。

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! ox-chameleon :recipe (:local-repo "lisp/ox-chameleon"))
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! ox-chameleon
  :after ox)
#+end_src

**** 使 verbatim 与 code 不同
既然已经在上面做了这么多的努力，我们通过让 =verbatim= 使用 ~verb~ 而不是
~protectedtexttt~ (默认) 来充分利用它。

这提供了与 [[*使 verbatim 与 code 不同][HTML 导出部分]] 中提到的相同的优点。

#+begin_src emacs-lisp
(setq org-latex-text-markup-alist
      '((bold . "\\textbf{%s}")
        (code . protectedtexttt)
        (italic . "\\emph{%s}")
        (strike-through . "\\sout{%s}")
        (underline . "\\uline{%s}")
        (verbatim . verb)))
#+end_src

**** 检查所需的包
对于我如何设置 Org 的 LaTeX 导出，需要以下包：
#+name: org-latex-required-packages-list
| Package    | Description                                           |
|------------+-------------------------------------------------------|
| adjustbox  | Adjust general LaTeX material in like includegraphics |
| amsmath    | A near-essential maths package                        |
| booktabs   | Nice horizontal lines in tables                       |
| cancel     | Cancel terms in equations                             |
| capt-of    | Captions outside floats                               |
| caption    | Finer control over captions                           |
| cleveref   | Easy cross-referencing                                |
| embedall   | Embed files in the document                           |
| float      | Floating environments                                 |
| fontenc    | Font encodings                                        |
| fvextra    | Enhanced verbatim environments                        |
| graphicx   | An extended graphics package                          |
| hanging    | Used by oc-csl                                        |
| hyperref   | Links                                                 |
| inputenc   | Input file encodings                                  |
| longtable  | Multi-page tables                                     |
| mathalpha  | Set extended math alphabet fonts                      |
| mathtools  | Typesetting tools for maths                           |
| microtype  | Microtypography                                       |
| pdfx       | Create pdf/a- and pdf/x- compatible documents         |
| pifont     | A collection of symbols                               |
| preview    | Needed for AUCTeX and ob-latex                        |
| scrbase    | KOMA classes and more                                 |
| siunitx    | Proper unit support                                   |
| soul       | Strikethrough and underline, flexibly                 |
| subcaption | Form subfigures and subcaptions                       |
| svg        | Insert SVG images                                     |
| tikz       | Generally handy, as a dependancy and for graphics     |
| tcolorbox  | Nice boxes for code                                   |
| textcomp   | Font encodings                                        |
| xcolor     | Colours                                               |
| xparse     | Extended command/env definition forms                 |
| xcoffins   | Manipulate coffins (boxes) for typesetting            |

然后依赖的各种字体集：
#+name: org-latex-font-packages-list
+ Alegreya
+ arev
+ biolinum
+ FiraMono
+ FiraSans
+ fourier
+ gillius
+ kpfonts
+ libertine
+ newpxmath
+ newpxtext
+ newtxmath
+ newtxtext
+ newtxsf
+ noto
+ plex-mono
+ plex-sans
+ plex-serif
+ sourcecodepro
+ sourcesanspro
+ sourceserifpro

我们可以编写一个函数，使用 =kpsewhich= 检查这些包中的每一个，然后如果其中任何一个
丢失，我们将在生成的配置中注入一些建议，该配置会获取丢失包的列表并在每次导出时在
PDF 格式中警告我们。

#+name: org-missing-latex-packages
#+begin_src emacs-lisp :noweb-ref none :var org-latex-required-packages-list=org-latex-required-packages-list[,0] :var org-latex-font-packages-list=org-latex-font-packages-list
(setq org-required-latex-packages (append org-latex-required-packages-list
                                          (mapcar #'car org-latex-font-packages-list)))

(defun check-for-latex-packages (packages)
  (delq nil (mapcar (lambda (package)
                      (unless
                          (= 0 (shell-command (format "kpsewhich %s.sty" package)))
                        package))
                    packages)))

(if-let ((missing-pkgs (check-for-latex-packages org-required-latex-packages)))
    (concat
     (pp-to-string `(setq org-required-latex-packages ',org-required-latex-packages))
     (message ";; Detected missing LaTeX packages: %s\n" (mapconcat #'identity missing-pkgs ", "))
     (pp-to-string
      '(defun check-for-latex-packages (packages)
         (delq nil (mapcar (lambda (package)
                             (unless
                                 (= 0 (shell-command (format "kpsewhich %s.sty" package)))
                               package))
                           packages))))
     (pp-to-string
      '(defun +org-warn-about-missing-latex-packages (&rest _)
         (message "Checking for missing LaTeX packages...")
         (sleep-for 0.4)
         (if-let (missing-pkgs (check-for-latex-packages org-required-latex-packages))
             (message "%s You are missing the following LaTeX packages: %s."
                      (propertize "Warning!" 'face '(bold warning))
                      (mapconcat (lambda (pkg) (propertize pkg 'face 'font-lock-variable-name-face))
                                 missing-pkgs
                                 ", "))
           (message "%s You have all the required LaTeX packages. Run %s to make this message go away."
                    (propertize "Success!" 'face '(bold success))
                    (propertize "doom sync" 'face 'font-lock-keyword-face))
           (advice-remove 'org-latex-export-to-pdf #'+org-warn-about-missing-latex-packages))
         (sleep-for 1)))
     (pp-to-string
      '(advice-add 'org-latex-export-to-pdf :before #'+org-warn-about-missing-latex-packages)))
  ";; No missing LaTeX packags detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<org-missing-latex-packages()>>
#+end_src

*** 幻灯片导出
如果能使用不同的主题就很好了
It's nice to use a different theme
#+begin_src emacs-lisp
(setq org-beamer-theme "[progressbar=foot]metropolis")
#+end_src

#+begin_src emacs-lisp
(defun org-beamer-p (info)
  (eq 'beamer (and (plist-get info :back-end) (org-export-backend-name (plist-get info :back-end)))))

(add-to-list 'org-latex-conditional-features '(org-beamer-p . beamer) t)
(add-to-list 'org-latex-feature-implementations '(beamer :requires .missing-koma :prevents (italic-quotes condensed-lists)) t)
(add-to-list 'org-latex-feature-implementations '(.missing-koma :snippet "\\usepackage{scrextend}" :order 2) t)
#+end_src

而且我认为将演示文稿分成几个部分是很自然的，例如简介、概述…… 所以让我们将标题级别设置
为从 ~1~ 到 ~2~ 的帧。
#+begin_src emacs-lisp
(setq org-beamer-frame-level 2)
#+end_src

*** Reveal 导出
默认情况下显示相当不错，我认为只需要调整一点点。

#+begin_src emacs-lisp
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      org-re-reveal-plugins '(markdown notes math search zoom))
#+end_src

*** ASCII 导出

当 UTF-8 存在时，为什么要满足于 ASCII？
#+begin_src emacs-lisp
(setq org-ascii-charset 'utf-8)
#+end_src

ASCII 导出通常不错，我认为从改进中收益的主要方面是 LaTeX 片段的外观，我们可以使
用一个很好的程序来创建更好的 unicode 表示。它叫做 ~latex2text~ ，并[[https://repology.org/project/python:pylatexenc/versions][没有真正的
打成 elisp 包]]，它是 =pylatexenc= 的一部分。因此将使用 =pip= 安装它。

#+begin_src shell :tangle (if (executable-find "latex2text") "no" "setup.sh")
sudo python3 -m pip install pylatexenc
#+end_src

安装后，我们可以覆盖 src_elisp{(org-ascii-latex-fragment)} 和
src_elisp{(org-ascii-latex-environment)} 函数，它们非常方便
--- 只需提取内容并缩进。我们只会在设置 =utf-8= 时做一些不同的事情。

#+begin_src emacs-lisp :noweb-ref none :tangle (if (executable-find "latex2text") "yes" "no")
(after! ox-ascii
  (defvar org-ascii-convert-latex t
    "Use latex2text to convert LaTeX elements to unicode.")

  (defadvice! org-ascii-latex-environment-unicode-a (latex-environment _contents info)
    "Transcode a LATEX-ENVIRONMENT element from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
    :override #'org-ascii-latex-environment
    (when (plist-get info :with-latex)
      (org-ascii--justify-element
       (org-remove-indentation
        (let* ((latex (org-element-property :value latex-environment))
               (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                             org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
          (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
              (cdr unicode) latex)))
       latex-environment info)))

  (defadvice! org-ascii-latex-fragment-unicode-a (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
    :override #'org-ascii-latex-fragment
    (when (plist-get info :with-latex)
      (let* ((latex (org-element-property :value latex-fragment))
             (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                           org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
        (if (and unicode (= (car unicode) 0)) ; utf-8 set, and sucessfully ran latex2text
            (cdr unicode) latex)))))
#+end_src

*** Markdown 导出
**** GFM
由于 /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][Markdown 实现的多样性]]/ ，实际上并没有标准的表格规范……或标准的任何东西。因
为 ~org-md~ 表现的与众不同，它只是对所有这些非标准化元素 (很多) 使用 HTML。因此
ox-gfm 可以方便地导出具有 GitHub 拥有的所有功能的 Markdown。

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! ox-gfm :pin "99f93011b069e02b37c9660b8fcb45dab086a07f")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! ox-gfm
  :after ox)
#+end_src

**** 字符替换
当我想在某处粘贴导出的 Markdown 时 (例如在使用 [[Emacs Everywhere][Emacs Everywhere]] 时)，最好使用
unicode 字符 =---= 而不是 =&#x2014;= 。

为此，我们只需要在本地重新绑定提供的这些 alist。
#+begin_src emacs-lisp
(defadvice! org-md-plain-text-unicode-a (orig-fn text info)
  "Locally rebind `org-html-special-string-regexps'"
  :around #'org-md-plain-text
  (let ((org-html-special-string-regexps
         '(("\\\\-" . "-")
           ("---\\([^-]\\|$\\)" . "—\\1")
           ("--\\([^-]\\|$\\)" . "–\\1")
           ("\\.\\.\\." . "…")
           ("->" . "→")
           ("<-" . "←"))))
    (funcall orig-fn text (plist-put info :with-smart-quotes nil))))
#+end_src

将来，我可能想仅在使用 =ox-gfm= 时启用检查 =信息= 。

另一个值得考虑的是 LaTeX 格式。似乎大多数 Markdown 解析器都专注于 TeX 样式的语法
 (=$= 和 =$$=)。不幸的是，为了获得良好的渲染，最好兼容它们。

=ox-md= 没有为此提供转码器，因此必须自己创建并将它们推送到 =md= 转码器列表中。

#+begin_src emacs-lisp
(after! ox-md
  (defun org-md-latex-fragment (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to Markdown."
    (let ((frag (org-element-property :value latex-fragment)))
      (cond
       ((string-match-p "^\\\\(" frag)
        (concat "$" (substring frag 2 -2) "$"))
       ((string-match-p "^\\\\\\[" frag)
        (concat "$$" (substring frag 2 -2) "$$"))
       (t (message "unrecognised fragment: %s" frag)
          frag))))

  (defun org-md-latex-environment (latex-environment contents info)
    "Transcode a LATEX-ENVIRONMENT object from Org to Markdown."
    (concat "$$\n"
            (org-html-latex-environment latex-environment contents info)
            "$$\n"))

  (defun org-utf8-entity (entity _contents _info)
    "Transcode an ENTITY object from Org to utf-8.
CONTENTS are the definition itself.  INFO is a plist holding
contextual information."
    (org-element-property :utf-8 entity))

  ;; We can't let this be immediately parsed and evaluated,
  ;; because eager macro-expansion tries to call as-of-yet
  ;; undefined functions.
  ;; NOTE in the near future this shouldn't be required
  (eval
   '(dolist (extra-transcoder
             '((latex-fragment . org-md-latex-fragment)
               (latex-environment . org-md-latex-environment)
               (entity . org-utf8-entity)))
      (unless (member extra-transcoder (org-export-backend-transcoders
                                        (org-export-get-backend 'md)))
        (push extra-transcoder (org-export-backend-transcoders
                                (org-export-get-backend 'md)))))))
#+end_src

*** Babel
Doom 懒加载 babel 语言。它还引入了 [[https://github.com/astahlman/ob-async][ob-async]]，这太棒了，但如果默认使用它会更好。

=ob-async= 有两个注意事项：
1. 不支持 =:session=
  + 当设置了 =:session= 是我们不会使用 =:async=
2. 增加了执行的固定延迟
  + 这在许多情况下是不可取的，例如 =emacs-lisp= 代码通常不需要它
  + 因此，我还引入了一个异步语言黑名单来控制它何时自动启用

由于所需行为的细微差别，我建议 ~org-babel-get-src-block-info~ 智能地添加 =:async=
，而不是仅仅将 =:async= 添加到 ~org-babel-default-header-args~ 。作为一个 escape
hatch，它还将 =:sync= 识别为不应添加 =:async= 的指示。

我最初确实为除 =emacs-lisp= 和 =LaTeX= 之外的所有内容启用了此功能 (存在一些奇怪
的问题)，但这为每个 src 块评估增加了大约 3 秒的 "启动" 成本，这有点痛苦。由于
=:async= 可以通过 =#+properties= 轻松添加，因此我将此行为从黑名单转变为白名单。

#+begin_src emacs-lisp
(add-transient-hook! #'org-babel-execute-src-block
  (require 'ob-async))

(defvar org-babel-auto-async-languages '()
  "Babel languages which should be executed asyncronously by default.")

(defadvice! org-babel-get-src-block-info-eager-async-a (orig-fn &optional light datum)
  "Eagarly add an :async parameter to the src information, unless it seems problematic.
This only acts o languages in `org-babel-auto-async-languages'.
Not added when either:
+ session is not \"none\"
+ :sync is set"
  :around #'org-babel-get-src-block-info
  (let ((result (funcall orig-fn light datum)))
    (when (and (string= "none" (cdr (assoc :session (caddr result))))
               (member (car result) org-babel-auto-async-languages)
               (not (assoc :async (caddr result))) ; don't duplicate
               (not (assoc :sync (caddr result))))
      (push '(:async) (caddr result)))
    result))
#+end_src

*** ESS
我们不希望 ~R~ 评估挂起编辑器，因此
#+begin_src emacs-lisp
(setq ess-eval-visibly 'nowait)
#+end_src

语法高亮很好，所以让我们开启这些设置
#+begin_src emacs-lisp
(setq ess-R-font-lock-keywords
      '((ess-R-fl-keyword:keywords . t)
        (ess-R-fl-keyword:constants . t)
        (ess-R-fl-keyword:modifiers . t)
        (ess-R-fl-keyword:fun-defs . t)
        (ess-R-fl-keyword:assign-ops . t)
        (ess-R-fl-keyword:%op% . t)
        (ess-fl-keyword:fun-calls . t)
        (ess-fl-keyword:numbers . t)
        (ess-fl-keyword:operators . t)
        (ess-fl-keyword:delimiters . t)
        (ess-fl-keyword:= . t)
        (ess-R-fl-keyword:F&T . t)))
#+end_src

最后，如果使用 =JAGS= 最好能够使用 =jags= 作为语言标识符，而不是 =ess-jags= 。
#+begin_src emacs-lisp
(add-to-list '+org-babel-mode-alist '(jags . ess-jags))
#+end_src

** LaTeX
[[xkcd:1301]]
*** 随想随用
- 从剪贴板粘贴图像
  + 确定 ~graphicspath~ 中的第一个文件夹 (如果适用)
  + 询问文件名
  + 使用 ~xclip~ 将文件保存到图形文件夹或当前目录 (以适用者为准)
  #+begin_src shell :eval no :tangle no
command -v xclip >/dev/null 2>&1 || { echo >&1 "no xclip"; exit 1; }

if
    xclip -selection clipboard -target image/png -o >/dev/null 2>&1
then
    xclip -selection clipboard -target image/png -o >$1 2>/dev/null
    echo $1
else
    echo "no image"
fi
  #+end_src
  + 插入图形，填充详细信息 (文件名作为变量可能激活 =yasnippet=?)

*** 编译
#+begin_src emacs-lisp
(setq TeX-save-query nil
      TeX-show-compilation t
      TeX-command-extra-options "-shell-escape")
(after! latex
  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+end_src

对于查看 PDF，我更喜欢 pdf-tools 查看器。虽然 auctex 试图很好地识别我安装的一些
PDF 查看应用程序，但我不想让它默认使用它们，所以让我们重新排序首选项。
#+begin_src emacs-lisp
(setq +latex-viewers '(pdf-tools evince zathura okular skim sumatrapdf))
#+end_src

*** Snippet helpers
为了在新文件模板中使用，让我们列出一个我们可能想要使用的漂亮序言。
#+name: latex-nice-preamble
#+begin_src latex :tangle no
\\usepackage[pdfa,unicode=true,hidelinks]{hyperref}

\\usepackage[dvipsnames,svgnames,table,hyperref]{xcolor}
\\renewcommand{\\UrlFont}{\\ttfamily\\small}

\\usepackage[a-2b]{pdfx} % why not be archival

\\usepackage[T1]{fontenc}
\\usepackage[osf]{newpxtext}  % Palatino
\\usepackage{gillius}
\\usepackage[scale=0.9]{sourcecodepro}

\\usepackage[varbb]{newpxmath}
\\usepackage{mathtools}
\\usepackage{amssymb}

\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}
% microtype makes text look nicer

\\usepackage{graphicx} % include graphics

\\usepackage{booktabs} % nice table rules
#+end_src
然后让我们将内容绑定到一个函数，并定义一些不错的辅助函数。
#+begin_src emacs-lisp :noweb no-export
(setq tec/yas-latex-template-preamble "
<<latex-nice-preamble>>
")

(defun tec/yas-latex-get-class-choice ()
  "Prompt user for LaTeX class choice"
  (setq tec/yas-latex-class-choice (completing-read "Select document class: " '("article" "scrartcl" "bmc"))))

(defun tec/yas-latex-preamble-if ()
  "Based on class choice prompt for insertion of default preamble"
  (if (equal tec/yas-latex-class-choice "bmc") 'nil
    (eq (read-char-choice "Include default preamble? [Type y/n]" '(?y ?n)) ?y)))
#+end_src

**** 分隔符
#+begin_src emacs-lisp
(after! tex
  (defvar tec/tex-last-delim-char nil
    "Last open delim expanded in a tex document")
  (defvar tec/tex-delim-dot-second t
    "When the `tec/tex-last-delim-char' is . a second character (this) is prompted for")
  (defun tec/get-open-delim-char ()
    "Exclusivly read next char to tec/tex-last-delim-char"
    (setq tec/tex-delim-dot-second nil)
    (setq tec/tex-last-delim-char (read-char-exclusive "Opening deliminator, recognises: 9 ( [ { < | ."))
    (when (eql ?. tec/tex-last-delim-char)
      (setq tec/tex-delim-dot-second (read-char-exclusive "Other deliminator, recognises: 0 9 (  ) [ ] { } < > |"))))
  (defun tec/tex-open-delim-from-char (&optional open-char)
    "Find the associated opening delim as string"
    (unless open-char (setq open-char (if (eql ?. tec/tex-last-delim-char)
                                          tec/tex-delim-dot-second
                                        tec/tex-last-delim-char)))
    (pcase open-char
      (?\( "(")
      (?9  "(")
      (?\[ "[")
      (?\{ "\\{")
      (?<  "<")
      (?|  (if tec/tex-delim-dot-second "." "|"))
      (_   ".")))
  (defun tec/tex-close-delim-from-char (&optional open-char)
    "Find the associated closing delim as string"
    (if tec/tex-delim-dot-second
        (pcase tec/tex-delim-dot-second
          (?\) ")")
          (?0  ")")
          (?\] "]")
          (?\} "\\}")
          (?\> ">")
          (?|  "|")
          (_   "."))
      (pcase (or open-char tec/tex-last-delim-char)
        (?\( ")")
        (?9  ")")
        (?\[ "]")
        (?\{ "\\}")
        (?<  ">")
        (?\) ")")
        (?0  ")")
        (?\] "]")
        (?\} "\\}")
        (?\> ">")
        (?|  "|")
        (_   "."))))
  (defun tec/tex-next-char-smart-close-delim (&optional open-char)
    (and (bound-and-true-p smartparens-mode)
         (eql (char-after) (pcase (or open-char tec/tex-last-delim-char)
                             (?\( ?\))
                             (?\[ ?\])
                             (?{ ?})
                             (?< ?>)))))
  (defun tec/tex-delim-yas-expand (&optional open-char)
    (yas-expand-snippet (yas-lookup-snippet "_deliminators" 'latex-mode) (point) (+ (point) (if (tec/tex-next-char-smart-close-delim open-char) 2 1)))))
#+end_src

*** 编辑器视觉效果
让我们增强一下 ~TeX-fold-math~
#+begin_src emacs-lisp
(after! latex
  (setcar (assoc "⋆" LaTeX-fold-math-spec-list) "★")) ;; make \star bigger

(setq TeX-fold-math-spec-list
      `(;; missing/better symbols
        ("≤" ("le"))
        ("≥" ("ge"))
        ("≠" ("ne"))
        ;; convenience shorts -- these don't work nicely ATM
        ;; ("‹" ("left"))
        ;; ("›" ("right"))
        ;; private macros
        ("ℝ" ("RR"))
        ("ℕ" ("NN"))
        ("ℤ" ("ZZ"))
        ("ℚ" ("QQ"))
        ("ℂ" ("CC"))
        ("ℙ" ("PP"))
        ("ℍ" ("HH"))
        ("𝔼" ("EE"))
        ("𝑑" ("dd"))
        ;; known commands
        ("" ("phantom"))
        (,(lambda (num den) (if (and (TeX-string-single-token-p num) (TeX-string-single-token-p den))
                                (concat num "／" den)
                              (concat "❪" num "／" den "❫"))) ("frac"))
        (,(lambda (arg) (concat "√" (TeX-fold-parenthesize-as-necessary arg))) ("sqrt"))
        (,(lambda (arg) (concat "⭡" (TeX-fold-parenthesize-as-necessary arg))) ("vec"))
        ("‘{1}’" ("text"))
        ;; private commands
        ("|{1}|" ("abs"))
        ("‖{1}‖" ("norm"))
        ("⌊{1}⌋" ("floor"))
        ("⌈{1}⌉" ("ceil"))
        ("⌊{1}⌉" ("round"))
        ("𝑑{1}/𝑑{2}" ("dv"))
        ("∂{1}/∂{2}" ("pdv"))
        ;; fancification
        ("{1}" ("mathrm"))
        (,(lambda (word) (string-offset-roman-chars 119743 word)) ("mathbf"))
        (,(lambda (word) (string-offset-roman-chars 119951 word)) ("mathcal"))
        (,(lambda (word) (string-offset-roman-chars 120003 word)) ("mathfrak"))
        (,(lambda (word) (string-offset-roman-chars 120055 word)) ("mathbb"))
        (,(lambda (word) (string-offset-roman-chars 120159 word)) ("mathsf"))
        (,(lambda (word) (string-offset-roman-chars 120367 word)) ("mathtt"))
        )
      LaTeX-fold-macro-spec-list
      '(
        ;; as the defaults
        ("[f]" ("footnote" "marginpar"))
        ("[c]" ("cite"))
        ("[l]" ("label"))
        ("[r]" ("ref" "pageref" "eqref"))
        ("[i]" ("index" "glossary"))
        ("..." ("dots"))
        ("{1}" ("emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt"
                "textbf" "textsc" "textup"))
        ;; tweaked defaults
        ("©" ("copyright"))
        ("®" ("textregistered"))
        ("™"  ("texttrademark"))
        ("[1]:||►" ("item"))
        ("❡❡ {1}" ("part" "part*"))
        ("❡ {1}" ("chapter" "chapter*"))
        ("§ {1}" ("section" "section*"))
        ("§§ {1}" ("subsection" "subsection*"))
        ("§§§ {1}" ("subsubsection" "subsubsection*"))
        ("¶ {1}" ("paragraph" "paragraph*"))
        ("¶¶ {1}" ("subparagraph" "subparagraph*"))
        ;; extra
        ("⬖ {1}" ("begin"))
        ("⬗ {1}" ("end"))
        ))

(defun string-offset-roman-chars (offset word)
  "Shift the codepoint of each character in WORD by OFFSET with an extra -6 shift if the letter is lowercase"
  (apply 'string
         (mapcar (lambda (c)
                   (string-offset-apply-roman-char-exceptions
                    (+ (if (>= c 97) (- c 6) c) offset)))
                 word)))

(defvar string-offset-roman-char-exceptions
  '(;; lowercase serif
    (119892 .  8462) ; ℎ
    ;; lowercase caligraphic
    (119994 . 8495) ; ℯ
    (119996 . 8458) ; ℊ
    (120004 . 8500) ; ℴ
    ;; caligraphic
    (119965 . 8492) ; ℬ
    (119968 . 8496) ; ℰ
    (119969 . 8497) ; ℱ
    (119971 . 8459) ; ℋ
    (119972 . 8464) ; ℐ
    (119975 . 8466) ; ℒ
    (119976 . 8499) ; ℳ
    (119981 . 8475) ; ℛ
    ;; fraktur
    (120070 . 8493) ; ℭ
    (120075 . 8460) ; ℌ
    (120076 . 8465) ; ℑ
    (120085 . 8476) ; ℜ
    (120092 . 8488) ; ℨ
    ;; blackboard
    (120122 . 8450) ; ℂ
    (120127 . 8461) ; ℍ
    (120133 . 8469) ; ℕ
    (120135 . 8473) ; ℙ
    (120136 . 8474) ; ℚ
    (120137 . 8477) ; ℝ
    (120145 . 8484) ; ℤ
    )
  "An alist of deceptive codepoints, and then where the glyph actually resides.")

(defun string-offset-apply-roman-char-exceptions (char)
  "Sometimes the codepoint doesn't contain the char you expect.
Such special cases should be remapped to another value, as given in `string-offset-roman-char-exceptions'."
  (if (assoc char string-offset-roman-char-exceptions)
      (cdr (assoc char string-offset-roman-char-exceptions))
    char))

(defun TeX-fold-parenthesize-as-necessary (tokens &optional suppress-left suppress-right)
  "Add ❪ ❫ parenthesis as if multiple LaTeX tokens appear to be present"
  (if (TeX-string-single-token-p tokens) tokens
    (concat (if suppress-left "" "❪")
            tokens
            (if suppress-right "" "❫"))))

(defun TeX-string-single-token-p (teststring)
  "Return t if TESTSTRING appears to be a single token, nil otherwise"
  (if (string-match-p "^\\\\?\\w+$" teststring) t nil))
#+end_src

绑定一些模式下的快捷键，用起来更轻松
#+begin_src emacs-lisp
(after! tex
  (map!
   :map LaTeX-mode-map
   :ei [C-return] #'LaTeX-insert-item)
  (setq TeX-electric-math '("\\(" . "")))
#+end_src

数学定界符可以不用强调
#+begin_src emacs-lisp
;; Making \( \) less visible
(defface unimportant-latex-face
  '((t :inherit font-lock-comment-face :weight extra-light))
  "Face used to make \\(\\), \\[\\] less visible."
  :group 'LaTeX-math)

(font-lock-add-keywords
 'latex-mode
 `(("\\\\[]()[]" 0 'unimportant-latex-face prepend))
 'end)

;; (font-lock-add-keywords
;;  'latex-mode
;;  '(("\\\\[[:word:]]+" 0 'font-lock-keyword-face prepend))
;;  'end)
#+end_src

并为预览启用 shell 转义
#+begin_src emacs-lisp
(setq preview-LaTeX-command '("%`%l \"\\nonstopmode\\nofiles\
\\PassOptionsToPackage{" ("," . preview-required-option-list) "}{preview}\
\\AtBeginDocument{\\ifx\\ifPreview\\undefined"
preview-default-preamble "\\fi}\"%' \"\\detokenize{\" %t \"}\""))
#+end_src

*** 数学输入
**** CDLaTeX
默认情况下，符号和修改非常好，但可以做些补充。让我们将前缀更改为类似很少使用但
更方便的键，例如 =;= 。
#+begin_src emacs-lisp
(after! cdlatex
  (setq cdlatex-env-alist
        '(("bmatrix" "\\begin{bmatrix}\n?\n\\end{bmatrix}" nil)
          ("equation*" "\\begin{equation*}\n?\n\\end{equation*}" nil)))
  (setq ;; cdlatex-math-symbol-prefix ?\; ;; doesn't work at the moment :(
   cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow"  ""           "\\inf"))
     (?2    ("^2"           "\\sqrt{?}"     ""     ))
     (?3    ("^3"           "\\sqrt[3]{?}"  ""     ))
     (?^    ("\\uparrow"    ""           "\\sup"))
     (?k    ("\\kappa"      ""           "\\ker"))
     (?m    ("\\mu"         ""           "\\lim"))
     (?c    (""             "\\circ"     "\\cos"))
     (?d    ("\\delta"      "\\partial"  "\\dim"))
     (?D    ("\\Delta"      "\\nabla"    "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot" "\\dots"))
     (?:    ("\\vdots" "\\ddots"))
     (?*    ("\\times" "\\star" "\\ast")))
   cdlatex-math-modify-alist
   '( ;; my own stuff
     (?B    "\\mathbb"        nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+end_src
**** LAAS
这利用 =aas= (/自动激活片段/) 进行类似 CDLaTeX 的符号输入。

#+begin_src emacs-lisp :tangle packages.el
(package! laas :recipe (:local-repo "lisp/LaTeX-auto-activating-snippets"))
#+end_src

#+begin_src emacs-lisp
(use-package! laas
  :hook (LaTeX-mode . laas-mode)
  :config
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src

*** SyncTeX
#+begin_src emacs-lisp
(after! tex
  (add-to-list 'TeX-view-program-list '("Evince" "evince %o"))
  (add-to-list 'TeX-view-program-selection '(output-pdf "Evince")))
#+end_src

*** Fixes
Emacs28
#+begin_src emacs-lisp
(when EMACS28+
  (add-hook 'latex-mode-hook #'TeX-latex-mode))
#+end_src

** Python
由于我使用的是 =mypyls= ，正如 [[file:~/.emacs.d/modules/lang/python/README.org::*Language Server Protocol Support][:lang python LSP support]] 中所建议的，我将调整
=mypyls= 的优先级
#+begin_src emacs-lisp
(after! lsp-python-ms
  (set-lsp-priority! 'mspyls 1))
#+end_src

** PDF
*** MuPDF
虽然 =pdf-tools= 很好，但基于 =mupdf= 的解决方案更好。

#+begin_src emacs-lisp :tangle no
(package! paper :recipe (:host github :repo "ymarco/paper-mode"
                         :files ("*.el" ".so")
                         :pre-build ("make")))
#+end_src

#+begin_src emacs-lisp :tangle yes
;; (use-package paper
;;   ;; :mode ("\\.pdf\\'"  . paper-mode)
;;   ;; :mode ("\\.epub\\'"  . paper-mode)
;;   :config
;;   (require 'evil-collection-paper)
;;   (evil-collection-paper-setup))
#+end_src

*** 终端预览
有时我在终端中，但我仍然想查看内容。此外，有时我想对文本内容采取一些操作，因此想
要纯文本版本。多亏了 src_shell{pdftotext} 可以用它来进行方便的转换。我已经将它集
成到了 =pdftotext.el= 这个包中。
#+begin_src emacs-lisp :tangle packages.el
(package! pdftotext :recipe (:local-repo "lisp/pdftotext"))
#+end_src

输出可以稍微好一点，没有拼写错误，并且页面提要更漂亮 (默认为 =^L=)。

#+begin_src emacs-lisp
#+end_src

这很好，现在我们只需要将它与 =.pdf= 文件关联，并确保不优先使用 =pdf-tools= 。

最后，只要 Emacs 是非图形的 (即 TUI)，我们希望默认使用它。
#+begin_src emacs-lisp :tangle (if (executable-find "pdftotext") "yes" "no")
(use-package! pdftotext
  :init
  (unless (display-graphic-p)
    (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdftotext-mode))
    (add-to-list 'magic-mode-alist '("%PDF" . pdftotext-mode)))
  :config
  (unless (display-graphic-p) (after! pdf-tools (pdftotext-install)))
  ;; For prettyness
  (add-hook 'pdftotext-mode-hook #'spell-fu-mode-disable)
  (add-hook 'pdftotext-mode-hook (lambda () (page-break-lines-mode 1)))
  ;; I have no idea why this is needed
  (map! :map pdftotext-mode-map
        "<mouse-4>" (cmd! (scroll-down mouse-wheel-scroll-amount-horizontal))
        "<mouse-5>" (cmd! (scroll-up mouse-wheel-scroll-amount-horizontal))))
#+end_src

** R
*** 编辑器视觉体验
#+begin_src emacs-lisp
(after! ess-r-mode
  (appendq! +ligatures-extra-symbols
            '(:assign "⟵"
              :multiply "×"))
  (set-ligatures! 'ess-r-mode
    ;; Functional
    :def "function"
    ;; Types
    :null "NULL"
    :true "TRUE"
    :false "FALSE"
    :int "int"
    :floar "float"
    :bool "bool"
    ;; Flow
    :not "!"
    :and "&&" :or "||"
    :for "for"
    :in "%in%"
    :return "return"
    ;; Other
    :assign "<-"
    :multiply "%*%"))
#+end_src

** Julia
如 [[https://github.com/non-Jedi/lsp-julia/issues/35][lsp-julia#35]] 中所述， =lsp-mode= 似乎向 Julia 服务器提供了无效响应。
伪修复至少相当简单。
#+begin_src emacs-lisp
(after! julia-mode
  (add-hook 'julia-mode-hook #'rainbow-delimiters-mode-enable)
  (add-hook! 'julia-mode-hook
    (setq-local lsp-enable-folding t
                lsp-folding-range-limit 100)))
#+end_src

** Graphviz
Graphviz 是一种基于纯文本 .dot / .gv 文件可视化简单图形的好方法。
#+begin_src emacs-lisp :tangle packages.el
(package! graphviz-dot-mode :pin "a1b7d66f5c20404a1e59c2ee5e841022622535b8")
#+end_src

#+begin_src emacs-lisp
(use-package! graphviz-dot-mode
  :commands graphviz-dot-mode
  :mode ("\\.dot\\'" "\\.gz\\'")
  :init
  (after! org
    (setcdr (assoc "dot" org-src-lang-modes)
            'graphviz-dot)))

(use-package! company-graphviz-dot
  :after graphviz-dot-mode)
#+end_src

** Markdown
大多数情况下，当我编写 Markdown 时，它会进入一些应用程序 / 网站，它们会进行自己
的换行，因此我们 /只/ 想使用可视换行。而不是硬性的。
Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

由于 Markdown 通常被视为渲染的 HTML，让我们尝试在某种程度上模仿样式或 Markdown
渲染器。

大多数 Markdown 渲染似乎使前三个标题级别大于普通文本，前两个更大。然后第四层往往
与正文相同，而第五和第六层 (越来越小)，第六层变灰。第六关太小了，我把尝试将其再
提高一个档次。
#+begin_src emacs-lisp
(custom-set-faces!
  '(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
  '(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src

** Beancount
[[https://plaintextaccounting.org/][纯文本记账]]有许多相当引人注目的优势，[[https://www.ledger-cli.org/][分类帐]]是最明显的例子。然而 [[https://github.com/beancount/beancount][beancount]]，这个想
法的更新实现是账本兼容的 (这意味着如果我改变主意，我可以很容易地切换) 并且有一个
华丽的前端 --- [[https://beancount.github.io/fava/][fava]]。

当然，这是 Emacs 的一部分。

#+begin_src emacs-lisp :tangle packages.el
(package! beancount :recipe (:host github :repo "beancount/beancount-mode")
  :pin "ea8257881b7e276e8d170d724e3b2e179f25cb77")
#+end_src

#+begin_src emacs-lisp
(use-package! beancount
  :mode ("\\.beancount\\'" . beancount-mode)
  :init
  (after! all-the-icons
    (add-to-list 'all-the-icons-icon-alist
                 '("\\.beancount\\'" all-the-icons-material "attach_money" :face all-the-icons-lblue))
    (add-to-list 'all-the-icons-mode-icon-alist
                 '(beancount-mode all-the-icons-material "attach_money" :face all-the-icons-lblue)))
  :config
  (setq beancount-electric-currency t)
  (defun beancount-bal ()
    "Run bean-report bal."
    (interactive)
    (let ((compilation-read-command nil))
      (beancount--run "bean-report"
                      (file-relative-name buffer-file-name) "bal")))
  (map! :map beancount-mode-map
        :n "TAB" #'beancount-align-to-previous-number
        :i "RET" (cmd! (newline-and-indent) (beancount-align-to-previous-number))))
#+end_src
